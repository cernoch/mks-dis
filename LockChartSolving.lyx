#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass classicthesis
\begin_preamble
% Multi-row tables
\usepackage{multirow}

% Hack to remove [xetex] option,
% which does not work with sideways floats.
\usepackage{graphicx}

% Libraries for printing the graphs
\usepackage{tikz, pgf, pgfplots}
\usepackage{gnuplot-lua-tikz}
\usetikzlibrary{arrows,patterns,plotmarks,backgrounds,fit}
\usepgfplotslibrary{external} 
\tikzexternalize

% Hack to use biblatex in Lyx 2.2
\addbibresource{References.bib}

% Hack to use old font definitions
\scr@DeclareOldFontCommand{\rm}{\normalfont\rmfamily}{\mathrm}
\scr@DeclareOldFontCommand{\sf}{\normalfont\sffamily}{\mathsf}
\scr@DeclareOldFontCommand{\tt}{\normalfont\ttfamily}{\mathtt}
\scr@DeclareOldFontCommand{\bf}{\normalfont\bfseries}{\mathbf}
\scr@DeclareOldFontCommand{\it}{\normalfont\itshape}{\mathit}
\scr@DeclareOldFontCommand{\sl}{\normalfont\slshape}{\@nomath\sl}
\scr@DeclareOldFontCommand{\sc}{\normalfont\scshape}{\@nomath\sc}


% Footnote numbering restart per page
%\usepackage{perpage}
%\MakePerPage{footnote}

% Use (*) for footnotes
%\usepackage{alphalph}
%\makeatletter
%\newalphalph{\fnsymbolmult}[mult]{\@fnsymbol}{5}
%\makeatother
%\renewcommand*{\thefootnote}{%
%  \fnsymbolmult{\value{footnote}}%
%}

% Set header and footer
%\usepackage{fancyhdr}
%\lhead{Lock-chart solving}
%\chead{}
%\rhead{Radom\'ir \v{C}ernoch et al.}
%\lfoot{}
%\cfoot{\thepage}
%\rfoot{}

% Specify authors with affiliations
%\usepackage{authblk}
%\author[1]{Radom\'{i}r \v{C}ernoch\thanks{
% \href{mailto:radomir.cernoch@fel.cvut.cz}{radomir.cernoch@fel.cvut.cz}
% Department of Computer Science,
% Faculty of Electrical Engineering,
% Czech Technical University in Prague,
% Karlovo n\'{a}m\v{e}st\'{i} 13,
% 121 35 Praha 2}}
%\author[2]{Ond\v{r}ej Ku\v{z}elka\thanks{
% \href{mailto:kuzelkao@cs.cardiff.ac.uk}{kuzelkao@cs.cardiff.ac.uk}}}
%\author[1]{Filip \v{Z}elezny\thanks{
% \href{mailto:zelezny@fel.cvut.cz}{zelezny@fel.cvut.cz}}}
%\affil[1]{Czech Technical University in Prague}
%\affil[2]{Cardiff University}

\SetArgSty{textrm}
\end_preamble
\options eulerchapternumbers,xetex
\use_default_options false
\begin_modules
algorithm2e
theorems-ams
theorems-ams-extended
\end_modules
\maintain_unincluded_children false
\begin_local_layout
Provides graphicx 1
\end_local_layout
\language english
\language_package auto
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\graphics xetex
\default_output_format pdf4
\output_sync 1
\output_sync_macro "\synctex=1"
\bibtex_command bibtex8
\index_command default
\paperfontsize default
\spacing onehalf
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder true
\pdf_colorlinks true
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style apalike
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\leftmargin 1.15in
\topmargin 1.15in
\rightmargin 1.15in
\bottommargin 1.15in
\secnumdepth 1
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 2
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
frenchspacing
\backslash
raggedbottom
\backslash
pagenumbering{roman}
\backslash
pagestyle{empty}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\size large
Czech Technical University in Prague
\end_layout

\begin_layout Standard
\noindent
\align center

\size large
Faculty of Electrical Engineering
\begin_inset Newline newline
\end_inset

Department of Computer Science
\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\series bold
\size giant
Lock-chart solving
\end_layout

\begin_layout Standard
\noindent
\align center

\series bold
\size larger
Doctoral Thesis
\end_layout

\begin_layout Standard
\noindent
\align center

\size large
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\size larger
\emph on
Radomír Černoch, MSc.
\end_layout

\begin_layout Standard
\noindent
\align center

\size large
\begin_inset VSpace vfill
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\size large
Prague, October 2017
\end_layout

\begin_layout Standard
\noindent
\align center

\size large
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
Ph.D.
 Programme:
\begin_inset Newline newline
\end_inset

Electrical Engineering and Information Technology
\end_layout

\begin_layout Standard
\noindent
\align center
Branch of study:
\begin_inset Newline newline
\end_inset

Artificial Intelligence and Biocybernetics
\end_layout

\begin_layout Standard
\noindent
\align center

\size large
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\size large
Supervisor: prof.
 Ing.
 Filip Železný, Ph.D.
\end_layout

\begin_layout Standard
\noindent
\align center

\size large
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Chapter*
Abstract
\end_layout

\begin_layout Standard
Lock-chart solving (also known as master key system solving) is a process
 for designing mechanical keys and locks so that every key can open and
 be blocked in a user-defined set of locks.
 This work is an algorithmic study of lock-chart solving.
\end_layout

\begin_layout Standard
Literature on this topic 
\begin_inset CommandInset citation
LatexCommand cite
key "junker1999,lawer2004,oshall2015,vomel2017"

\end_inset

 has established that the extension variant of the problem is 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete, reformulated lock-chart solving as a constraint satisfaction
 problem (CSP) with set variables, applied a local search algorithm, and
 defined a sym\SpecialChar softhyphen
met\SpecialChar softhyphen
ry-breaking algorithm using au\SpecialChar softhyphen
to\SpecialChar softhyphen
mor\SpecialChar softhyphen
phisms.
\end_layout

\begin_layout Standard
However, the otherwise standard decision problem with a discrete search
 space has a twist.
 After a lock-chart is solved and its solution is fixed, new keys and locks
 may be added as a part of an extension, and the original solution should
 be prepared for this.
 In the first formal treatment of extensions, several scenarios are proposed,
 and effects on lock-chart solving algorithms are discussed.
\end_layout

\begin_layout Standard
First, we formalise lock-chart solving.
 6
\begin_inset space ~
\end_inset

variants of lock-charts and 4
\begin_inset space ~
\end_inset

constraint frameworks of increasing generality and applicability to real-world
 problems are formulated.
 Their hierarchy is used to extend the classification of lock-chart solving
 problems into computational complexity classes.
 A
\begin_inset space ~
\end_inset

close relationship between the most realistic framework and the Boolean
 satisfiability problem (SAT) is established.
 Mechanical profiles are shown to express 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete problems as a complement to the previous result on the extension
 problem variant.
 We give the first proof that diagonal lock-charts (systems with only one
 master key) can be solved in 
\begin_inset Formula $\mathcal{P}$
\end_inset

 using an algorithm known as 
\emph on
rotating constant method
\emph default
.
 
\end_layout

\begin_layout Standard
The practical part proposes several algorithms for lock-chart solving.
 The problem is translated into SAT, into CSP (with standard variables)
 and partly into the maximum independent set problem.
 The SAT translation inspires a model-counting algorithm tailored for lock-chart
s.
 Finally, we describe a customised depth-first-search (DFS) algorithm that
 uses the model-counter for pruning non-perspective parts of the search
 space.
 In the empirical evaluation, CSP and the customised DFS improve the performance
 of the previous automorphism algorithm.
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Chapter*
Abstrakt
\end_layout

\begin_layout Standard
Řešením systému generálního a hlavních klíčů (SGHK) se myslí návrh uzávěrů
 mechanických klíčů a blokovacích prvků zámků.
 Návrh musí respektovat požadavek, aby každý klíč v systému otevíral uživatelem
 zadanou množinu zámků.
 Tato práce poskytuje algoritmickou analýzu SGHK.
\end_layout

\begin_layout Standard
Relevantní literatura 
\begin_inset CommandInset citation
LatexCommand cite
key "junker1999,lawer2004,oshall2015,vomel2017"

\end_inset

 již dokázala jednu variantu problému jako 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-úplnou, přeformulovala problém jako programování s omezujícími podmínkami
 (CSP) s použitím množinových proměnných, aplikovala simulované žíhání a
 definovala symetrie stavového prostoru pomocí automorfismu.
\end_layout

\begin_layout Standard
Jinak běžná úloha s diskrétním stavovým prostorem má háček.
 Zákazník může objednat tzv.
 rozšíření – přidání nových klíčů a zámků do již vyrobeného SGHK.
 Prvotní řešení proto musí počítat s omezujícími podmínkami, jejichž přesná
 forma není v
\begin_inset space ~
\end_inset

době návrhu známa.
 Tato práce je dle našich znalostí první formální studí problému rozšíření
 SGHK.
\end_layout

\begin_layout Standard
Práce nejdříve formalizuje pojem SGHK v několika variantách a navrhuje čtyři
 způsoby formalizace omezujících podmínek od nejjednodušší po nejrealističtější.
 Hierarchie rozhodovacích úloh je využita pro klasifikaci do tříd výpočetní
 složitosti.
 Nejdříve je popsána úzká vazba na úlohu splnitelnosti vý\SpecialChar softhyphen
ro\SpecialChar softhyphen
ko\SpecialChar softhyphen
vých formulí
 (SAT).
 Mechanické profily se ukazují dostatečně expresivní pro překlad 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-úplných úloh, což doplňuje již existující výsledek.
 Práce obsahuje první důkaz příslušnosti diagonální úlohy (SGHK s generálním
 klíčem, ale bez dalších hlavních klíčů) do třídy 
\begin_inset Formula $\mathcal{P}$
\end_inset

 pomocí tzv.
 
\emph on
rotating constant method
\emph default
.
\end_layout

\begin_layout Standard
Praktická část práce navrhuje několik algoritmů pro řešení SGHK.
 Problém je přeložen na SAT, na CSP a jeho část na úlohu hledání maximální
 nezávislé množiny.
 Pro počítání počtu klíčů splňující omezující podmínky je použito dynamické
 programování a princip inkluze a exkluze.
 Závěrem je popsán upravený algoritmus prohledávání do hloubky (DFS), který
 prořezává neperspektivní části stavového prostoru pomocí počitadla klíčů.
 V
\begin_inset space ~
\end_inset

emprickém porovnání CSP a upravené DFS algoritmy prokázaly přínos stávajícímu
 algoritmu využívající automorfismy.
\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Chapter*
Publications
\end_layout

\begin_layout Standard
List of publications is presented for the purpose of dissertation defence.
 The degree of authorship is split between all authors of every publication
 equally.
\end_layout

\begin_layout Paragraph
Impacted journal articles relevant to the topic of this dissertation:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{refsection}[Publications1]
\end_layout

\begin_layout Plain Layout


\backslash
nocite{*}
\end_layout

\begin_layout Plain Layout


\backslash
printbibliography[heading=none]
\end_layout

\begin_layout Plain Layout


\backslash
end{refsection}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Other articles in impacted journals:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{refsection}[Publications2]
\end_layout

\begin_layout Plain Layout


\backslash
nocite{*}
\end_layout

\begin_layout Plain Layout


\backslash
printbibliography[heading=none]
\end_layout

\begin_layout Plain Layout


\backslash
end{refsection}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Other peer-reviewed conference papers:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{refsection}[Publications3]
\end_layout

\begin_layout Plain Layout


\backslash
nocite{*}
\end_layout

\begin_layout Plain Layout


\backslash
printbibliography[heading=none]
\end_layout

\begin_layout Plain Layout


\backslash
end{refsection}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagestyle{plain}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage clearpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begingroup
\end_layout

\begin_layout Plain Layout


\backslash
let
\backslash
clearpage
\backslash
relax
\end_layout

\begin_layout Plain Layout


\backslash
let
\backslash
cleardoublepage
\backslash
relax
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\begin_inset FloatList table

\end_inset


\begin_inset VSpace 8ex
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand*{
\backslash
addvspace}[1]{}
\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\begin_inset FloatList algorithm

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
endgroup
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage cleardoublepage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Section
Mechanical locks
\end_layout

\begin_layout Standard
There is hardly any technology as old, as trusted and as ubiquitous as mechanica
l keys and locks.
 The technology dates back to ancient Egypt 
\begin_inset CommandInset citation
LatexCommand cite
key "pulford2007,bbc2014"

\end_inset

 and some sources put it even further in history 
\begin_inset CommandInset citation
LatexCommand cite
key "james1995"

\end_inset

.
 Highly refined during the industrial revolution with notable improvements
 by famous Linus Yale, Sr.
 and Jr.
 
\begin_inset CommandInset citation
LatexCommand cite
key "pulford2007"

\end_inset

, mechanical keys and locks are omnipresent.
 Given the modern industry, they can be produced in large quantities and
 for low prices.
 In other words – if you do not have a mechanical lock at work, your house
 is probably equipped with one.
\end_layout

\begin_layout Standard
Even to this day, mechanical locks have remained somewhat romanticised.
 It is hard to imagine the Wild West without a safe robbery and even today
 words like “vault” and “burgled” make newspaper headlines 
\begin_inset CommandInset citation
LatexCommand cite
key "bbc2015"

\end_inset

.
 Lock-picking, the activity of overcoming locks without the proper key,
 has recently attracted many enthusiasts.
 Supported by a growing number of books 
\begin_inset CommandInset citation
LatexCommand cite
key "hampton1987,mccloud2007,ollam2012"

\end_inset

, holding regular competitions, supporters practice it as a hobby or a so-called
 locksport without malicious intents and they emphasise an ethical code
 
\begin_inset CommandInset citation
LatexCommand cite
key "wikiLocksport"

\end_inset

.
 The emotional side of mechanical locks is best illustrated by publication
 titles such as “The Secret Life of Keys” 
\begin_inset CommandInset citation
LatexCommand cite
key "vomel2017"

\end_inset

, which carries on the 19
\begin_inset script superscript

\begin_layout Plain Layout
th
\end_layout

\end_inset

-century tradition of bold statements about “indestructible” and “pick-proof”
 
\begin_inset CommandInset citation
LatexCommand cite
key "pulford2007"

\end_inset

 locks.
\end_layout

\begin_layout Standard
Mechanical locks are not only old but also resilient and refusing to die
 out.
 Admittedly, the most prominent competitor – the electronic lock – has certain
 advantages.
 Computer-equipped locks can, for example, restrict users on a time-scheduled
 basis or keep track of the users who opened them (or tried to open).
 Recent advancements 
\begin_inset CommandInset citation
LatexCommand cite
key "cliq"

\end_inset

 fit an electronic lock inside a standardised Euro-profile shell, which
 reduces the cost of electronic lock deployment.
 Especially in hotels, where keys are temporary, electronic locks possess
 a significant advantage.
\end_layout

\begin_layout Standard
Nevertheless, the mechanical lock still keeps a higher reliability, probably
 due to larger and sturdier components.
 Also, if a metal key is sunk in water, thrown in fire or exposed to freezing
 temperatures, there is still a good chance it will work.
 The implication on security is reflected in cheaper insurance of cars equipped
 with mechanical locks 
\begin_inset CommandInset citation
LatexCommand cite
key "bbc2014"

\end_inset

.
 And finally, there is a pragmatic argument.
 Many use cases do not need a high-tech solution, which makes the low price
 of mechanical locks a decisive advantage.
 It is likely that our homes will use mechanical locks for many years to
 come.
\end_layout

\begin_layout Standard
There is also a reason to believe in the future of mechanical locks in the
 long term.
 High-security applications might use locks, which are both electronic and
 mechanical, such as CLIQ 
\begin_inset CommandInset citation
LatexCommand cite
key "cliq"

\end_inset

.
 Both components are independent – hence for a key to open a lock, the key's
 physical shape must be correct as well as the code inside its computer.
 An attacker attempting to make an illegal copy of a key must copy both
 components, which requires two different skill sets.
 The James Bond of the future will have to be a good hacker, merely to open
 a door.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename 20160902-152051.jpg
	lyxscale 10
	width 5cm
	rotateAngle 270

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Wooden door lock dated 1889
\end_layout

\end_inset

Wooden door lock dated 1889 from the Pitt Rivers Museum, Oxford.
 Photo © Filip Železný.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Tumbler locks.
\end_layout

\begin_layout Standard
The fundamental principle of mechanical locks has remained the same for
 thousands of years.
 Inside the lock, there is a small movable part, which obstructs the lock's
 opening.
 The movable part is hard to reach by hand or by tools but can be pushed
 out of its place by inserting a correctly shaped key.
\end_layout

\begin_layout Standard
Since the industrial revolution, this idea has been realized in many ways.
 Using 
\begin_inset CommandInset citation
LatexCommand cite
key "pulford2007"

\end_inset

 we can pinpoint two important types, which are relevant to lock-chart solving.
 They serve merely as an example, other lock types might be relevant as
 well.
\end_layout

\begin_layout Standard
First, there are 
\emph on
pin tumbler locks
\emph default
, illustrated in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "pin-tumbler-fig"

\end_inset

.
 Pin tumbler locks have several cylindrical holes called 
\emph on
chambers
\emph default
 drilled through the 
\emph on
plug
\emph default
 and the 
\emph on
casing
\emph default
, in which spring-loaded 
\emph on
pins
\emph default
 can travel up and down.
 In the locked state (left) the plug cannot rotate in the casing, because
 
\emph on
driver pins
\emph default
 are stuck between the two.
 Inserting a correct key (right) moves the 
\emph on
key pins
\emph default
 as well as the driver pins against the spring.
 Since all gaps between pins align with the 
\emph on
shear-line
\emph default
, the key with the plug can be rotated.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename StandardKey.jpg
	lyxscale 20
	width 40text%

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename AbloyKey.jpg
	lyxscale 25
	width 40text%

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Keys for a pin and disc tumbler locks
\end_layout

\end_inset

Keys for a pin tumbler lock (left) and disc tumbler lock (right).
 Images are in the public domain 
\begin_inset CommandInset citation
LatexCommand cite
key "standardkey,abloykey"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "keys-fig"

\end_inset


\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename TumblerLockK2D.pdf
	width 100text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Internal components of a tumbler lock
\end_layout

\end_inset

Internal components of a tumbler lock with 4 chambers in the locked (left)
 and unlocked (right) states.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "pin-tumbler-fig"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Second, there are 
\emph on
disc tumbler locks
\emph default
.
 Their mechanism is best explained using the 
\emph on
Scandinavian padlock
\emph default
 (shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "scandinavian-fig"

\end_inset

), in Scandinavia better known as 
\emph on
Polhem padlock
\emph default
 after its inventor.
 It lacks some features of a modern disc tumbler lock (e.g.
 locking bars), but that only makes the principle easier to explain.
 The key has several 
\emph on
facets
\emph default
 aligned with the key's central axis, each rotated at a different angle
 (see Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "keys-fig"

\end_inset

 on the right).
 The padlock's 
\emph on
body
\emph default
 contains several circular 
\emph on
discs
\emph default
 with protrusions on its inner perimeter, displayed in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "cross-fig"

\end_inset

.
 A key is inserted and starts turning.
 Facets start hitting the protrusions, each at a different angle and eventually
 turn the discs.
 When notches on the discs' outer perimeters are aligned, the 
\emph on
shackle
\emph default
 is released.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename ScandinavianPadlockAd.jpg
	lyxscale 25
	width 55text%

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename PolhemPadlock.png
	lyxscale 50
	width 40text%

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Drawings of Scandinavian padlocks
\end_layout

\end_inset

Left: Advertisement for a Scandinavian padlock, year 1874.
 Right: Drawing of an unlocked Scandinavian padlock.
 Images are in the public domain 
\begin_inset CommandInset citation
LatexCommand cite
key "scandinavian,polhem"

\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "scandinavian-fig"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename PinTumblerLock.pdf

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Principle of the Scandinavian padlock
\end_layout

\end_inset

Cross section of a simplified Scandinavian padlock through one of its discs
 illustrates disc tumbler locks.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "cross-fig"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
A particular type of locks together with the number of chambers, discs,
 cutting depths, facet angles etc.
 will be called a 
\emph on
platform
\emph default
.
 Platforms come with constraints – either formal or informal rules that
 must be satisfied by all keys and locks.
\end_layout

\begin_layout Standard
Please keep in mind that the terminology differs between manufacturers and
 languages.
 A translation table can be found in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "pulford2007"

\end_inset

.
\end_layout

\begin_layout Paragraph
Lock-charts.
\end_layout

\begin_layout Standard
For large buildings such as offices or factories, their owners specify access
 rights of each person to each room.
 Typically most users can only open their office, some have access to an
 entire floor and usually, there is one key which can open every door of
 the building.
 This is known as 
\emph on
master keying
\emph default
, where each lock is opened by one associated key called an 
\emph on
individual
\emph default
 key and also by a limited number of 
\emph on
master
\emph default
 keys.
 The term is contrasted with 
\emph on
maison keying
\emph default
, where a single lock is opened by many individual keys in the system 
\begin_inset CommandInset citation
LatexCommand cite
key "pulford2007"

\end_inset

, which can be used e.g.
 for the main door of the building.
\end_layout

\begin_layout Standard
However, in general, access rights can be arbitrary – a key can open any
 number of locks and vice versa.
 Such requirements are encoded in a 
\emph on
lock-chart
\emph default
.
 Lock-charts can be visualised in many forms, the simplest of which is a
 table as in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "basic-fig"

\end_inset

.
 Its rows correspond to the locks and columns to the keys.
 When a key should open a lock, the respective cell in the table contains
 a tick.
 Lock-charts tend to have a large number of individual keys, which makes
 the table hard to visualise on a small screen.
 Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "hlava-fig"

\end_inset

 shows the same lock-chart in a format inspired by the Hlavatý calculation
 software, developed for the FAB company, now ASSA ABLOY Czech & Slovakia
 s.r.o.
 The format only displays locks and master keys.
 If a lock is opened by an individual key the “
\family typewriter
I
\family default
” symbol is printed in the row.
\end_layout

\begin_layout Standard
The production of a master keyed system involves several parties.
 The customer's requirements are encoded in a lock-chart, which is sent
 to a key manufacturer.
 They must design the cuttings of the keys and the internal components of
 the locks so that all constraints and access rights are respected, manufacture
 them and send them to the customer.
 We call the process of designing keys and locks 
\emph on
lock-chart solving
\emph default
.
 Algorithms for this task are the main contribution of this dissertation.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename MultiLevelLockChart.pdf

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Lock-chart displayed as a table
\end_layout

\end_inset

Lock-chart with 12 locks and 16 keys, displayed as a table.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "basic-fig"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "35col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Verbatim

      +---------+
\end_layout

\begin_layout Verbatim

      | g m m m |
\end_layout

\begin_layout Verbatim

      |   1 2 3 |
\end_layout

\begin_layout Verbatim

      +---------+
\end_layout

\begin_layout Verbatim

      | M M M M |
\end_layout

\begin_layout Verbatim

+---+-+---------+
\end_layout

\begin_layout Verbatim

|l1 |I| * * .
 .
 |
\end_layout

\begin_layout Verbatim

|l2 |I| * * .
 .
 |
\end_layout

\begin_layout Verbatim

|l3 |I| * * .
 .
 |
\end_layout

\begin_layout Verbatim

|l4 |I| * * .
 .
 |
\end_layout

\begin_layout Verbatim

|l5 |I| * .
 * .
 |
\end_layout

\begin_layout Verbatim

|l6 |I| * .
 * .
 |
\end_layout

\begin_layout Verbatim

|l7 |I| * .
 * .
 |
\end_layout

\begin_layout Verbatim

|l8 |I| * .
 * .
 |
\end_layout

\begin_layout Verbatim

|l9 |I| * .
 .
 * |
\end_layout

\begin_layout Verbatim

|l10|I| * .
 .
 * |
\end_layout

\begin_layout Verbatim

|l11|I| * .
 .
 * |
\end_layout

\begin_layout Verbatim

|l12|I| * .
 .
 * |
\end_layout

\begin_layout Verbatim

+---+-+---------+
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Lock-chart in a Hlavatý-like format
\end_layout

\end_inset

Lock-chart with 12 locks and 16 keys, displayed in a Hlavatý-like format.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "hlava-fig"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Master keyed locks.
\end_layout

\begin_layout Standard
How can two or more keys open a mechanical lock? Ordinary pin tumbler lock
 in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "pin-tumbler-fig"

\end_inset

 opens when gaps between all key pins and driver pins align with the shear-line.
 By introducing additional driver pins called 
\emph on
spacer pins
\emph default
 as in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "pin-mks-fig"

\end_inset

, the number of gaps increases.
 Any combination of gaps from different chambers lets one key enter the
 lock.
 Disc tumbler locks can be modified similarly.
 If the disc's outer perimeter in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "cross-fig"

\end_inset

 had more notches, the disc could be rotated at multiple angles and still
 allow the shackle to be released.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename TumblerLock.pdf

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Master-keyed pin tumbler lock
\end_layout

\end_inset

Master-keyed pin tumbler
\emph on
 
\emph default
lock.
 Because of the added spacer pins, there are 8
\begin_inset space ~
\end_inset

different shear lines, each corresponding to a key cutting that opens the
 lock.
 Two of them are shown in the picture: 
\begin_inset Formula $(1,2,1,1)$
\end_inset

 and 
\begin_inset Formula $(1,4,4,1)$
\end_inset

.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "pin-mks-fig"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Are all lock mechanisms suitable for master keying? The plethora of ideas
 accumulated over centuries of development makes this a hard question.
 A comprehensive encyclopedic answer is provided by 
\begin_inset CommandInset citation
LatexCommand cite
key "pulford2007"

\end_inset

.
 However, for the purposes of this text, we consider a platform suitable
 for master keying if:
\end_layout

\begin_layout Quote
Given an arbitrary set of keys (from one platform), it is possible to manufactur
e a lock opened (at least) by all of them.
\end_layout

\begin_layout Standard
An example of technology outside of this definition is a 
\emph on
wafer tumbler lock
\emph default
.
 Master-keyed wafer locks are opened by at most two keys 
\begin_inset CommandInset citation
LatexCommand cite
key "pulford2007"

\end_inset

.
 Furthermore, the key's teeth are shifted either to the left or right.
 Consequently, no lock can be operated by two different “left” keys or by
 two different “right” keys, which dramatically reduces the set of lock-charts
 that can be manufactured.
 Hence wafer tumbler locks are not considered in this text.
\end_layout

\begin_layout Standard
Even platforms suitable for master keying have restrictions.
 Some master keyed locks are “forbidden”, because of higher manufacturing
 costs or their susceptibility to lock picking.
 A typical example is an overly small spacer pin in a pin tumbler lock.
 However, from our experience, the effects of 
\emph on
lock
\emph default
 constraints are less significant than of those applied on 
\emph on
keys
\emph default
.
 In this text, we considered only key constraints and assumed that lock
 constraints do not exist or that their effect can be nullified by a mathematica
l transformation (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "constraints-definition-section"

\end_inset

).
\end_layout

\begin_layout Standard
On the other hand, our approach embraces many platforms and mechanical lock
 features.
 Besides pin tumbler locks and disc tumbler locks, this work is also well
 suited for 
\emph on
side pins
\emph default
, both 
\emph on
active
\emph default
 and 
\emph on
passive
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "pulford2007"

\end_inset

.
 Side pins are similar to chambers in a pin tumbler lock, except they are
 binary.
 Usually located on the side of the key, side pin appears either as a dimple
 or a flat surface.
 Despite their low contribution to lock-picking protection, for lock-chart
 solving they behave exactly like a regular chamber.
\end_layout

\begin_layout Paragraph
Innovation.
\end_layout

\begin_layout Standard
It may seem that a centuries-old technology is stable and does not evolve.
 In reality, the opposite is true.
\end_layout

\begin_layout Standard
One of the business promises made to customers is that a key cannot be duplicate
d without authorisation.
 Before issuing a duplicate key, customers must typically present a “key
 cutting ID card”, otherwise kept at a safe place.
 This scheme ensures that a temporarily lost or lent key once returned is
 still the only existing copy.
\end_layout

\begin_layout Standard
How can a manufacturer ensure that no other party starts a business by issuing
 compatible key blanks and duplicating keys without authorisation? After
 all, a key cutting ID card has no legal status.
 However, by filing a patent for a particular platform, a legal protection
 of the scheme is guaranteed.
 
\end_layout

\begin_layout Standard
After a patent expires (20 years in the United States), the manufacturer
 is forced to update the platform and file a new patent.
 Sometimes, the old and new platforms are made incompatible only by changing
 the external dimensions, but often a chamber or a disc is added 
\begin_inset CommandInset citation
LatexCommand cite
key "pulford2007"

\end_inset

, which also affects the calculation.
\end_layout

\begin_layout Paragraph
Extensions.
\end_layout

\begin_layout Standard
Our industrial partner introduced us to yet another aspect of lock-chart
 solving.
 Buildings get remodeled, new floors are added, dividing walls are moved,
 and all such changes affect lock-charts.
 For example, when a new room is built, the lock-chart receives a new lock.
 Or, when someone loses their key, a new key might be added.
 Such modification to an existing master key system is called an 
\emph on
extension
\emph default
.
\end_layout

\begin_layout Standard
Extensions pose two challenges.
 First, a lock-chart solving software must anticipate such modifications.
 When a brand new master key system is calculated, which we call 
\emph on
from-scratch solving
\emph default
, the keys and locks must be designed in a way to allow new keys and locks
 to be added in future.
 The tricky part is that the exact lock-chart with the extension is not
 known during the initial calculation.
 The second challenge called 
\emph on
extension lock-chart solving
\emph default
 is to accept a lock-chart with some of its keys and locks fixed during
 the from-scratch solution.
\end_layout

\begin_layout Standard
Our industrial partner stressed the importance of this aspect because, businessw
ise, the majority of their orders were extensions of already existing master-key
 systems.
\end_layout

\begin_layout Standard
This text focuses on lock-chart solving algorithms that are general, parametriza
ble, support a significant range of platforms, and are suitable for both
 the from-scratch and extension tasks.
\end_layout

\begin_layout Section
Related literature
\end_layout

\begin_layout Standard
Despite a clean mathematical formulation of lock-chart solving and the constrain
ts, the problem has not received adequate attention of computer scientists
 or the industry.
 From our experience of working together with a major player in the industry,
 many key manufacturers still solve lock-charts manually, merely with computer-a
ssisted validation of design decisions made by a human operator.
 Most software we know only solve special cases of lock-charts or require
 their lengthy manual preprocessing.
 The underappreciation of lock-chart solving is reflected by a limited number
 of algorithmic studies.
\end_layout

\begin_layout Standard
The first study on lock-chart solving known to us is 
\begin_inset CommandInset citation
LatexCommand citep
key "junker1999"

\end_inset

.
 Junker used a constraint satisfaction problem (CSP) solver for solving
 lock-charts.
 In particular, his main contribution is a procedure, which decomposes a
 CSP representing a lock-chart into a tree hierarchy of subproblems of smaller
 size.
 Since the primal graph of the hierarchy is almost a tree, it can be solved
 in polynomial time in the size of the tree and in exponential time in the
 size of the subproblems 
\begin_inset CommandInset citation
LatexCommand citep
before "see"
key "gottlob2008"

\end_inset

.
 The algorithm used the ILOG library and was verified on a set of problems,
 whose exact structure has not been disclosed.
\end_layout

\begin_layout Standard
Lawer's contribution to lock-chart solving in her thesis 
\begin_inset CommandInset citation
LatexCommand citep
key "lawer2004"

\end_inset

 is manyfold.
 The main theoretical contribution is a proof of 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-completeness.
 In particular, the SAT problem was translated into an extension lock-chart.
 In the practical part, she focused on inter-customer security.
 Key manufacturers try to prevent keys belonging to one customer from opening
 locks belonging to another customer (if all produced in the same mechanical
 platform).
 Lawer proposed and tested several algorithms that minimise the number of
 keys unusable for future calculations.
 Also, the work contains a list of lock-charts used for benchmarking.
\end_layout

\begin_layout Standard
The newest contribution 
\begin_inset CommandInset citation
LatexCommand cite
key "vomel2017"

\end_inset

 to the field contains an explanation of 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-completeness and reports good experience with a simulated annealing algorithm.
 The work is accessible and might serve as a good introduction.
 Since the algorithm's description and important claims somewhat lack formal
 precision, this text is more inspired by the former two works.
 Readers interested in this resource should be aware that the formalisation
 of a 
\emph on
key
\emph default
 and a 
\emph on
lock
\emph default
 seem swapped when compared to this text and all other work on lock-chart
 solving cited here.
\end_layout

\begin_layout Standard
Besides the computer science community, lock-chart solving is discussed
 in training manuals for professionals who solve lock-charts by hand 
\begin_inset CommandInset citation
LatexCommand cite
key "oshall2015"

\end_inset

.
 For example, the description of the 
\emph on
rotating constant method
\emph default
 can be viewed as an executable algorithm.
 However, we were unable to find any optimality proofs or an analysis of
 the method's limitations.
 We decided to include the work here and fit it into our theoretical concepts.
\end_layout

\begin_layout Paragraph
Extensions.
\end_layout

\begin_layout Standard
To the best of our knowledge, the extension aspect of lock-chart solving
 has not been studied before.
 Hence we also reviewed the literature about general combinatorial problems
 which are solved without the knowledge of future constraints.
\end_layout

\begin_layout Standard
The seminal work on 
\emph on
dynamic CSPs
\emph default
 in 
\begin_inset CommandInset citation
LatexCommand citep
key "dechter1988"

\end_inset

 attempts to reuse a solution to one CSP in a slightly modified CSP.
 
\begin_inset CommandInset citation
LatexCommand citep
key "hebrard2004"

\end_inset

 proposed
\emph on
 super solutions
\emph default
 as a method of preparing a solution for small modifications of the constraints
 and minimise the number of necessary changes.
 Other approaches allow using 
\emph on
soft constraints
\emph default
 in the form of 
\emph on
MAX-CSP
\emph default
 
\begin_inset CommandInset citation
LatexCommand citep
key "freuder1992"

\end_inset

 or 
\emph on
weighted CSP
\emph default
 
\begin_inset CommandInset citation
LatexCommand citep
key "cooper2010"

\end_inset

.
 It looks promising to formulate extensibility as an optimisation criterion
 using a clever reformulation.
 Our initial attempt was to use existing CSP solvers, but even without the
 extensibility criterion, an off-the-shelf, state-of-the-art CSP solver
 Choco 
\begin_inset CommandInset citation
LatexCommand citep
key "choco"

\end_inset

 proved orders of magnitude slower than the pruning procedure with the heuristic
s we present here.
\end_layout

\begin_layout Section
Goals and disclaimer
\end_layout

\begin_layout Standard
This text was written with several goals in mind:
\end_layout

\begin_layout Itemize
Capture our experience from 4-year long industrial collaboration with ASSA
 ABLOY Czech & Slovakia, ASSA ABLOY Belgium and the ASSA ABLOY EMEA.
\end_layout

\begin_layout Itemize
Formalise all known variations of the lock-chart solving problem and establish
 relationships to existing literature.
 Find a reasonable compromise between the theory's strength and its assumptions.
\end_layout

\begin_layout Itemize
Extend the 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-completeness proof from 
\begin_inset CommandInset citation
LatexCommand citep
key "lawer2004"

\end_inset

 to non-extension variants of lock-chart solving.
 Find classes of polynomial instances.
\end_layout

\begin_layout Itemize
Find efficient algorithms for lock-chart solving.
 Evaluate them on a dataset of lock-chart with a focus on real-world problems.
 Describe means of increasing extensibility.
\end_layout

\begin_layout Itemize
Provide an introduction to lock-chart solving for computer scientists without
 a background in mechanical engineering.
\end_layout

\begin_layout Standard
We stress out topics which are not part of this text:
\end_layout

\begin_layout Itemize
Non-disclosure agreements with our partners were honoured.
 We tried to generalise our knowledge and provide theoretical insight without
 details about the particular technology, constraints or security measures.
\end_layout

\begin_layout Itemize
Despite the fact that some constraints affect lock-chart solving and they
 also affect resistance to lock-picking, we do not establish any relationship
 between the two here.
 Here, we assume that experts design all security measures and formulate
 their implications as constraints for lock-chart solving.
\end_layout

\begin_layout Itemize
Conversely, this text is not meant to help lock-pickers.
 If any property of an algorithm or an insight presented here leads to a
 new lock-picking technique (which we doubt), it should be disclosed publicly
 following the industry's best practices 
\begin_inset CommandInset citation
LatexCommand cite
key "pulford2007"

\end_inset

.
\end_layout

\begin_layout Itemize
Data structures for algorithms' efficient implementation are out of scope
 together with an analysis of asymptotic time complexity.
 First, most of the problems considered here are 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete and entail an exponential runtime (based on the current knowledge)
 that hides effects of most efficient data structures.
 Second, computational aspects of lock-chart solving are too little explored.
 We felt that a broad exploration of different algorithms should precede
 fine-tuning of their implementation.
\end_layout

\begin_layout Section
Acknowledgements
\end_layout

\begin_layout Standard
I would like to thank ASSA ABLOY for a long-term collaboration and for funding
 research, which has lead to publishing this text.
\end_layout

\begin_layout Standard
Several ideas in this text are products of teamwork, usually springing out
 of a lively discussion with colleagues.
 Chronologically, the CSP algorithm in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "csp-sec"

\end_inset

 was suggested and first implemented by Ondřej Kuželka.
 The idea of using SAT solvers described in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sat-sec"

\end_inset

 and the first prototype shall be credited to Jiří Vyskočil.
 Several optimisations by Josef Hájíček and Martin Hořeňovský affected the
 code used here.
 The dynamic programming scheme in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "count-gen-sec"

\end_inset

 came out of the collaboration with Václav Voráček.
\end_layout

\begin_layout Standard
I am also grateful to my supervisor, who was always there if the project
 needed a new direction to continue.
\end_layout

\begin_layout Standard
My biggest thanks belong to my partner and my son, who made the greatest
 sacrifice.
 Without their support and time, this text would never have been created.
\end_layout

\begin_layout Chapter
Lock-chart formalisation
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "chapter-formalization"

\end_inset


\end_layout

\begin_layout Standard
The previous text provided an introduction to mechanical keys and lock-charts.
 This chapter will formalise these notions and give a mathematical model.
 The formalisation will be used as the input and output of a lock-chart
 solving algorithm.
\end_layout

\begin_layout Section
Preliminaries
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "formalization-preliminaries-section"

\end_inset


\end_layout

\begin_layout Standard
This section is a quick review of mathematical notions used in the remaining
 text.
 Since all notions are within a common computer science curriculum, we tried
 to keep the definitions short and provided references for further investigation.
 Readers are encouraged to use this section merely as a “knowledge check-list”.
\end_layout

\begin_layout Standard
Although some notions are complex enough to write a book, we have tried
 to find a reasonable compromise.
 For the reason of low relevancy rather then author's ignorance, we will
 not discuss the paradoxes of set theory, nor avoid them by axiomatization.
 Here, we define sets in a narrower sense.
\end_layout

\begin_layout Paragraph
Sets.
\end_layout

\begin_layout Standard
Let there be finitely many symbols 
\begin_inset Formula $d_{1},\ldots,d_{n}$
\end_inset

.
 The collection 
\begin_inset Formula $\{d_{1},\ldots,d_{n}\}$
\end_inset

 is a 
\emph on
set
\emph default
.
 Deleting arbitrary items from a set 
\begin_inset Formula $A$
\end_inset

 yields a 
\emph on
set
\emph default
 
\begin_inset Formula $B$
\end_inset

, (written 
\begin_inset Formula $A\subseteq B$
\end_inset

) called a 
\emph on
subset
\emph default
.
 Sets are written with capital letters 
\begin_inset Formula $A,B,C,\ldots,$
\end_inset

 its items are referred as 
\emph on
members
\emph default
 of the set (
\begin_inset Formula $a\in A$
\end_inset

) and the number of items in a set is its 
\emph on
cardinality
\emph default
, written as 
\begin_inset Formula $|A|$
\end_inset

.
 An 
\emph on
empty set
\emph default
 
\begin_inset Formula $\emptyset$
\end_inset

 is a set, whose cardinality is 
\begin_inset Formula $0$
\end_inset

.
 If 
\begin_inset Formula $B$
\end_inset

 is a subset of 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $|A|>|B|,$
\end_inset

 then 
\begin_inset Formula $B$
\end_inset

 is a 
\emph on
proper subset
\emph default
 of 
\begin_inset Formula $A$
\end_inset

, written 
\begin_inset Formula $B\subset A$
\end_inset

.
 Given two sets 
\begin_inset Formula $A,B$
\end_inset

, their intersection, union and difference are 
\begin_inset Formula $A\cap B$
\end_inset

, 
\begin_inset Formula $A\cup B$
\end_inset

 and 
\begin_inset Formula $A\setminus B$
\end_inset

 respectively.
 
\end_layout

\begin_layout Standard
Given 
\begin_inset Formula $n$
\end_inset

 sets 
\begin_inset Formula $T_{1},\ldots,T_{n}$
\end_inset

, a collection of 
\begin_inset Formula $n$
\end_inset

 ordered items 
\begin_inset Formula $t_{1}\in T_{1},\ldots,t_{n}\in T_{n}$
\end_inset

 is called a 
\emph on
tuple 
\emph default

\begin_inset Formula $t=(t_{1},\ldots,t_{n})$
\end_inset

 of 
\emph on
arity
\emph default
 
\begin_inset Formula $n$
\end_inset

.
 If 
\begin_inset Formula $n=2$
\end_inset

, the tuple is a 
\emph on
pair
\emph default
.
 The 
\emph on
cartesian product
\emph default
 
\begin_inset Formula $T_{1}\times\cdots\times T_{n}$
\end_inset

 is a set of all tuples on 
\begin_inset Formula $T_{1},\ldots,T_{n}$
\end_inset

.
 A subset of a cartesian product is called a 
\emph on
relation
\emph default
.
 If 
\begin_inset Formula $n=1$
\end_inset

, the relation is 
\emph on
unary
\emph default
 and if 
\begin_inset Formula $n=2$
\end_inset

, the relation is 
\emph on
binary
\emph default
.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $R$
\end_inset

 be a relation on 
\begin_inset Formula $D\times D$
\end_inset

.
 For all 
\begin_inset Formula $d,d',d''\in D$
\end_inset

: If no 
\begin_inset Formula $(d,d)\in R$
\end_inset

, then 
\begin_inset Formula $R$
\end_inset

 is 
\emph on
irreflexive
\emph default
.
 If 
\begin_inset Formula $(d,d)\in R$
\end_inset

, then 
\begin_inset Formula $R$
\end_inset

 is 
\emph on
reflexive
\emph default
.
 If 
\begin_inset Formula $(d,d')\in R$
\end_inset

 and 
\begin_inset Formula $(d',d)\in R$
\end_inset

 implies 
\begin_inset Formula $d=d'$
\end_inset

, then 
\begin_inset Formula $R$
\end_inset

 is 
\emph on
antisymmetric
\emph default
.
 If 
\begin_inset Formula $(d,d')\in R$
\end_inset

 and 
\begin_inset Formula $(d',d'')\in R$
\end_inset

 implies 
\begin_inset Formula $(d,d'')\in R$
\end_inset

, the relation is 
\emph on
transitive
\emph default
.
 A reflexive, antisymmetric and transitive relation is a 
\emph on
partial order
\emph default
.
 The 
\emph on
inverse 
\emph default
relation 
\begin_inset Formula $R^{-1}$
\end_inset

 is defined as 
\begin_inset Formula $(d,d')\in R$
\end_inset

 iff 
\begin_inset Formula $(d',d)\in R^{-1}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Functions.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $D$
\end_inset

 and 
\begin_inset Formula $R$
\end_inset

 be sets (called 
\emph on
function's domain
\emph default
 and the 
\emph on
function's range
\emph default
).
 A 
\emph on
partial function
\emph default
 
\begin_inset Formula $f\,:D\rightharpoonup R$
\end_inset

 is a binary relation on 
\begin_inset Formula $D\times R$
\end_inset

, which has the 
\emph on
right-unique
\emph default
 property — if 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $(d,r_{1})\in f$
\end_inset

 and 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $(d,r_{2})\in f$
\end_inset

 then 
\begin_inset Formula $r_{1}=r_{2}$
\end_inset

.
 Furthermore, a partial function is a 
\emph on
function 
\emph default

\begin_inset Formula $f\,:D\rightarrow R$
\end_inset

 if it is 
\emph on
left-total
\emph default
 — if 
\begin_inset Formula $d\in D$
\end_inset

 then there must be 
\begin_inset Formula $r\in R$
\end_inset

 s.t.
 
\begin_inset Formula $(d,r)\in f$
\end_inset

.
 A function is 
\emph on
surjective
\emph default
 if has the 
\emph on
right-total
\emph default
 property — if 
\begin_inset Formula $r\in R$
\end_inset

 then there must be 
\begin_inset Formula $d\in D$
\end_inset

 s.t.
 
\begin_inset Formula $(d,r)\in f$
\end_inset

.
 A function is 
\emph on
injective
\emph default
 if it has the 
\emph on
left-unique
\emph default
 property — if 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $(d_{1},r)\in f$
\end_inset

 and 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $(d_{2},r)\in f$
\end_inset

 then 
\begin_inset Formula $d_{1}=d_{2}$
\end_inset

.
 A function, which is both surjective and injective, is a 
\emph on
bijection
\emph default
.
 Throughout the text, the standard notation 
\begin_inset Formula $f(d)=r$
\end_inset

 is used instead of 
\begin_inset Formula $(d,r)\in f$
\end_inset

 and also a less-standard notation 
\begin_inset Formula $f\cup(d,h)$
\end_inset

 to define an extension of a partial function 
\begin_inset Formula $f$
\end_inset

 (partial functions are sets of pairs).
\end_layout

\begin_layout Paragraph
Graphs.
\end_layout

\begin_layout Standard

\emph on
Graph
\emph default
 is a pair 
\begin_inset Formula $(V,E)$
\end_inset

 of 
\emph on
vertices
\emph default
 and 
\emph on
edges
\emph default
, where 
\begin_inset Formula $E$
\end_inset

 is a binary relation on 
\begin_inset Formula $V$
\end_inset

.
 We say that vertex 
\begin_inset Formula $v'$
\end_inset

 is 
\emph on
adjacent
\emph default
 to 
\begin_inset Formula $v$
\end_inset

 if there is an edge from one vertex to the other 
\begin_inset Formula $(v,v')\in E$
\end_inset

.
 The graph is 
\emph on
simple
\emph default
 if 
\emph on

\begin_inset Formula $E$
\end_inset


\emph default
 is irreflexive.
 Vertices adjacent to 
\begin_inset Formula $v$
\end_inset

 are denoted 
\begin_inset Formula $E(v)$
\end_inset

.
 The 
\emph on
degree
\emph default
 of vertex 
\begin_inset Formula $v$
\end_inset

 is 
\begin_inset Formula $|E(v)|$
\end_inset

.
 A graph is 
\emph on
undirected
\emph default
 if 
\begin_inset Formula $E$
\end_inset

 is a symmetric relation: if 
\begin_inset Formula $(v,v')\in V$
\end_inset

, then 
\begin_inset Formula $(v',v)\in V$
\end_inset

.
 A graph is bipartite with 
\emph on
partite sets
\emph default
 
\begin_inset Formula $U$
\end_inset

 and 
\begin_inset Formula $U'$
\end_inset

 if 
\begin_inset Formula $U\cap U'=\emptyset$
\end_inset

, 
\begin_inset Formula $U\cup U'=V$
\end_inset

 and 
\begin_inset Formula $E\subseteq(U\times U')\cup(U'\times U)$
\end_inset

, which will be written as 
\begin_inset Formula $(U\cup U',E)$
\end_inset

.
\end_layout

\begin_layout Paragraph
Integers.
\end_layout

\begin_layout Standard
The set of integers is 
\begin_inset Formula $\mathbb{Z}=\{\ldots,-2,-1,0,1,2,\ldots\}$
\end_inset

, the set of whole numbers is 
\begin_inset Formula $\mathbb{W}=\left\{ 0,1,2,3,\ldots\right\} $
\end_inset

 and the set of natural numbers 
\begin_inset Formula $\mathbb{N}=\left\{ 1,2,3,\ldots\right\} $
\end_inset

.
 Addition, subtraction, multiplication, quotient and remainder of natural
 numbers 
\begin_inset Formula $x,y$
\end_inset

 will be denoted 
\begin_inset Formula $x+y$
\end_inset

, 
\begin_inset Formula $x-y$
\end_inset

, 
\begin_inset Formula $x\cdot y$
\end_inset

, 
\begin_inset Formula $x\div y$
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 and 
\begin_inset Formula $x\mathop\%y$
\end_inset

.
 By 
\begin_inset Formula $\frac{x}{y}$
\end_inset

 we mean a division of two rational numbers.
\end_layout

\begin_layout Section
Constraints
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "constraints-definition-section"

\end_inset


\end_layout

\begin_layout Standard
The combinatorial problem of lock-chart solving consists of 2
\begin_inset space ~
\end_inset

parts.
 First, there is the lock-chart, which is specified by the customer.
 Second, there are some constraints, which capture the engineering limitations
 specified by the manufacturer.
 We start by describing the constraints in this section.
\end_layout

\begin_layout Standard
During the industrial collaboration, we met 12 mechanical platforms with
 roughly 20 types of constraints of various types.
 Together they make up a big „zoo“, which is hard to analyse as a whole.
 There are roughly two taxonomies of such constraints.
\end_layout

\begin_layout Paragraph
Security and manufacturing.
\end_layout

\begin_layout Standard
There is an intuitive distinction between 
\emph on
security
\emph default
 and 
\emph on
manufacturing
\emph default
 constraints.
 An example of a manufacturing constraint is the “maximum difference between
 neighbouring positions on a key”, which we call the 
\emph on
jump
\emph default
.
 Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "borkey-figure"

\end_inset

 shows a detail of a milling machine.
 Its milling wheel is V-shaped, where the deepest cutting point cuts the
 desired position into a flat key blank.
 However, the shallower parts of the milling wheel might still cut too deeply
 in neighbouring positions.
 As a countermeasure, the jump constraint ensures that neighbouring positions
 still have enough metal to be milled properly.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename BorkeyKeycutterMilling3.jpg
	lyxscale 10
	width 49text%

\end_inset

 
\begin_inset Graphics
	filename BorkeyKeycutterMilling2.jpg
	lyxscale 8
	width 49text%

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Börkey 954-2 Key Cutting Machine
\end_layout

\end_inset

Börkey 954-2 Key Cutting Machine with a close-up of the milling wheel.
 © Dennis van Zuijlekom, 
\begin_inset CommandInset href
LatexCommand href
name "CC BY-SA 2.0"
target "https://creativecommons.org/licenses/by-sa/2.0/"

\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "borkey2013"

\end_inset

.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "borkey-figure"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
An example of a security constraint is the 
\emph on
delta
\emph default
 constraint, which prescribes the “minimum difference of key's cutting depth
 from the lock's shear-line
\begin_inset Quotes erd
\end_inset

 if the key should be blocked in the lock.
\begin_inset Foot
status open

\begin_layout Plain Layout
If the key should open the lock, then delta must be 
\begin_inset Formula $0$
\end_inset

.
\end_layout

\end_inset

 Increasing the delta lowers the chances of an accidental opening, which
 makes it a security constraint.
\end_layout

\begin_layout Standard
Increasing the delta constraint also affects manufacturing.
 Assuming 
\begin_inset Formula $\text{delta}=3\,\mathrm{mm}$
\end_inset

, it makes no sense to manufacture pins of size 
\begin_inset Formula $2\,\mathrm{mm}$
\end_inset

 or smaller, because they would be unable to block a key.
 Hence, the delta is often accompanied with the 
\emph on
forbidden pins
\emph default
 constraint, which “forbids prescribed pin heights from a lock”.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
A strong heuristic is to forbid pins, whose size is “not modulo delta” —
 in this case, pins of size 
\begin_inset Formula $1\,\mathrm{mm}$
\end_inset

, 
\begin_inset Formula $2\,\mathrm{mm}$
\end_inset

, 
\begin_inset Formula $4\,\mathrm{mm}$
\end_inset

, 
\begin_inset Formula $5\,\mathrm{mm}$
\end_inset

, 
\begin_inset Formula $7\,\mathrm{mm},\ldots$
\end_inset

 An even simpler heuristic is to ignore certain cuttings depths completely
 and reduce the entire code space.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Consequently, increasing delta also affects manufacturing by increasing
 components' sizes and reducing the need for tight tolerances.
 The distinction between security and manufacturing constraints is used
 in the industry, but form the computational point of view, it is not very
 crisp.
\end_layout

\begin_layout Paragraph
Computational constraints.
\end_layout

\begin_layout Standard
Another distinction can be made from the formal point of view.
 Constraints can
\end_layout

\begin_layout Enumerate
affect a single key; e.g.
 the 
\emph on
jump
\end_layout

\begin_layout Enumerate
affect a single lock; e.g.
 
\emph on
forbidden pins
\end_layout

\begin_layout Enumerate
affect the blocking between a key and a lock; e.g.
 the 
\emph on
delta
\end_layout

\begin_layout Enumerate
affect a pair of keys
\end_layout

\begin_layout Standard
In this text, we decided to focus on the first type only.
 First, the example above shows that types 2 and 3 can be closely related
 or they can even be eliminated by reducing the code space.
 Moreover, out of the 20 types of constraints we know, the majority (15)
 is of the first type.
\end_layout

\begin_layout Standard
Finally, we know of only one constraint of the fourth type, namely “minimum
 difference of two key cuttings”.
 Because it is almost always set to value 1, later in this section will
 show how to satisfy it as a by-product of Corollary
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "distinct-cor"

\end_inset

.
\end_layout

\begin_layout Paragraph
Two types of platforms.
\end_layout

\begin_layout Standard
Different mechanical platforms call for different formalisms.
 On one side, there are old and low-cost platforms.
 Locks in these platforms have a small number of chambers, typically 
\begin_inset Formula $5$
\end_inset

 or 
\begin_inset Formula $6$
\end_inset

, and their components are manufactured with high tolerances.
 As an effect, lock's reliability must be increased by prescribing a large
 number of constraints.
 Even though these platforms can have up to 
\begin_inset Formula $10$
\end_inset

 cutting depths, a high value of the delta constraint decreases this number
 to 
\begin_inset Formula $3,4$
\end_inset

 or 
\begin_inset Formula $5$
\end_inset

.
 In the end, these platforms can be characterized by 
\begin_inset Formula $\sim10^{6}$
\end_inset

 or less keys that satisfy all constraints.
\end_layout

\begin_layout Standard
On the other side, locks in modern platforms typically have a large number
 of chambers.
 This value is usually larger than 
\begin_inset Formula $10$
\end_inset

, the largest platform known to us has 
\begin_inset Formula $30$
\end_inset

 chambers.
 Cheaper platforms may have a low number of cutting depths, say 
\begin_inset Formula $2$
\end_inset

, 
\begin_inset Formula $3$
\end_inset

 or 
\begin_inset Formula $4$
\end_inset

, but some have 
\begin_inset Formula $7$
\end_inset

.
 Tight tolerances allow 
\begin_inset Formula $\text{delta}=1$
\end_inset

.
 In the end, these platforms have 
\begin_inset Formula $\sim10^{7}$
\end_inset

 or more valid key cuttings.
\end_layout

\begin_layout Standard
The effect on computation can be dramatic.
 In older platforms, current computers can easily generate all key cuttings
 and keep them in memory.
 Even with 
\begin_inset Formula $2$
\end_inset

 bytes per chamber, this requires roughly 
\begin_inset Formula $12\cdot10^{5}\,\mathrm{B}\cong1\,\mathrm{MiB}$
\end_inset

 for all valid key codes.
 In newer platforms, it may not even be feasible to iterate through all
 valid key cuttings.
\end_layout

\begin_layout Paragraph
Cuttings and cylinders.
\end_layout

\begin_layout Standard
This section will describe different ways of formalising constraints for
 calculating lock-charts, called a 
\emph on
framework
\emph default
.
 Each framework will be associated with 2 numbers – the 
\emph on
number of positions
\emph default
 
\begin_inset Formula $p$
\end_inset

, which counts the number of chambers, side pins, etc.
 and the number of 
\emph on
cutting depths
\emph default
 
\begin_inset Formula $d$
\end_inset

, which counts available values that each position can take.
\end_layout

\begin_layout Definition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Cutting, cylinder
\end_layout

\end_inset

Let 
\begin_inset Formula $p,d\in\mathbb{N}$
\end_inset

.
 A 
\emph on
cutting depth
\emph default
 is a number 
\begin_inset Formula $d_{i}\in\mathbb{N}$
\end_inset

 s.t.
 
\begin_inset Formula $d_{i}\leq d$
\end_inset

.
 A key 
\emph on
cutting
\emph default
 is a 
\begin_inset Formula $p$
\end_inset

-tuple 
\begin_inset Formula $(d_{1},\ldots,d_{p})$
\end_inset

 of cutting depths.
 A 
\emph on
cylinder
\emph default
 is a 
\begin_inset Formula $p$
\end_inset

-tuple 
\begin_inset Formula $(D_{1},\ldots,D_{p})$
\end_inset

, where each 
\begin_inset Formula $D_{i}$
\end_inset

 is a set of cutting depths.
\end_layout

\begin_layout Standard
From now on, we will distinguish between a key and a cutting and similarly
 between a lock and a cylinder.
 Cuttings and cylinders will represent physical metal objects.
 Keys and locks represent rows and columns in the lock-chart.
\end_layout

\begin_layout Standard
The definition of cuttings and cylinders requires 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

.
 Since every framework comes with the two numbers, we will omit them whenever
 they become obvious from the context.
\end_layout

\begin_layout Standard
A cutting will be denoted by 
\begin_inset Formula $\gamma$
\end_inset

 and a cylinder by 
\begin_inset Formula $\lambda$
\end_inset

.
 The 
\begin_inset Formula $i$
\end_inset

-th cutting depth (resp.
 
\begin_inset Formula $i$
\end_inset

-th set of cutting depths) will be 
\begin_inset Formula $\gamma_{i}$
\end_inset

 (resp.
 
\begin_inset Formula $\lambda_{i}$
\end_inset

).
 By a 
\emph on
union
\emph default
 of cylinders or cuttings, we mean a cylinder, whose cutting depths are
 a union of cutting depths in the respective positions.
 Example:
\begin_inset Formula 
\[
(1,3,2)\cup(\{1,2\},\{1\},\{2\})=(\{1,2\},\{1,3\},\{2\})
\]

\end_inset


\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "shear-line-definition"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Shear-line
\end_layout

\end_inset

Let 
\begin_inset Formula $\lambda$
\end_inset

 be a cylinder.
 A cutting 
\begin_inset Formula $\gamma$
\end_inset

 which satisfies 
\begin_inset Formula $\gamma_{i}\in\lambda_{i}$
\end_inset

 for all 
\begin_inset Formula $1\leq i\leq p$
\end_inset

 is a 
\emph on
shear-line
\emph default
 of 
\begin_inset Formula $\gamma$
\end_inset

.
\end_layout

\begin_layout Standard
If 
\begin_inset Formula $\gamma$
\end_inset

 is a shear-line of 
\begin_inset Formula $\lambda$
\end_inset

 we will say that “
\begin_inset Formula $\gamma$
\end_inset

 
\emph on
enters
\emph default
 
\begin_inset Formula $\lambda$
\end_inset

”.
 Otherwise “
\begin_inset Formula $\lambda$
\end_inset

 
\emph on
blocks
\emph default
 
\begin_inset Formula $\gamma$
\end_inset

”.
\end_layout

\begin_layout Standard
Given 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

, there are at most 
\begin_inset Formula $d^{p}$
\end_inset

 cutting depths.
 However, in general, not all of them satisfy the constraints.
 For that reason, each framework will be associated with a set of cuttings
 
\begin_inset Formula $S$
\end_inset

 called a 
\emph on
code space
\emph default
.
 If 
\begin_inset Formula $\gamma\in S$
\end_inset

, we will say that “
\begin_inset Formula $\gamma$
\end_inset

 is a 
\emph on
valid 
\emph default
cutting”.
\end_layout

\begin_layout Standard
We will also speak about the set of all cylinders 
\begin_inset Formula $T$
\end_inset

.
 Since constraints on cylinders are not in the scope of this text, any union
 of cuttings yields a valid cylinder
\begin_inset Formula 
\begin{equation}
T=\left\{ \bigcup_{\gamma\in S'}\gamma\mid\text{for every }S'\subseteq S\right\} ,\label{cyl-space-eq}
\end{equation}

\end_inset

so that there are at most 
\begin_inset Formula $2^{d\cdot p}$
\end_inset

 different cylinders.
\end_layout

\begin_layout Paragraph
Four frameworks.
\end_layout

\begin_layout Standard
The simplest constraint framework, which is mostly of theoretical interest,
 is defined first and then we proceed to more complex ones, aiming at describing
 real-world platforms.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "vanilla-def"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Vanilla framework
\end_layout

\end_inset

Let 
\begin_inset Formula $p,d\in\mathbb{N}$
\end_inset

.
 In the 
\emph on
vanilla
\emph default
 framework, all 
\begin_inset Formula $d^{p}$
\end_inset

 cuttings are valid.
\end_layout

\begin_layout Standard
The vanilla framework has two major advantages.
 First, the code space is perfectly symmetric.
 Swapping two positions has no effect on the code space as well as swapping
 arbitrary cutting depths.
 Second, the code space is defined using two parameters only.
 This makes it suitable for benchmarking and easy-to-read plots.
\end_layout

\begin_layout Standard
How well do real-world platforms fit in the vanilla framework? During our
 industrial collaboration, we met only one platform, which has approx.
 
\begin_inset Formula $97\%$
\end_inset

 of 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $d^{p}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 valid key cuttings,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Other platforms had less than that, roughly between 
\begin_inset Formula $1\%$
\end_inset

 and 
\begin_inset Formula $50\%$
\end_inset

.
\end_layout

\end_inset

 hence the answer would be “almost”.
 The encyclopedia of lock-chart platforms 
\begin_inset CommandInset citation
LatexCommand cite
key "pulford2007"

\end_inset

 mentions platforms (such as Mul-T-Lock) without constraints, merely with
 a varying number of cutting depths between positions.
 A step towards real-world platforms is to allow different positions to
 have a different number of cutting depths.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "asym-def"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Asymmetric framework
\end_layout

\end_inset

Let 
\begin_inset Formula $p,d\in\mathbb{N}$
\end_inset

.
 The 
\emph on
deepest cutting
\emph default
 is a cutting denoted 
\begin_inset Formula $(\tilde{d}_{1},\ldots,\tilde{d}_{p})$
\end_inset

.
 A cutting 
\begin_inset Formula $(d_{1},\ldots,d_{p})$
\end_inset

 is valid in the 
\emph on
asymmetric framework
\emph default
 if all its cutting depths are below the deepest cut: 
\begin_inset Formula $d_{i}\leq\tilde{d_{i}}$
\end_inset

 for all 
\begin_inset Formula $1\leq i\leq p$
\end_inset

.
\end_layout

\begin_layout Standard
The asymmetric framework needs 
\begin_inset Formula $p+1$
\end_inset

 parameters to define the deepest cutting.
 When compared to the vanilla framework, the symmetry is somewhat reduced.
 Swapping two cutting depths on the same position is fine, swapping two
 positions 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

 can be done as long as 
\begin_inset Formula $\tilde{d}_{i}=\tilde{d}_{j}$
\end_inset

.
\end_layout

\begin_layout Standard
In order to completely specify most real-world platforms, yet avoid the
 complexity of its constraints, the general framework is proposed.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "gecon-def"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
General framework
\end_layout

\end_inset

Let 
\begin_inset Formula $p,d\in\mathbb{N}$
\end_inset

.
 A 
\emph on
general constraint
\emph default
 (gecon) is a 
\begin_inset Formula $p$
\end_inset

-tuple 
\begin_inset Formula $(c_{1},\ldots,c_{p})$
\end_inset

, where either 
\begin_inset Formula $c_{i}$
\end_inset

 is a cutting depth or 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $c_{i}={}?$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 called a 
\emph on
wildcard
\emph default
.
 A key cutting 
\begin_inset Formula $(d_{1},\ldots,d_{p})$
\end_inset

 satisfies the gecon if there is a position 
\begin_inset Formula $i$
\end_inset

, which is not a wildcard 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $c_{i}\not={}?$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 and where 
\begin_inset Formula $c_{i}\not=d_{i}$
\end_inset

.
 A key cutting is valid in the 
\emph on
general framework
\emph default
 if it satisfies all gecons.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "gecon-ex"

\end_inset

Let 
\begin_inset Formula $p=3$
\end_inset

, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $d=5$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 and assume there is a gecon 
\begin_inset Formula $(1,4,?)$
\end_inset

.
 Is the cutting 
\begin_inset Formula $(1,5,5)$
\end_inset

 valid? Yes, because on the second position 
\begin_inset Formula $i=2$
\end_inset

, the cutting depth 
\begin_inset Formula $d_{2}=5$
\end_inset

 does not match the depth in the gecon 
\begin_inset Formula $c_{2}=4$
\end_inset

.
 The conditions 
\begin_inset Formula $c_{i}\not=d_{i}$
\end_inset

 and 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $c_{i}\not={}?$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 are satisfied.
 Also all invalid cuttings are 
\begin_inset Formula $(1,4,1)$
\end_inset

, 
\begin_inset Formula $(1,4,2)$
\end_inset

, 
\begin_inset Formula $(1,4,3)$
\end_inset

, 
\begin_inset Formula $(1,4,4)$
\end_inset

 and 
\begin_inset Formula $(1,4,5)$
\end_inset

.
\end_layout

\begin_layout Standard
The intuitive meaning of the gecon from the example is: “First and second
 positions cannot have depths 
\begin_inset Formula $1$
\end_inset

 and 
\begin_inset Formula $4$
\end_inset

 respectively.” The wildcard symbol 
\begin_inset Formula $?$
\end_inset

 means “any value”.
 Hence a gecon without wildcards makes exactly 
\begin_inset Formula $1$
\end_inset

 cutting invalid.
 A gecon with wildcards on all positions invalidates all cuttings, which
 is why it is rarely used.
\end_layout

\begin_layout Standard
Why do gecons have the word “general” in their name? Most constraints that
 we met can be translated into gecons.
\end_layout

\begin_layout Example
Let 
\begin_inset Formula $p=3$
\end_inset

, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $d=5$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 and take the 
\begin_inset Formula $\text{jump}=2$
\end_inset

 constraint, which can be rephrased as “difference of neighbouring positions
 larger or equal than 3 is forbidden”.
 This constraint can be expressed using 6 gecons 
\begin_inset Formula $(1,4,?)$
\end_inset

, 
\begin_inset Formula $(1,5,?)$
\end_inset

, 
\begin_inset Formula $(2,5,?)$
\end_inset

, 
\begin_inset Formula $(?,1,4)$
\end_inset

, 
\begin_inset Formula $(?,1,5)$
\end_inset

 and 
\begin_inset Formula $(?,2,5)$
\end_inset

.
\end_layout

\begin_layout Standard
In general, the jump constraint is equivalent to 
\begin_inset Formula 
\[
\frac{1}{2}\cdot\text{jump}\cdot(\text{jump}+1)\cdot(p-1)
\]

\end_inset

gecons.
 The number of gecons is polynomial, which is also true for most of the
 15 constraints we know.
\end_layout

\begin_layout Standard
Software engineers have a proverb that the lengthiest task is not to develop
 the software, but to make the customer realize his/her expectations.
 In lock-chart solving, the same applies for obtaining a complete, non-ambiguous
 specification of constraints.
\end_layout

\begin_layout Standard
It helps a lot if the manufacturer provides a list of all valid key cuttings
 in a text file.
 When it is the case, some algorithms can use the list directly.
\end_layout

\begin_layout Definition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Explicit framework
\end_layout

\end_inset

In the 
\emph on
explicit framework
\emph default
, the code space 
\begin_inset Formula $S$
\end_inset

 is a part of the algorithm's input.
\end_layout

\begin_layout Standard
This framework is suited for older platforms, where 
\begin_inset Formula $|S|$
\end_inset

 is a feasible number for the current generation of computers.
\end_layout

\begin_layout Paragraph
Hierarchy.
\end_layout

\begin_layout Standard
There is a certain hierarchy among the 4 frameworks.
 The vanilla framework is a special case of the asymmetric framework.
 By setting the deepest cutting 
\begin_inset Formula $(\tilde{d}_{1},\ldots,\tilde{d}_{p})=(d,\ldots,d)$
\end_inset

, both frameworks generate the same code space.
\end_layout

\begin_layout Standard
The asymmetric framework is a special case of the general framework.
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Start from the deepest cutting 
\begin_inset Formula $(\tilde{d}_{1},\ldots,\tilde{d}_{p})$
\end_inset

 and for every positions 
\begin_inset Formula $1\leq i\leq p$
\end_inset

 and every forbidden cutting depth 
\begin_inset Formula $\tilde{d}_{i}<j\leq d$
\end_inset

, generate 
\begin_inset Formula $1$
\end_inset

 gecon:
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
(\underbrace{?,?,\ldots,?}_{i-1},j,\underbrace{?,\ldots,?}_{p-i})\label{asym2gen-eq}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
This gecon effectively forbids the cutting depth 
\begin_inset Formula $j$
\end_inset

 at position 
\begin_inset Formula $i$
\end_inset

.
 Also, note that there are polynomially many such gecons; no more than 
\begin_inset Formula $d\cdot p$
\end_inset

.
\end_layout

\begin_layout Standard
The relationship between the general and the explicit frameworks is not
 that obvious.
 A brute force algorithm may iterate over all 
\begin_inset Formula $d^{p}$
\end_inset

 cuttings, check if the cutting is in 
\begin_inset Formula $S$
\end_inset

 or check against all gecons.
 However, this procedure is not polynomial in 
\begin_inset Formula $p$
\end_inset

.
 As we will see later, sub-exponential algorithms do not exist.
\begin_inset Foot
status open

\begin_layout Plain Layout
This holds unless 
\begin_inset Formula $\mathcal{P}=\mathcal{NP}$
\end_inset

.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "hierarchy-figure"

\end_inset

 concludes this section by a schema of frameworks' hierarchy, which will
 be referred in the future chapters.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename ConstraintHierarchy.pdf

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Hierarchy of constraint frameworks
\end_layout

\end_inset

Hierarchy of constraint frameworks.
 An arrow points from a special case to a more general framework.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "hierarchy-figure"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Lock-charts
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "lc-sec"

\end_inset


\end_layout

\begin_layout Standard
This section formalises the notion of a lock-chart.
 Their purpose is to define the computational task together with a constraint
 framework.
 A solution will be defined w.r.t.
 to a lock-chart.
\end_layout

\begin_layout Standard
The catch is that different manufacturers have different practices, which
 lead to different calculation procedures.
 Hence here we propose multiple definitions of “the lock-chart” together
 with their relationships, which will be used to analyse the computational
 complexity.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "basic-def"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Basic lock-chart
\end_layout

\end_inset

A 
\emph on
basic lock-chart
\emph default
 
\begin_inset Formula $(K,L,E)$
\end_inset

 consists of a 
\emph on
key-set
\emph default
 
\begin_inset Formula $K$
\end_inset

, a 
\emph on
lock-set
\emph default
 
\begin_inset Formula $L$
\end_inset

, which are disjoint 
\begin_inset Formula $K\cap L=\emptyset$
\end_inset

 and a binary relation 
\begin_inset Formula $E$
\end_inset

 on 
\begin_inset Formula $K\times L$
\end_inset

 called an 
\emph on
edge-set
\emph default
.
\end_layout

\begin_layout Standard
Since we will speak about basic lock-charts most of the time, they will
 be referred simply as “lock-charts” if not stated otherwise.
 
\end_layout

\begin_layout Standard
There is an parallel between lock-charts and graphs 
\begin_inset CommandInset citation
LatexCommand cite
key "lawer2004"

\end_inset

.
 Every lock-chart 
\begin_inset Formula $(K,L,E)$
\end_inset

 is by definition an undirected bipartite graph 
\begin_inset Formula $(K\cup L,E\cup E^{-1})$
\end_inset

 with 
\emph on
partite sets
\emph default
 
\begin_inset Formula $K$
\end_inset

 and 
\begin_inset Formula $L$
\end_inset

.
 This simplifies the terminology.
 Incident vertices are denoted as
\begin_inset Formula 
\[
E(k)=\left\{ l\in L\mid(k,l)\in E\right\} \text{, }E(l)=\left\{ k\in K\mid(k,l)\in E\right\} ,
\]

\end_inset

If 
\begin_inset Formula $(k,l)\in E$
\end_inset

, then we say that “
\begin_inset Formula $k$
\end_inset

 
\emph on
opens
\emph default
 
\begin_inset Formula $l$
\end_inset

”, otherwise “
\begin_inset Formula $l$
\end_inset

 
\emph on
stops
\emph default
 
\begin_inset Formula $k$
\end_inset

”.
\end_layout

\begin_layout Example
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "basic-fig"

\end_inset

 shows a basic lock-chart.
 Keys are in columns, locks in rows.
 If the cell is black, the row-lock opens the key-column.
 The lock-chart is formalised as follows:
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula 
\[
K=\{g,m_{1},m_{2},m_{3},k_{1},k_{2},\ldots,k_{12}\},\ L=\{l_{1},l_{2},\ldots,l_{12}\}\ ,
\]

\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula 
\[
E=\{(g,l_{1}),(g,l_{2}),\ldots,(m_{1},l_{1}),(m_{1},l_{2}),\ldots,(k_{1},l_{1}),(k_{2},l_{2}),\ldots\}\ .
\]

\end_inset


\end_layout

\begin_layout Example
By the defined notation, the following statements hold: 
\begin_inset Formula $E(g)=L$
\end_inset

, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $E(m_{1})=\{l_{1},l_{2},l_{3},l_{4}\}$
\end_inset

 and 
\begin_inset Formula $E(k_{i})=E(l_{i})$
\end_inset

 for 
\begin_inset Formula $1\leq i\leq12$
\end_inset

.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "gmik-def"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
General, master and individual keys
\end_layout

\end_inset

Let 
\begin_inset Formula $K$
\end_inset

 be a key-set, 
\begin_inset Formula $L$
\end_inset

 a lock-set, 
\begin_inset Formula $E$
\end_inset

 an edge-set and 
\begin_inset Formula $k\in K$
\end_inset

.
 If 
\begin_inset Formula $\vert E(k)\vert=1$
\end_inset

 then 
\begin_inset Formula $k$
\end_inset

 is an 
\emph on
individual key
\emph default
.
 If 
\begin_inset Formula $\vert E(k)\vert>1$
\end_inset

 then 
\begin_inset Formula $k$
\end_inset

 is a 
\emph on
master key
\emph default
.
 If 
\begin_inset Formula $|E(k)|=|L|$
\end_inset

 then 
\begin_inset Formula $k$
\end_inset

 is the 
\emph on
general key
\emph default
.
\end_layout

\begin_layout Standard
Lock-chart in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "basic-fig"

\end_inset

 has the general key 
\begin_inset Formula $g$
\end_inset

, 4 master keys 
\begin_inset Formula $g$
\end_inset

, 
\begin_inset Formula $m_{1}$
\end_inset

, 
\begin_inset Formula $m_{2}$
\end_inset

, 
\begin_inset Formula $m_{3}$
\end_inset

 and 12 individual keys 
\begin_inset Formula $k_{1}$
\end_inset

 to 
\begin_inset Formula $k_{12}$
\end_inset

.
\end_layout

\begin_layout Standard
Perhaps the simplest class of lock-chart with the general key are diagonal
 lock-charts.
 Each is determined by a single parameter — the number of individual keys.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "diag-def"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Diagonal lock-chart
\end_layout

\end_inset

A lock-chart with 1 general key and no other master key is a 
\emph on
diagonal
\emph default
 lock-chart.
\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lc-diag-k2d-figure"

\end_inset

 left shows a diagonal lock-chart.
 It has 5
\begin_inset space ~
\end_inset

keys 
\begin_inset Formula $K=\{g,k_{1},\ldots,k_{4}\}$
\end_inset

 and 4
\begin_inset space ~
\end_inset

locks 
\begin_inset Formula $L=\{l_{1},\ldots,l_{4}\}$
\end_inset

.
 Each individual key 
\begin_inset Formula $k_{1},\ldots,k_{4}$
\end_inset

 opens exactly 1
\begin_inset space ~
\end_inset

lock 
\begin_inset Formula $E(k_{i})=\{l_{i}\}$
\end_inset

, the general key 
\begin_inset Formula $g$
\end_inset

 opens all locks 
\begin_inset Formula $E(g)=L$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename DiagonalLockChart.pdf

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename KeyToDiff.pdf

\end_inset


\begin_inset space \hfill{}
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Diagonal and key-to-differ lock-charts
\end_layout

\end_inset

Diagonal lock-chart (left) and key-to-differ lock-chart (right) with 4 individua
l keys.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "lc-diag-k2d-figure"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
If the general key is removed from a diagonal lock-chart, we get an even
 simpler lock-chart.
 Such lock-charts are occasionally used in practice, nevertheless they play
 a major role in the theoretical analysis.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "k2d-def"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Key-to-differ
\end_layout

\end_inset

A lock-chart without master keys is a 
\emph on
key-to-differ lock-chart
\emph default
.
\end_layout

\begin_layout Standard
An example of a key-to-diff lock-chart is shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lc-diag-k2d-figure"

\end_inset

 on the right.
\end_layout

\begin_layout Paragraph
Solutions.
\end_layout

\begin_layout Standard
Having formalised the input to a calculation algorithm, next we specify
 its output.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "assign-def"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Assignment
\end_layout

\end_inset

Let 
\begin_inset Formula $K$
\end_inset

 be a key-set, 
\begin_inset Formula $L$
\end_inset

 a lock-set and 
\begin_inset Formula $S$
\end_inset

 a code space.
 
\emph on
Key-assignment
\emph default
 is a function 
\begin_inset Formula $s:K\rightarrow S$
\end_inset

 that assigns cuttings to keys and 
\emph on
lock-assignment
\emph default
 is a function 
\begin_inset Formula $t:L\rightarrow T$
\end_inset

 that assigns cylinders to locks.
 An 
\emph on
assignment
\emph default
 is a function 
\begin_inset Formula $s\cup t$
\end_inset

.
 We speak about a 
\emph on
partial assignment
\emph default
 if any of the two functions 
\begin_inset Formula $s$
\end_inset

 or 
\begin_inset Formula $t$
\end_inset

 is partial.
\end_layout

\begin_layout Standard
By inspecting each cell in the lock-chart, we check the correctness of an
 assignment.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "sol-def"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Solution
\end_layout

\end_inset

Let 
\begin_inset Formula $(K,L,E)$
\end_inset

 be a lock-chart and 
\begin_inset Formula $s\cup t$
\end_inset

 a (partial) assignment.
 If for every 
\begin_inset Formula $(k,\gamma)\in s$
\end_inset

 and for every 
\begin_inset Formula $(l,\lambda)\in t$
\end_inset

 
\begin_inset Formula 
\begin{equation}
\gamma\text{ enters }\lambda\text{ if and only if }k\text{ opens }l\text{ ,}\label{sol-eq}
\end{equation}

\end_inset

then 
\begin_inset Formula $s\cup t$
\end_inset

 is a 
\emph on
(partial) solution
\emph default
.
\end_layout

\begin_layout Standard
For clarity, partial assignments and solutions will be denoted as 
\begin_inset Formula $\hat{s}$
\end_inset

 unless stated otherwise.
\end_layout

\begin_layout Standard
A possibly non-trivial finding is that a lock-assignment can be ignored
 by a deterministic extension of a key-assignment.
\end_layout

\begin_layout Standard
First note that the more cutting depths a cylinder has the more shear-lines
 it contains.
 There are exactly 
\begin_inset Formula $\left|D_{1}\right|\times\cdots\times\left|D_{p}\right|$
\end_inset

 shear-lines in a cylinder 
\begin_inset Formula $(D_{1},\ldots D_{p})$
\end_inset

.
 This motivates a method to generate cylinders that block as many cuttings
 as possible.
\end_layout

\begin_layout Proposition
\begin_inset CommandInset label
LatexCommand label
name "least-cut-prop"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Least-cut
\end_layout

\end_inset

Let 
\begin_inset Formula $(K,L,E)$
\end_inset

 be a lock-chart and 
\begin_inset Formula $s\cup t$
\end_inset

 its solution.
 Then the assignment 
\begin_inset Formula $s\cup t'$
\end_inset

, where 
\begin_inset Formula 
\begin{equation}
t'(l)=\bigcup_{k\in E(l)}s(k)\label{least-cut-eq}
\end{equation}

\end_inset

is also a solution.
\end_layout

\begin_layout Proof
Take any lock 
\begin_inset Formula $l$
\end_inset

.
 In order to satisfy key openings, 
\begin_inset Formula 
\begin{equation}
t'(l)\subseteq\bigcup_{k\in E(l)}s(k)\subseteq t(l)\ .
\end{equation}

\end_inset

Since the blocking ability only weakens with additional cutting depths,
 each set 
\begin_inset Formula $t'(l)_{i}$
\end_inset

 is as small as possible.
\end_layout

\begin_layout Standard
Hence further in the text, when a key-assignment 
\begin_inset Formula $s:K\rightarrow S$
\end_inset

 is referred as a “solution”, we speak about a solution 
\begin_inset Formula $s\cup t'$
\end_inset

, where 
\begin_inset Formula $t'$
\end_inset

 is defined by (
\begin_inset CommandInset ref
LatexCommand ref
reference "least-cut-eq"

\end_inset

).
 When it is the case, we took the liberty of writing 
\begin_inset Formula $s(l)$
\end_inset

 for 
\begin_inset Formula $l\in L$
\end_inset

, which really means 
\begin_inset Formula $t'(l)$
\end_inset

, just to avoid overly complex notation.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "sol-ex"

\end_inset

Suppose that the diagonal lock-chart from Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lc-diag-k2d-figure"

\end_inset

 is assigned cuttings as follows: 
\begin_inset Formula $s(g)=(1,1,1,1)$
\end_inset

, 
\begin_inset Formula $s(k_{1})=(1,1,2,2)$
\end_inset

, 
\begin_inset Formula $s(k_{2})=(1,2,2,1)$
\end_inset

, 
\begin_inset Formula $s(k_{3})=(2,2,1,1)$
\end_inset

, 
\begin_inset Formula $s(k_{4})=(2,1,1,2)$
\end_inset

.
 Then the locks become
\begin_inset Formula 
\begin{eqnarray*}
t'(l_{1}) & = & (\{1\},\{1\},\{1,2\},\{1,2\})\\
t'(l_{2}) & = & (\{1\},\{1,2\},\{1,2\},\{1\})\\
t'(l_{3}) & = & (\{1,2\},\{1,2\},\{1\},\{1\})\\
t'(l_{4}) & = & (\{1,2\},\{1\},\{1\},\{1,2\})
\end{eqnarray*}

\end_inset


\end_layout

\begin_layout Example
The assignment is a solution: Key 
\begin_inset Formula $k_{2}$
\end_inset

 is blocked in 
\begin_inset Formula $l_{1}$
\end_inset

 in the 2
\begin_inset Formula $^{\text{nd}}$
\end_inset

 position, because 
\begin_inset Formula $s(k_{2})_{2}=2$
\end_inset

 is a cutting depth not present in 
\begin_inset Formula $t'(l_{1})_{2}=\{1\}$
\end_inset

.
 Similarly, key 
\begin_inset Formula $k_{3}$
\end_inset

 is blocked in 
\begin_inset Formula $l_{1}$
\end_inset

 in the 1
\begin_inset Formula $^{\text{st}}$
\end_inset

 and 2
\begin_inset Formula $^{\text{nd}}$
\end_inset

 position and key 
\begin_inset Formula $k_{4}$
\end_inset

 only in the 1
\begin_inset Formula $^{\text{st}}$
\end_inset

 position.
 The same is true for locks 
\begin_inset Formula $l_{2},\ldots,l_{4}$
\end_inset

.
\end_layout

\begin_layout Standard
Note that the proposition can reduce the number of available cylinders 
\begin_inset Formula $T$
\end_inset

.
 It is no longer necessary to consider all combinations of all cuttings
 as in (
\begin_inset CommandInset ref
LatexCommand ref
reference "cyl-space-eq"

\end_inset

).
 The union in (
\begin_inset CommandInset ref
LatexCommand ref
reference "least-cut-eq"

\end_inset

) iterates over 
\begin_inset Formula $E(l)$
\end_inset

, hence every lock 
\begin_inset Formula $l$
\end_inset

 is assigned a cylinder, which is a union of at most 
\begin_inset Formula $|E(l)|$
\end_inset

 different cuttings.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "cylinder-count-remark"

\end_inset

Let 
\begin_inset Formula $(K,L,E)$
\end_inset

 be a lock-chart and 
\begin_inset Formula $S$
\end_inset

 a code space.
 Every lock-assignment 
\begin_inset Formula $t$
\end_inset

 satisfies 
\begin_inset Formula $t\subseteq L\times T'$
\end_inset

, where
\begin_inset Formula 
\begin{equation}
T'=\left\{ \bigcup_{\gamma\in S'}\gamma\mid\text{for every }S'\subseteq S\text{ s.t. }|S'|\leq\max_{l\in L}|E(l)|\right\} .\label{cyl-space-eq-1}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Can the proposition be applied to partial key-assignments 
\begin_inset Formula $\hat{s}:K\rightharpoonup S$
\end_inset

 as well? Adapting equation (
\begin_inset CommandInset ref
LatexCommand ref
reference "least-cut-eq"

\end_inset

) needs only a cosmetic modification
\begin_inset Formula 
\begin{equation}
t'(l)=\bigcup_{k\in E(l)\text{ and }\hat{s}(k)\text{ is defined}}\hat{s}(k)\ ,\label{least-cut-partial-eq}
\end{equation}

\end_inset

and the definition of partial solutions still holds.
\end_layout

\begin_layout Standard
Observe that using (
\begin_inset CommandInset ref
LatexCommand ref
reference "least-cut-partial-eq"

\end_inset

), a partial key-assignment 
\begin_inset Formula $\hat{s}$
\end_inset

 yields a lock-assignment 
\begin_inset Formula $t'$
\end_inset

, which is not partial.
 Even if 
\begin_inset Formula $\hat{s}$
\end_inset

 is an empty function, the lock-assignment prescribes an empty cylinder
 to all locks 
\begin_inset Formula $t'(l)=(\emptyset,\ldots,\emptyset)$
\end_inset

.
\end_layout

\begin_layout Paragraph
Extension lock-charts.
\end_layout

\begin_layout Standard
An extension is a naturally occurring industrial problem when a customer
 orders master-key-systems in multiple batches.
 Each batch adds new keys or locks into the lock-chart, yet the solution
 to the original lock-chart remains fixed because it has already been manufactur
ed and shipped.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "lc-ext-def"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Extension lock-chart
\end_layout

\end_inset

 Let 
\begin_inset Formula $(K,L,E)$
\end_inset

 be a lock-chart and 
\begin_inset Formula $\hat{s}\cup\hat{t}$
\end_inset

 its partial solution.
 The 
\emph on
extension lock-chart
\emph default
 is 
\begin_inset Formula $(K,L,E,\hat{s}\cup\hat{t})$
\end_inset

.
 A (partial) assignment 
\begin_inset Formula $s\cup t$
\end_inset

 is a 
\emph on
(partial) solution
\emph default
 of 
\begin_inset Formula $(K,L,E,\hat{s}\cup\hat{t})$
\end_inset

 if 
\begin_inset Formula $\hat{s}\subseteq s$
\end_inset

, 
\begin_inset Formula $\hat{t}\subset t$
\end_inset

 and 
\begin_inset Formula $\hat{s}\cup\hat{t}$
\end_inset

 is a (partial) solution of 
\begin_inset Formula $(K,L,E)$
\end_inset

.
\end_layout

\begin_layout Standard
Extension lock-charts with 
\begin_inset Formula $\hat{s}=\hat{t}=\emptyset$
\end_inset

 are called 
\emph on
from-scratch lock-charts
\emph default
.
 Therefore basic lock-charts are a special case of extension lock-charts
 in the following sense: A assignment 
\begin_inset Formula $s$
\end_inset

 of a basic lock-chart 
\begin_inset Formula $(K,L,E)$
\end_inset

 is a solution if and only if it is a solution of the from-scratch lock-chart
 
\begin_inset Formula $(K,L,E,\emptyset)$
\end_inset

.
\end_layout

\begin_layout Paragraph
Profile maps.
\end_layout

\begin_layout Standard
Some mechanical platforms contain profiles and profile maps.
 A profile is a particular shape of a flat key's cross section or the keyway
 in a lock.
 Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "profiles-figure"

\end_inset

 shows examples of profile maps.
 Profiles can ensure that some flat keys cannot be physically inserted into
 certain keyways so that the blocking does not have to be done by pins,
 discs or any other elements inside the cylinder.
 This alleviates the number of blockings a cylinder must ensure, hence enlarging
 the capacity of the lock-chart.
\end_layout

\begin_layout Standard
Each key and lock in a lock-chart gets assigned one profile.
 The general key is usually assigned the profile with the least amount of
 metal.
 Like that, it enters all cylinders in the lock-chart.
 Typically, other master keys have more metal and individual keys have the
 most.
 This implies a reverse hierarchy among locks.
 Locks opened merely by a few master keys will be assigned profiles with
 more metal and less air than locks opened by individual keys.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename ProfilesPatent1.png
	lyxscale 10
	height 5cm

\end_inset

 
\begin_inset Graphics
	filename ProfilesPatent2.png
	lyxscale 10
	height 5cm

\end_inset

 
\begin_inset Graphics
	filename ProfilesPatent3.png
	lyxscale 10
	height 5cm

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Physical profiles
\end_layout

\end_inset

A physical profile on a cutting and in a cylinder (left) and key-profiles
 from a profile map (right).
\begin_inset Newline newline
\end_inset

Source: patent US 2011 0271723 A1 
\begin_inset CommandInset citation
LatexCommand cite
key "widen2011"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "profiles-figure"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Definition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Profile map
\end_layout

\end_inset

A 
\emph on
profile map 
\emph default

\begin_inset Formula $(P,\preceq)$
\end_inset

 consists of a set of 
\emph on
profiles
\emph default
 
\begin_inset Formula $P$
\end_inset

 and a partial order 
\begin_inset Formula $\preceq$
\end_inset

 on 
\begin_inset Formula $P$
\end_inset

.
 
\emph on
Profile assignment
\emph default
 is a function 
\begin_inset Formula $a:(K\cup L)\rightarrow P$
\end_inset

, which assigns profiles to keys and locks.
\end_layout

\begin_layout Standard
Let be a profile map 
\begin_inset Formula $(P,\preceq)$
\end_inset

 and 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $p'$
\end_inset

 be profiles in 
\begin_inset Formula $P$
\end_inset

.
 If 
\begin_inset Formula $p\preceq p'$
\end_inset

 we say that “
\begin_inset Formula $p$
\end_inset

 is 
\emph on
above
\emph default
 
\begin_inset Formula $p'$
\end_inset

” or “
\begin_inset Formula $p'$
\end_inset

 is 
\emph on
below
\emph default
 
\begin_inset Formula $p$
\end_inset

”.
 If 
\begin_inset Formula $p\not\preceq p'$
\end_inset

 and 
\begin_inset Formula $p'\not\preceq p$
\end_inset

 we say that “
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $p'$
\end_inset

 are 
\emph on
independent
\emph default
”.
\end_layout

\begin_layout Example
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "melted-fig"

\end_inset

 on the left shows a profile map with 
\begin_inset Formula $5$
\end_inset

 profiles 
\begin_inset Formula $P=\{1,2,3,4,5\}$
\end_inset

.
 Arrows pointing from 
\begin_inset Formula $p$
\end_inset

 to 
\begin_inset Formula $p'$
\end_inset

 means 
\begin_inset Formula $p\preceq p'$
\end_inset

 (transitive and reflexive tuples in 
\begin_inset Formula $\preceq$
\end_inset

 are hidden for clarity).
 Profiles 
\begin_inset Formula $2,3$
\end_inset

 and 
\begin_inset Formula $4$
\end_inset

 are all pair-wise independent.
 No other two profiles are independent.
\end_layout

\begin_layout Standard
The strategy for dealing with profile maps varies.
 Some manufacturers let the software find a profile assignment, some hand-code
 it manually for better control of future extensions.
 It is not hard to formalise the first approach.
 The algorithm would have to find a solution 
\begin_inset Formula $s$
\end_inset

 and a profile assignment 
\begin_inset Formula $a$
\end_inset

 as its output.
\end_layout

\begin_layout Standard
There are two reasons why we focused on the second approach.
 First, there is the practical experience.
 We have dealt mostly with lock-charts, whose profiles have been hand-coded,
 and hence our knowledge of efficient methods for finding profile assignments
 is not very deep.
 Second, ideas that will be presented in the next chapter require a fixed
 profile assignment.
\end_layout

\begin_layout Standard
Assuming that 
\begin_inset Formula $a$
\end_inset

 is fixed, the definition of the combinatorial problem can be simplified.
 Given an assignment, some blockings are ensured by means of profiles, not
 necessarily by pins in chambers.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "lc-profiled-def"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Profiled lock-chart
\end_layout

\end_inset

 Let 
\begin_inset Formula $(K,L,E)$
\end_inset

 be a lock-chart chart, 
\begin_inset Formula $(P,\preceq)$
\end_inset

 a profile-map and 
\begin_inset Formula $a:(K\cup L)\rightarrow P$
\end_inset

 a profile assignment.
 A 
\emph on
profiled lock-chart
\emph default
 is a tuple 
\begin_inset Formula $(K,L,E,P,\preceq,a)$
\end_inset

.
 Let 
\begin_inset Formula $s\cup t$
\end_inset

 be an assignment.
 If for every 
\begin_inset Formula $(k,\gamma)\in s$
\end_inset

 and 
\begin_inset Formula $(l,\lambda)\in t$
\end_inset


\begin_inset Formula 
\begin{equation}
k\text{ opens }l\text{ if and only if }\gamma\text{ enters }\lambda\text{ and }a(k)\preceq a(l)\label{lc-profiled-eq}
\end{equation}

\end_inset

then 
\begin_inset Formula $s\cup t$
\end_inset

 is a 
\emph on
(partial) solution
\emph default
 of 
\begin_inset Formula $(K,L,E,P,\preceq,a)$
\end_inset

.
\end_layout

\begin_layout Standard
The definition might be clearer by rewriting (
\begin_inset CommandInset ref
LatexCommand ref
reference "lc-profiled-eq"

\end_inset

) into an equivalent form using De Morgan's law:
\begin_inset Formula 
\begin{equation}
l\text{ stops }k\text{ if and only if }\lambda\text{ blocks }\gamma\text{ or }a(k)\not\preceq a(l)\label{lc-profiled-eq-eq}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Basic lock-charts are a special case of profiled lock-charts in the following
 sense: An assignment 
\begin_inset Formula $s$
\end_inset

 to a basic lock-chart 
\begin_inset Formula $(K,L,E)$
\end_inset

 is a solution if and only if it is a solution to a profiled lock-chart
 
\begin_inset Formula $(K,L,E,\{p\},\{(p,p)\},(K\cup L)\times\{p\})$
\end_inset

 with a single-profile profile map.
 This follows from 
\begin_inset Formula $a(k)=p\preceq p=a(l)$
\end_inset

 for all keys and locks and hence conditions (
\begin_inset CommandInset ref
LatexCommand ref
reference "sol-eq"

\end_inset

) and (
\begin_inset CommandInset ref
LatexCommand ref
reference "lc-profiled-eq"

\end_inset

) overlap.
\end_layout

\begin_layout Standard
Also note an immediate consequence of (
\begin_inset CommandInset ref
LatexCommand ref
reference "lc-profiled-eq"

\end_inset

).
 For every lock 
\begin_inset Formula $l$
\end_inset

 opened by some key 
\begin_inset Formula $k$
\end_inset

, the 
\begin_inset Formula $k$
\end_inset

's profile must be above the 
\begin_inset Formula $l$
\end_inset

's profile: 
\begin_inset Formula $a(k)\preceq a(l)$
\end_inset

; otherwise the lock-chart has no solution.
 Profile assignments that satisfy this condition are called 
\emph on
well-formed profile assignments
\emph default
.
 Since other profile assignments are meritless, from now on we will assume
 that all profile assignments are well-formed.
\end_layout

\begin_layout Standard
Because of the “or” in (
\begin_inset CommandInset ref
LatexCommand ref
reference "lc-profiled-eq-eq"

\end_inset

), in a profiled lock-chart each key-lock pair 
\begin_inset Formula $(k,l)$
\end_inset

 falls into 3 cases:
\end_layout

\begin_layout Enumerate
Either 
\begin_inset Formula $k$
\end_inset

 opens 
\begin_inset Formula $l$
\end_inset

,
\end_layout

\begin_layout Enumerate
or 
\begin_inset Formula $k$
\end_inset

 is blocked in 
\begin_inset Formula $l$
\end_inset

 by means of profiles 
\begin_inset Formula $a(k)\not\preceq a(l)$
\end_inset

,
\end_layout

\begin_layout Enumerate
or 
\begin_inset Formula $k$
\end_inset

 is blocked in 
\begin_inset Formula $l$
\end_inset

 not by profiles 
\begin_inset Formula $a(k)\preceq a(l)$
\end_inset

.
\end_layout

\begin_layout Example
Let the lock-chart from Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "basic-fig"

\end_inset

 be assigned profiles from the profile map in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "melted-fig"

\end_inset

 left as follows: 
\begin_inset Formula $a(g)=1$
\end_inset

, 
\begin_inset Formula $a(m_{1})=a(k_{i})=a(l_{i})=2$
\end_inset

 for 
\begin_inset Formula $1\leq i\leq4$
\end_inset

, 
\begin_inset Formula $a(m_{2})=a(k_{i})=a(l_{i})=3$
\end_inset

 for 
\begin_inset Formula $5\leq i\leq8$
\end_inset

 and 
\begin_inset Formula $a(m_{3})=a(k_{i})=a(l_{i})=3$
\end_inset

 for 
\begin_inset Formula $9\leq i\leq12$
\end_inset

.
 Then Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "melted-fig"

\end_inset

 on the right visualises the lock-chart, whose case 1 cells are filled black,
 case 2 are filled grey and case 3 are white.
\end_layout

\begin_layout Standard
These 3 cases of a profiled lock-chart's cells are reflected in the last
 definition of a lock-chart.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "melt-def"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Melted profiles lock-chart
\end_layout

\end_inset

 The 
\emph on
melted profiles lock-chart
\emph default
 
\begin_inset Formula $(K,L,E,B)$
\end_inset

 consists of a key-set 
\begin_inset Formula $K$
\end_inset

 a lock-set 
\begin_inset Formula $L$
\end_inset

 and two edge-sets 
\begin_inset Formula $E$
\end_inset

, 
\begin_inset Formula $B$
\end_inset

 s.t.
 
\begin_inset Formula $K\cap L=\emptyset$
\end_inset

 and 
\begin_inset Formula $E\cap B=\emptyset$
\end_inset

.
 Let 
\emph on

\begin_inset Formula $s\cup t$
\end_inset


\emph default
 be a (partial) assignment.
 If for every 
\begin_inset Formula $(k,\gamma)\in s$
\end_inset

 and 
\begin_inset Formula $(l,\lambda)\in L$
\end_inset

 these conditions hold:
\begin_inset Formula 
\begin{equation}
\begin{array}{cc}
\text{if }(k,l)\in E & \text{ then }s(k)\text{ enters }t(l)\text{ and}\\
\text{if }(k,l)\in B & \text{ then }t(l)\text{ blocks \ensuremath{s(k)}}\text{ ,}
\end{array}\label{lc-melted-eq}
\end{equation}

\end_inset

then 
\begin_inset Formula $s\cup t$
\end_inset

 is a 
\emph on
(partial) solution
\emph default
 to 
\begin_inset Formula $(K,L,E,B)$
\end_inset

.
\end_layout

\begin_layout Standard
Profiled lock-charts are a special case of a melted profiles lock-charts
 in the following sense: An assignment 
\begin_inset Formula $s\cup t$
\end_inset

 is a solution to 
\begin_inset Formula $(K,L,E,P,\preceq,a)$
\end_inset

 if and only if it is a solution to 
\begin_inset Formula $(K,L,E,B)$
\end_inset

, where
\begin_inset Formula 
\begin{equation}
B=\left\{ (k,l)\in K\times L\mid k\not\in E(l)\text{ and }a(k)\preceq a(l)\right\} \ .
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename MeltedProfileMap.pdf

\end_inset


\begin_inset space \hfill{}
\end_inset


\begin_inset Graphics
	filename MeltedLockChart.pdf
	scale 80

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Small profile map and a profiled lock-chart
\end_layout

\end_inset

A small profile map (left) and a profiled lock-chart which use the profile
 map (right).
 Grey cells indicate blocking by profile.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "melted-fig"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Hierarchy.
\end_layout

\begin_layout Standard
This section presented 5 types of lock-charts in Definitions
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "basic-def"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "diag-def"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "k2d-def"

\end_inset

, 
\begin_inset CommandInset ref
LatexCommand ref
reference "lc-ext-def"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "melt-def"

\end_inset

.
 Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lc-hierarchy-figure"

\end_inset

 shows their relationship graphically.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename LockChartHierarchy.pdf

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Hierarchy of lock-chart types
\end_layout

\end_inset

Hierarchy of lock-chart types.
 An arrow points from a special case to its generalisation.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "lc-hierarchy-figure"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Uniqueness.
\end_layout

\begin_layout Standard
Finally, we discuss an important assumption.
 Can two keys open the same set of locks (and two locks be opened by the
 same set of keys)? Theoretically yes, but there is a good reason not to
 allow this.
\end_layout

\begin_layout Standard
First, the “duplicate” keys 
\begin_inset Formula $k$
\end_inset

 and 
\begin_inset Formula $k'$
\end_inset

 in a basic lock-chart, whose 
\begin_inset Formula $E(k)=E(k')$
\end_inset

 can always be assigned the same cutting 
\begin_inset Formula $s(k)=s(k')$
\end_inset

.
 Assigning different cuttings would only weaken blocking properties of opened
 locks.
 Hence, from the calculation point of view, the duplicate keys are irrelevant.
 A similar reasoning goes for locks.
\end_layout

\begin_layout Assumption
\begin_inset CommandInset label
LatexCommand label
name "distinct-ass"

\end_inset

Let 
\begin_inset Formula $K$
\end_inset

 be a key-set, 
\begin_inset Formula $L$
\end_inset

 a lock-set and 
\begin_inset Formula $E$
\end_inset

 an edge-set.
 For any 
\begin_inset Formula $x,y\in K\cup L$
\end_inset

, if 
\begin_inset Formula $x\neq y$
\end_inset

 then 
\shape up

\begin_inset Formula $E(x)\neq E(y)$
\end_inset


\shape default
.
\end_layout

\begin_layout Corollary
\begin_inset CommandInset label
LatexCommand label
name "distinct-cor"

\end_inset

Let 
\begin_inset Formula $(K,L,E,\hat{s})$
\end_inset

 be an extension lock-chart and 
\begin_inset Formula $s$
\end_inset

 its solution.
 Any two distinct keys 
\begin_inset Formula $k\neq k'$
\end_inset

 are assigned distinct cuttings 
\begin_inset Formula $s(k)\neq s(k')$
\end_inset

.
\end_layout

\begin_layout Proof
Assume that the key 
\begin_inset Formula $k$
\end_inset

 opens some lock 
\begin_inset Formula $l$
\end_inset

.
 Since 
\begin_inset Formula $s$
\end_inset

 is a solution, 
\begin_inset Formula $s(k)$
\end_inset

 enters 
\begin_inset Formula $s(l)$
\end_inset

.
 Assume there is another key 
\begin_inset Formula $k'$
\end_inset

 with the same cutting 
\begin_inset Formula $s(k)=s(k')$
\end_inset

.
 Since 
\begin_inset Formula $s(k')$
\end_inset

 enters 
\begin_inset Formula $s(l)$
\end_inset

 and 
\begin_inset Formula $s$
\end_inset

 is a solution, 
\begin_inset Formula $k'$
\end_inset

 opens 
\begin_inset Formula $l$
\end_inset

.
 This reasoning holds for any lock 
\begin_inset Formula $l\in L$
\end_inset

, hence 
\begin_inset Formula $E(k)\subseteq E(k')$
\end_inset

.
 Symmetric reasoning from 
\begin_inset Formula $k'$
\end_inset

 to 
\begin_inset Formula $k$
\end_inset

 yields 
\begin_inset Formula $E(k)=E(k')$
\end_inset

.
 This violates Assumption
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "distinct-ass"

\end_inset

.
\end_layout

\begin_layout Standard
The main purpose of this corollary will become apparent in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "backtrackers-chapter"

\end_inset

.
 Here, it helps to understand the structure of a lock-chart.
\end_layout

\begin_layout Remark
No two individual keys open the same lock and no two locks are opened by
 the same individual key.
 Therefore, there the relation 
\emph on

\begin_inset Formula $E$
\end_inset


\emph default
 contains a bijection between individual keys and their associated locks,
 which will be called 
\emph on
individual locks
\emph default
.
\end_layout

\begin_layout Standard
Profiled and melted lock-charts are more complicated.
 We still apply the Assumption
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "distinct-ass"

\end_inset

 (so that the previous remark is valid), but the Corollary
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "distinct-cor"

\end_inset

 no longer holds.
 Its proof inferred that both 
\begin_inset Formula $k$
\end_inset

 and 
\begin_inset Formula $k'$
\end_inset

 opens 
\begin_inset Formula $l$
\end_inset

 using (
\begin_inset CommandInset ref
LatexCommand ref
reference "sol-eq"

\end_inset

).
 In profiled lock-charts, lock 
\begin_inset Formula $l$
\end_inset

 does not have to exist if profiles of 
\begin_inset Formula $k$
\end_inset

 and 
\begin_inset Formula $k'$
\end_inset

 are independent.
\end_layout

\begin_layout Section
Optimisation
\end_layout

\begin_layout Standard
The lock-chart and its solution defined so far are sufficient to ask: “Does
 a solution exist?” or “Provide a solution, please.” However, for various
 reasons, manufacturers often prefer some solutions over other ones.
 This naturally leads to finding a criterion to measure solution's quality
 and to rephrase lock-chart solving as an optimisation problem.
\end_layout

\begin_layout Standard
Especially  high-end, patented platforms are advertised with a security
 guarantee that any key cutting issued for one customer is never reused
 for a different customer.
 Calculation software fulfils this promise by dividing the code space into
 regions, each assigned to one lock-chart.
 A natural manufacturer's requirement is to make such regions as small as
 possible so that it is possible to calculate as many lock-charts as possible
 using one platform.
\end_layout

\begin_layout Definition
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Global virtual cylinder
\end_layout

\end_inset

Let 
\begin_inset Formula $K$
\end_inset

 be a key-set and 
\begin_inset Formula $s$
\end_inset

 an assignment.
 The 
\emph on
global virtual cylinder
\emph default
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Lambda$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 (abbreviated GVC) is a cylinder defined as the union of all cuttings assigned
 by 
\emph on

\begin_inset Formula $s$
\end_inset


\emph default
:
\end_layout

\begin_layout Definition
\begin_inset Formula 
\[
\Lambda=\bigcup_{k\in K}s(k)
\]

\end_inset


\end_layout

\begin_layout Standard
The GVC is used to define two criteria, which minimise the size of a region
 allocated to a lock-chart.
\end_layout

\begin_layout Criterion
\begin_inset Argument 1
status open

\begin_layout Plain Layout

\emph on
Maximizing prefix
\end_layout

\end_inset

Let 
\begin_inset Formula $(K,L,E)$
\end_inset

 be a lock-chart and 
\begin_inset Formula $s$
\end_inset

 its solution.
 The 
\emph on
prefix
\emph default
 is the largest 
\begin_inset Formula $r$
\end_inset

-tuple 
\begin_inset Formula $(d_{1},d_{2},\ldots,d_{r})$
\end_inset

 of cutting depths s.t.
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Lambda_{i}=\{d_{i}\}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 for all 
\begin_inset Formula $1\leq i\leq r$
\end_inset

.
 A solution with a longer prefix is preferred over a solution with a shorter
 prefix.
\end_layout

\begin_layout Standard
The prefix is a well-established criterion in the industry.
 Its practical advantage is that every lock-chart is associated with 
\begin_inset Formula $1$
\end_inset

 tuple, that defines its region in the code space.
 Then all new calculations cannot reuse the prefix.
 This can be done by translating prefixes into gecons.
 Adding a gecon 
\begin_inset Formula $(3,5,2,?,?)$
\end_inset

 to a platform prevents all keys from reusing the prefix 
\begin_inset Formula $(3,5,2)$
\end_inset

.
\end_layout

\begin_layout Standard
The prefix has a disadvantage when used as a criterion for comparing algorithms'
 performance.
 During prototyping, we often found that there is a critical prefix length
 
\begin_inset Formula $r$
\end_inset

, which is achieved quickly by almost all algorithms, yet extending 
\begin_inset Formula $r$
\end_inset

 by 
\begin_inset Formula $1$
\end_inset

 is intractable by all algorithms.
 For that reason we use a different criterion in this work, taken from 
\begin_inset CommandInset citation
LatexCommand cite
key "lawer2004"

\end_inset

, where it was defined as “consumed key codes”:
\end_layout

\begin_layout Criterion
\begin_inset CommandInset label
LatexCommand label
name "minimize-gvc-criterion"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Minimise shear-lines
\end_layout

\end_inset

Let 
\begin_inset Formula $(K,L,E)$
\end_inset

 be a lock-chart and 
\begin_inset Formula $s$
\end_inset

 its solution.
 The number of 
\emph on
shear-lines in GVC
\emph default
, denoted 
\begin_inset Formula $|\Lambda|$
\end_inset

, is defined as 
\begin_inset Formula $|\Lambda|=|\Lambda_{1}|\cdot|\Lambda_{2}|\cdots|\Lambda_{p}|$
\end_inset

.
 A solution with a smaller 
\begin_inset Formula $|\Lambda|$
\end_inset

 is preferred over a solution with a bigger 
\begin_inset Formula $|\Lambda|$
\end_inset

.
\end_layout

\begin_layout Standard
Each GVC after a calculation defines shear-lines that cannot be used in
 new calculations.
 It is not feasible to translate a forbidden region defined by a GVC into
 gecons as it was done with prefixes.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In the worst case 
\begin_inset Formula $|\Lambda|$
\end_inset

 grows exponentially in 
\begin_inset Formula $p$
\end_inset

.
 This would generate an exponential number of constraints.
\end_layout

\end_inset

 Instead solving a basic lock-chart 
\begin_inset Formula $(K,L,E)$
\end_inset

 with a forbidden GVC 
\begin_inset Formula $\Lambda$
\end_inset

 is equivalent to solving an extension lock-chart 
\begin_inset Formula $(K,L',E,\hat{s})$
\end_inset

 with 
\begin_inset Formula $1$
\end_inset

 additional lock 
\begin_inset Formula $L'=L\cup\{v\}$
\end_inset

, whose cylinder is fixed 
\begin_inset Formula $\hat{s}(v)=\Lambda$
\end_inset

.
 Since the new lock 
\begin_inset Formula $v$
\end_inset

 stops all keys, no keys in 
\begin_inset Formula $K$
\end_inset

 can be assigned a cutting which enters 
\begin_inset Formula $\Lambda$
\end_inset

.
\end_layout

\begin_layout Section
Extensions
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "extensions-section"

\end_inset


\end_layout

\begin_layout Standard
Empirical evidence indicates that finding a solution (or disproving its
 existence) to the extension lock-chart is easier than solving a basic lock-char
t.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
This is probably due to the fact that a partial solution reduces the number
 of free parameters in the calculation.
\end_layout

\end_inset

 The difficult part is to solve the from-scratch lock-chart so that its
 future extension is still solvable.
\end_layout

\begin_layout Standard
In general, this task is practically impossible.
 For almost any solution, there is an extension, which is unsolvable.
 Take two locks 
\begin_inset Formula $l$
\end_inset

, 
\begin_inset Formula $l'$
\end_inset

, their cylinders 
\begin_inset Formula $s(l)$
\end_inset

 and 
\begin_inset Formula $s(l')$
\end_inset

 and assume they do not share any shear-line.
 If the extension contains a new key 
\begin_inset Formula $k$
\end_inset

 s.t.
 
\begin_inset Formula $\{l,l'\}\subseteq E(k)$
\end_inset

, the extension lock-chart has no solution.
\end_layout

\begin_layout Standard
Inevitably, one must specify which extensions should be expected and for
 which one optimises the solver.
 This section will discuss their various types.
 When all expected extensions of the chosen type are added, the largest
 solvable lock-chart is formed.
 Such lock-chart will be called the 
\emph on
extremal lock-chart
\emph default
.
 This section will define two types of extremal lock-charts and further
 chapters will describe their solutions.
 A practical algorithm designed to solve from-scratch lock-charts can use
 cuttings from the extremal's lock-chart solution, which effectively prepares
 the solution for future extensions.
\end_layout

\begin_layout Paragraph
Independent master keys.
\end_layout

\begin_layout Standard
The first extremal lock-chart is suited for extensions, whose locks might
 be opened by an arbitrary combination of master keys.
 We formulate it for the vanilla framework with 
\begin_inset Formula $p$
\end_inset

 positions and 
\begin_inset Formula $d$
\end_inset

 cutting depths.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "lc-independent-definition"

\end_inset

Let there be 
\begin_inset Formula $|K|=p\cdot(d-1)+1$
\end_inset

 keys denoted 
\begin_inset Formula $K=\{k_{1},k_{2},\ldots\}$
\end_inset

 and 
\begin_inset Formula $2^{|K|}$
\end_inset

 locks denoted 
\begin_inset Formula $L=\{l_{1},l_{2},\ldots\}$
\end_inset

.
 In the 
\emph on
lock-chart of independent keys
\emph default
 
\begin_inset Formula $(K,L,E)$
\end_inset

 is a lock-chart, whose every lock is opened by a unique combination of
 keys:
\begin_inset Formula 
\[
E=\left\{ (k_{i},l_{j})\in K\times L\,|\,(j-1)\%2^{i}<2^{i-1}\right\} 
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename IndependentKeysLockChart.pdf

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Lock-chart of 4 independent keys
\end_layout

\end_inset

The lock-chart of 4 independent keys for 
\begin_inset Formula $p=3$
\end_inset

, 
\begin_inset Formula $d=2$
\end_inset

.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "independent-lc-figure"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Independent keys are meant for people, whose access to rooms or corridors
 might be arbitrarily changed.
 Say there is a lock 
\begin_inset Formula $l$
\end_inset

 opened by keys 
\begin_inset Formula $E(l)$
\end_inset

 and the access of key 
\begin_inset Formula $k$
\end_inset

 should be added or removed.
 The extension is formed by adding a lock opened by keys 
\begin_inset Formula $E(l)\cup\{k\}$
\end_inset

 or 
\begin_inset Formula $E(l)\setminus\{k\}$
\end_inset

.
 Knowing that a solution to the extremal lock-chart exists, the extension
 must be solvable.
\end_layout

\begin_layout Standard
The flexibility stems from the exponential number of locks.
 However, this comes at the price of a small number of keys.
 Essentially, there is a trade-off between knowing the structure of future
 extensions and maximizing the number of keys in the extension.
 Independent master keys are one side of a spectrum and individual keys
 are the on other one.
\end_layout

\begin_layout Paragraph
Non-independent master keys.
\end_layout

\begin_layout Standard
What happens if master keys are not marked as independent? We interpret
 this case by not expecting a new combination of master keys in an extension
 other than those combinations that appeared in the from-scratch problem.
\end_layout

\begin_layout Standard
The experience we gained when building commercial solvers suggests to “compress”
 master keys into the smallest code space possible.
 First individual keys are removed from the lock-chart and then the solver
 finds a solution which minimises 
\begin_inset Formula $|\Lambda|$
\end_inset

 (see Criterion
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "minimize-gvc-criterion"

\end_inset

) from master-keys' cuttings, which remained in the lock-chart.
 Practical algorithms with this objective will be presented in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "gvc-min-sec"

\end_inset

.
\end_layout

\begin_layout Standard
Admittedly, despite the practical experience, this approach lacks formal
 justification.
 Its analysis is one of the topics for future work.
\end_layout

\begin_layout Paragraph
Individual keys.
\end_layout

\begin_layout Standard
A typical use-case for extensions is when a customer adds a new room to
 the building or loses a key and asks for a safe replacement.
 Both involve adding 1 individual key and 1 lock opened by the key to a
 lock-chart so that the new key doesn't open any previously shipped locks
 and the new lock blocks all existing individual keys.
\end_layout

\begin_layout Standard
The lock-chart, which maximizes the code space for individual keys, yet
 keeps at least some master keys, is the diagonal lock-chart.
 Considering diagonal lock-chart as the extremal, a natural question is:
 “What is the size of the largest diagonal lock-chart”?
\end_layout

\begin_layout Standard
Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "diagonal-lc-complexity-section"

\end_inset

 will give a definitive answer for the vanilla framework.
 The same question for the asymmetric and generic frameworks, to which we
 have found a partial answer, is presented in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "count-chap"

\end_inset

.
\end_layout

\begin_layout Paragraph
Central locks.
\end_layout

\begin_layout Standard
Central locks are used for the main door of a building or doors on corridors
 or floors.
 As such, they are expected to be opened by many keys, often by most keys
 in the lock-chart.
 Hence we define 
\emph on
central lock
\emph default
 as a lock, which is expected to be opened by new keys in an extension.
 Central locks are usually marked as such by the customer.
\end_layout

\begin_layout Standard
The issue with central locks is to estimate the number of shear-lines in
 their cylinders.
 Implicit solutions add as few cutting depths into cylinders as possible
 (see Proposition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "least-cut-prop"

\end_inset

).
 The risk is that there are too few shear-lines in a cylinder and that they
 will not allow new keys from an extension to enter them.
 On the other hand, central locks still have to block some keys and going
 too far by adding all 
\begin_inset Formula $d\cdot p$
\end_inset

 cutting depths is certainly not desirable.
\end_layout

\begin_layout Standard
Mitigation of this issue is to add superfluous cutting depths into cylinders.
 How much and where? My experience says that this question is only of theoretica
l importance.
 Manufacturers usually specify roughly how many new keys are expected in
 new extensions.
 New cutting depths might be added until this criterion is reached.
\end_layout

\begin_layout Paragraph
Conclusion.
\end_layout

\begin_layout Standard
Extensibility in all its forms can make a constraint for the decision problem
 or a criterion for the optimisation problem.
 Take independent keys, which can be rephrased both as “find a solution
 with all keys independent” or “find a solution with as many keys marked
 as independent as possible”.
 My personal experience shows greater success with the former approach;
 nevertheless, such choice depends heavily on the business case and a particular
 algorithm employed.
\end_layout

\begin_layout Chapter
Complexity classes
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "complexity-chapter"

\end_inset


\end_layout

\begin_layout Standard
The question of the highest interest to all the customers, manufacturers
 and programmers, who design lock-chart solving algorithms, is probably:
 “Can I get a solution to this particular lock-chart in a reasonable time?”
 But the question has a tricky part – the notion of a 
\emph on
reasonable time
\emph default
.
 For manufacturers that we worked with, the reasonable time was somewhere
 between 1
\begin_inset space ~
\end_inset

minute and 1
\begin_inset space ~
\end_inset

hour.
 As programmers, we tried to persuade them that 1
\begin_inset space ~
\end_inset

day is also a reasonable time.
 And that within a few years, computers will become fast enough to meet
 the 1
\begin_inset space ~
\end_inset

hour deadline.
\end_layout

\begin_layout Standard
Such disputes are of no concern to computer scientists.
 Most computers ranging from mobile phones to Konrad Zuse's mechanical machines
 share the same mathematic model.
 The model works in time that is not proportional to our physical time and
 hence asking for the processing time of any particular lock-chart is meaningles
s.
 Instead, the right question to ask in this chapter is: “How does the run-time
 evolve when the size of the lock-chart grows?” Since the mathematical model
 more or less captures all current computers, it also shapes our expectations
 for practical algorithms.
\end_layout

\begin_layout Section
Preliminaries
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "theory-preliminaries-section"

\end_inset


\end_layout

\begin_layout Paragraph
Tractability.
\end_layout

\begin_layout Standard
Let there be a combinatorial 
\emph on
problem
\emph default
, whose instances are written in a formal language and let the instance
 size be 
\begin_inset Formula $n$
\end_inset

.
 A 
\emph on
decision problem 
\emph default
is a problem, to which the answer is 
\emph on
yes
\emph default
 or 
\emph on
no
\emph default
.
 A Turing machine has 
\emph on
time complexity
\emph default
 
\begin_inset Formula $T(n)$
\end_inset

 if it accepts the formal description of the problem instance and gives
 a yes/no answer in at most 
\begin_inset Formula $T(n)$
\end_inset

 time steps.
 A decision problem is in 
\begin_inset Formula $\mathcal{P}$
\end_inset

, if there exists a deterministic Turing machine with a time complexity
 polynomial in 
\begin_inset Formula $n$
\end_inset

.
 A decision problem is in 
\begin_inset Formula $\mathcal{NP}$
\end_inset

, if a solution to the yes-instance can be verified in 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
 The 
\begin_inset Formula $\mathcal{P}\stackrel{?}{=}\mathcal{NP}$
\end_inset

 hypothesis, recently surveyed in 
\begin_inset CommandInset citation
LatexCommand cite
key "aaronson2017"

\end_inset

 has not been proved at the time of writing this text.
\end_layout

\begin_layout Standard
A 
\emph on
polynomial reduction
\emph default
 is an algorithm that translates a formal description of one problem into
 another one.
 A decision problem is 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-hard if every problem in 
\begin_inset Formula $\mathcal{NP}$
\end_inset

 can be polynomially reduced to it.
 A decision problem is 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete if it is 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-hard and in 
\begin_inset Formula $\mathcal{NP}$
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "hopcroft2006"

\end_inset

.
\end_layout

\begin_layout Paragraph
Propositional logic.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $X$
\end_inset

 denote the set of 
\emph on
variables
\emph default
 denoted 
\begin_inset Formula $x_{1},x_{2},\ldots,x_{n}$
\end_inset

.
 Every variable is a 
\emph on
formula
\emph default
.
 If 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $F'$
\end_inset

 are formulas, then a 
\emph on
negation
\emph default
 of a formula 
\begin_inset Formula $\neg F$
\end_inset

, a 
\emph on
conjunction
\emph default
 of formulas 
\begin_inset Formula $F\wedge F'$
\end_inset

, a 
\emph on
disjunction
\emph default
 of formulas 
\begin_inset Formula $F\vee F'$
\end_inset

, an 
\emph on
implication
\emph default
 of formulas 
\begin_inset Formula $F\Rightarrow F'$
\end_inset

, and an 
\emph on
equivalence
\emph default
 of formulas 
\begin_inset Formula $F\Leftrightarrow F'$
\end_inset

 are also formulas.
\end_layout

\begin_layout Standard
An 
\emph on
interpretation
\emph default
 is a function 
\begin_inset Formula $\mathcal{I}:\,X\rightarrow\{0,1\}$
\end_inset

.
 The domain of 
\begin_inset Formula $\mathcal{I}$
\end_inset

 is recursively extended to all formulas: 
\begin_inset Formula $\mathcal{I}(\neg F)=1-\mathcal{I}(F)$
\end_inset

, 
\begin_inset Formula $\mathcal{I}(F\wedge F')=\min\left\{ \mathcal{I}(F),\mathcal{I}(F')\right\} $
\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
, 
\begin_inset Formula $\mathcal{I}(F\vee F')=\max\left\{ \mathcal{I}(F),\mathcal{I}(F')\right\} $
\end_inset

, 
\begin_inset Formula $s(F\Rightarrow F')=\mathcal{I}(\neg F\vee F')$
\end_inset

, 
\begin_inset Formula $\mathcal{I}(F\Leftrightarrow F')=\mathcal{I}((F\Rightarrow F')\wedge(F'\Rightarrow F))$
\end_inset

.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 An interpretation 
\begin_inset Formula $\mathcal{I}$
\end_inset

 is a 
\emph on
model
\emph default
 of a formula 
\begin_inset Formula $F$
\end_inset

 if 
\begin_inset Formula $\mathcal{I}(F)=1$
\end_inset

.
 Two formulas 
\begin_inset Formula $F$
\end_inset

 and 
\begin_inset Formula $F'$
\end_inset

 are 
\emph on
semantically equivalent
\emph default
 if 
\begin_inset Formula $\mathcal{I}$
\end_inset

 is a model of 
\begin_inset Formula $F$
\end_inset

 if and only if 
\begin_inset Formula $\mathcal{I}$
\end_inset

 is also a model of 
\begin_inset Formula $F'$
\end_inset

.
\end_layout

\begin_layout Paragraph
Conjunctive normal form.
\end_layout

\begin_layout Standard
Next, we consider a restricted class of formulas.
 Every variable 
\begin_inset Formula $x$
\end_inset

 is associated a 
\emph on
positive literal
\emph default
 
\begin_inset Formula $x$
\end_inset

 and a 
\emph on
negative literal
\emph default
 
\begin_inset Formula $\bar{x}$
\end_inset

.
 A disjunction of literals 
\begin_inset Formula $C=\bar{x}_{1}\vee\bar{x}_{2}\vee\cdots\vee\bar{x}_{i}\vee x_{i+1}\vee x_{i+2}\vee\cdots\vee x_{j}$
\end_inset

 is called a 
\emph on
clause
\emph default
 (with the first 
\begin_inset Formula $i$
\end_inset

 literals negative).
 The size of a clause 
\begin_inset Formula $|C|$
\end_inset

 is the number of its literals (
\begin_inset Formula $j$
\end_inset

 in this case).
 A conjunction of clauses is called a 
\emph on
formula in the conjunctive normal form
\emph default
, abbreviated as 
\emph on
CNF
\emph default
.
 The size of a CNF 
\begin_inset Formula $|F|$
\end_inset

 is the number of its clauses.
\end_layout

\begin_layout Standard
The 
\emph on
Boolean satisfiability problem
\emph default
 (SAT) is a combinatorial problem of finding a model to a CNF.
 SAT is 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete.
 The 
\emph on
2-satisfiability problem
\emph default
 (2SAT) is a SAT for clauses with at most 2 literals.
 The 2SAT problem is in 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
 The 
\emph on
sharp-SAT problem
\emph default
 (#SAT) is the problem of counting the number of models to a CNF.
 The #SAT problem is in the class #
\begin_inset Formula $\mathcal{P}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Graph problems.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $(V,E)$
\end_inset

 be an undirected graph and 
\begin_inset Formula $k\in\mathbb{N}$
\end_inset

.
 A set of nodes 
\begin_inset Formula $I\subseteq V$
\end_inset

 is 
\emph on
independent
\emph default
 if no vertices in 
\begin_inset Formula $I$
\end_inset

 are adjacent.
 The 
\emph on
maximum independent set problem
\emph default
 (MIS) is a problem of finding some largest independent set 
\begin_inset CommandInset citation
LatexCommand citep
key "tarjan1977"

\end_inset

.
 The 
\emph on
independent set decision problem
\emph default
 asks if the graph contains an independent set of size at least 
\begin_inset Formula $k$
\end_inset

.
 The problem is 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete.
 A 
\emph on
graph colouring function
\emph default
 is a function 
\begin_inset Formula $c:V\rightarrow\{1,2,\ldots,k\}$
\end_inset

, which assigns distinct values to all adjacent vertices.
 The 
\emph on
graph colouring problem
\emph default
 is an 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete problem to determine if there exists a graph colouring function
 given 
\begin_inset Formula $k$
\end_inset

.
\end_layout

\begin_layout Paragraph
Combinatorics.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $n,k\in\mathbb{W}$
\end_inset

.

\emph on
 Factorial
\emph default
 is the function 
\begin_inset Formula $n!=n\cdot(n-1)\cdots2\cdot1$
\end_inset

.
 The corner case is defined as 
\begin_inset Formula $0!=1$
\end_inset

.
 The 
\emph on
binomial coefficient
\emph default
 
\begin_inset Formula $\binom{n}{k}=\frac{n!}{k!\cdot(n-k)!}$
\end_inset

 counts the choices of 
\begin_inset Formula $k$
\end_inset

 items out of a basket with 
\begin_inset Formula $n$
\end_inset

 items.
\end_layout

\begin_layout Section
Verifying solutions
\end_layout

\begin_layout Standard
The ultimate goal of this chapter is to show 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-completeness of the lock-chart solving.
 First, we deal with the easier part, namely proving that lock-chart solving
 is in 
\begin_inset Formula $\mathcal{NP}$
\end_inset

.
\end_layout

\begin_layout Standard
Lock-chart solving is in 
\begin_inset Formula $\mathcal{NP}$
\end_inset

 if the solution can be verified in polynomial time.
 This can be done by checking if an assignment is a solution using Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sol-def"

\end_inset

, exemplified by Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "algorithm-verifier"

\end_inset

.
 Its runtime is polynomial in 
\begin_inset Formula $|K|$
\end_inset

, 
\begin_inset Formula $|L|,$
\end_inset

 
\begin_inset Formula $|E|,$
\end_inset

 
\begin_inset Formula $|B|$
\end_inset

, 
\begin_inset Formula $|S|$
\end_inset

, 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

.
\end_layout

\begin_layout Standard
The algorithm is formulated for the explicit constraint framework, where
 we can easily check 
\begin_inset Formula $s(k)\in S$
\end_inset

 by iterating over the set.
 However, if the code space 
\begin_inset Formula $S$
\end_inset

 was not given explicitly, the algorithm can be easily extended.
 The general framework can be used simply by writing a procedure for checking
 a cutting against a gecon (see Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "gecon-ex"

\end_inset

).
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
If still in doubt, fast forward to Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sat-sec"

\end_inset

.
 An equivalence-version of CNF constructed with a partial solution 
\begin_inset Formula $\hat{s}=s$
\end_inset

 has all clauses with at most 2 literals (after unit propagation).
 Since 2SAT is in 
\begin_inset Formula $\mathcal{P}$
\end_inset

, lock-charts in the general framework are in 
\begin_inset Formula $\mathcal{NP}$
\end_inset

, which also entails vanilla and asymmetric frameworks.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This shows that all lock-charts defined in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chapter-formalization"

\end_inset

 are 
\begin_inset Formula $\mathcal{NP}$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LinesNumbered
\end_layout

\begin_layout Plain Layout


\backslash
DontPrintSemicolon
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{Input}{input}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{Output}{output}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{Requires}{requires}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{Ensures}{ensures}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{Assume}{assume}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{FakeForAlignment}{requiress}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{Null}{null}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{Prune}{prune}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{Dfs}{csp-dfs}
\end_layout

\begin_layout Plain Layout


\backslash
SetKw{Continue}{continue}
\end_layout

\begin_layout Plain Layout


\backslash
SetKw{Throw}{throw}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{Function}{
\backslash
string:}{}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
Input{lock-chart $(K, L, E, B)$, partial solution $
\backslash
hat{s}$, solution $s$}
\end_layout

\begin_layout Plain Layout


\backslash
Output{
\backslash
textrm{true} if the solution is correct, otherwise 
\backslash
textrm{false}}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
BlankLine
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
ForEach(){$k 
\backslash
in K$}{
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
If{$s(k) 
\backslash
not= 
\backslash
hat{s}(k)$}{
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $
\backslash
mathrm{false}$
\backslash
;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
ForEach(){$l 
\backslash
in L$}{
\end_layout

\begin_layout Plain Layout

    
\backslash
If{$(k,l) 
\backslash
in E$}{
\end_layout

\begin_layout Plain Layout

      
\backslash
If{$s(l)$ 
\backslash
textrm{blocks} $s(k)$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
Return $
\backslash
mathrm{false}$
\backslash
;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
If{$(k,l) 
\backslash
in B$}{
\end_layout

\begin_layout Plain Layout

      
\backslash
If{$s(k)$ 
\backslash
textrm{opens} $s(l)$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
Return $
\backslash
mathrm{false}$
\backslash
;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
Return $
\backslash
mathrm{true}$
\backslash
;
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Solution verifier
\end_layout

\end_inset

Solution verifier for partially-solved melted profiles lock-charts.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "algorithm-verifier"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
SAT correspondence
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sat-correspondence-section"

\end_inset


\end_layout

\begin_layout Paragraph
General constraints.
\end_layout

\begin_layout Standard
At the beginning of the discussion of tractability, we discuss the constraints
 themselves.
 Are gecons expressive enough to encode complex combinatorial problems?
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "sat-correspondence-theorem"

\end_inset

Solving the 
\begin_inset Formula $1\times0$
\end_inset

 lock-chart 
\begin_inset Formula $(\left\{ k\right\} ,\emptyset,\emptyset)$
\end_inset

 in the general framework is 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete.
\end_layout

\begin_layout Standard
This theorem will be proved by creating a many-one polynomial reduction
 from SAT to the lock-chart problem.
 However, the first reduction is not presented in this section.
 The high-level idea of the reduction procedure uses an equivalence between
 a clause and a gecon.
 A gecon ensures that at least one cutting depth on a non-wildcard position
 must “deviate” from the constraint.
 The “at least one” corresponds to the disjunctions 
\begin_inset Formula $\vee$
\end_inset

 in a clause.
\end_layout

\begin_layout Claim
\begin_inset CommandInset label
LatexCommand label
name "sat-correspondence-claim"

\end_inset

Let there be a CNF with variables 
\begin_inset Formula $x_{1},\ldots,x_{n}$
\end_inset

.
 A lock-chart 
\begin_inset Formula $(\{k\},\emptyset,\emptyset)$
\end_inset

 with 
\begin_inset Formula $p=n$
\end_inset

, 
\begin_inset Formula $d=2$
\end_inset

 will be constructed.
 For every clause 
\begin_inset Formula $C$
\end_inset

 let there be 1 gecon 
\begin_inset Formula $(c_{1},\ldots,c_{p})$
\end_inset

.
 For every positive literal 
\begin_inset Formula $x_{i}\in C$
\end_inset

, the constriant has 
\begin_inset Formula $c_{i}=1$
\end_inset

.
 For every negative literal 
\begin_inset Formula $\bar{x}_{i}\in C$
\end_inset

, the constraint has 
\begin_inset Formula $c_{i}=2$
\end_inset

.
 For all remaining variables 
\begin_inset Formula $c_{i}=?$
\end_inset

.
 The lock-chart has a solution 
\begin_inset Formula $s$
\end_inset

 if and only if 
\begin_inset Formula $\mathcal{I}$
\end_inset

 is a model of the CNF, where 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathcal{I}(x_{i})=s(k)_{i}-1$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.
\end_layout

\begin_layout Proof
(
\begin_inset Formula $\Rightarrow$
\end_inset

) Assume 
\begin_inset Formula $s$
\end_inset

 is a solution to the lock-chart, yet 
\begin_inset Formula $\mathcal{I}$
\end_inset

 is not a model of the CNF.
 Then there must be a clause 
\begin_inset Formula $C=\bar{x}_{1}\vee\bar{x}_{2}\vee\cdots\vee\bar{x}_{i}\vee x_{i+1}\vee x_{i+2}\vee\cdots\vee x_{j}$
\end_inset

 s.t.
 
\begin_inset Formula $\mathcal{I}(C)=0$
\end_inset

 and therefore all its literals evaluate to 
\begin_inset Formula $0$
\end_inset

.
 For any negative literal 
\begin_inset Formula $\mathcal{I}(\bar{x}_{i})=0=1-\mathcal{I}(x_{i})$
\end_inset

, hence 
\begin_inset Formula $s(k)_{i}=2$
\end_inset

.
 Similarly for all positive literals 
\begin_inset Formula $x_{j}$
\end_inset

, 
\begin_inset Formula $s(k)_{i}=1$
\end_inset

.
 There is no position, where 
\begin_inset Formula $s(k)$
\end_inset

 deviates from the non-wildcard positions in the constraint created from
 
\begin_inset Formula $C$
\end_inset

.
 The cutting 
\begin_inset Formula $s(k)$
\end_inset

 does not satisfy the gecon and therefore 
\begin_inset Formula $s$
\end_inset

 is not a solution (a contradiction).
\end_layout

\begin_layout Proof
(
\begin_inset Formula $\Leftarrow$
\end_inset

) Assume 
\begin_inset Formula $\mathcal{I}$
\end_inset

 is a model of the CNF, yet there is no solution to the lock-chart.
 As there is no blocking cell in the lock-chart, a gecon must have been
 violated by 
\begin_inset Formula $s(k)$
\end_inset

.
 A contradiction is reached by similar reasoning as above.
 The violated constraint is associated with a clause, which must evaluate
 to 
\begin_inset Formula $0$
\end_inset

 under 
\begin_inset Formula $\mathcal{I}$
\end_inset

.
\end_layout

\begin_layout Standard
The result also applies to diagonal lock-charts.
 Observe that a diagonal lock-chart has as many locks as individual keys.
 A diagonal lock-chart with 
\begin_inset Formula $0$
\end_inset

 individual keys has exactly 
\begin_inset Formula $1$
\end_inset

 key (the general key) and no locks.
 Hence the 
\begin_inset Formula $1\times0$
\end_inset

 lock-chart is the smallest diagonal lock-chart and therefore solving diagonal
 lock-charts in the general framework are 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete.
\end_layout

\begin_layout Standard
Extending the result to the 
\begin_inset Formula $1\times1$
\end_inset

 key-to-differ lock-chart can be made by adding a redundant lock.
 The proofs in this section would neither change a lot, neither provide
 additional insight.
 Instead, the result is generalised to the whole class of key-to-differ
 lock-charts.
\end_layout

\begin_layout Paragraph
Key-to-differ lock-charts.
\end_layout

\begin_layout Standard
For clarity, a key-to-differ lock-chart is assumed to contain 
\begin_inset Formula $n$
\end_inset

 keys and 
\begin_inset Formula $n$
\end_inset

 locks 
\begin_inset Formula $K=\{k_{1},\ldots k_{n}\}$
\end_inset

, 
\begin_inset Formula $L=\{l_{1},\ldots,l_{n}\}$
\end_inset

 and both sets will indexed 
\begin_inset Quotes eld
\end_inset

conveniently
\begin_inset Quotes erd
\end_inset

 s.t.
 
\begin_inset Formula $E=\{(k_{1},l_{1}),(k_{2},l_{2}),\ldots,(k_{n},l_{n})\}$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "key2diff-sat-lemma"

\end_inset

A key-to-differ lock-chart with 
\begin_inset Formula $n$
\end_inset

 keys/locks has a solution if and only if there are at least 
\begin_inset Formula $n$
\end_inset

 available cuttings in the set of available keys 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Proof
All keys are individual.
 Hence all cylinders contain a single shear-line — namely the 
\begin_inset Formula $i$
\end_inset

-th lock's only shear-line is the 
\begin_inset Formula $i$
\end_inset

-th key's cutting.
 Such cylinder prevents all remaining keys 
\begin_inset Formula $k_{j}\not=k_{i}$
\end_inset

 from having the same cutting.
 By the pigeonhole principle it is possible to assign 
\begin_inset Formula $|S|$
\end_inset

 cuttings to 
\begin_inset Formula $n$
\end_inset

 keys if and only if 
\begin_inset Formula $n\leq|S|$
\end_inset

.
\end_layout

\begin_layout Standard
This lemma implies results to some trivial decision problems.
\end_layout

\begin_layout Corollary
A key-to-differ lock-chart with 
\begin_inset Formula $n$
\end_inset

 keys/locks is solvable in 
\begin_inset Formula $\mathcal{P}$
\end_inset

 if a) 
\begin_inset Formula $n\leq d^{p}$
\end_inset

 in vanilla framework, b) 
\begin_inset Formula $n\leq\tilde{d}_{1}\cdot\tilde{d}_{2}\cdot\cdots\cdot\tilde{d}_{p}$
\end_inset

 in asymmetric framework with the deepest cutting 
\begin_inset Formula $(\tilde{d}_{1},\ldots,\tilde{d}_{p})$
\end_inset

 or c) 
\begin_inset Formula $n\leq|S|$
\end_inset

 if the set 
\begin_inset Formula $S$
\end_inset

 is given by the explicit framework.
\end_layout

\begin_layout Standard
The only remaining question is whether key-to-diff lock-charts are solvable
 in the general framework.
\end_layout

\begin_layout Corollary
The problem of finding the largest key-to-differ lock-chart in the general
 framework is in 
\begin_inset Formula $\#\mathcal{P}$
\end_inset

.
\end_layout

\begin_layout Proof
As in the proof of Claim
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sat-correspondence-claim"

\end_inset

, every model is equivalent to 1 valid key cutting 
\begin_inset Formula $s(k)$
\end_inset

.
 By Lemma
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "key2diff-sat-lemma"

\end_inset

 every model corresponds to one key in a key-to-differ lock-chart.
 The number of models to a CNF is given by the #SAT problem, which is in
 
\begin_inset Formula $\#\mathcal{P}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Extensions lock-charts.
\end_layout

\begin_layout Standard
The idea of having two cutting depths for two boolean values and one position
 per variable, that we used in Lemma
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sat-correspondence-claim"

\end_inset

, is not new.
 Lawer 
\begin_inset CommandInset citation
LatexCommand cite
key "lawer2004"

\end_inset

 used a similar translation procedure to turn SAT into an extension lock-chart
 in the vanilla framework.
 Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sat-correspondence-theorem"

\end_inset

 will be related to Lawer's main result by a reduction of a basic lock-chart
 in general framework into an extension lock-chart in vanilla framework.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "universal-cylinder-lemma"

\end_inset

Let 
\begin_inset Formula $(c_{1},\ldots,c_{p})$
\end_inset

 be a gecon.
 A 
\emph on
universal cylinder
\emph default
 is 
\begin_inset Formula $(D_{1},\ldots,D_{n})$
\end_inset

, s.t.
 if 
\begin_inset Formula $c_{i}=\,?$
\end_inset

 then 
\begin_inset Formula $D_{i}=\{1,2,\ldots,d\}$
\end_inset

; otherwise 
\begin_inset Formula $D_{i}=\{c_{i}\}$
\end_inset

.
 A key cutting 
\begin_inset Formula $(d_{1},\ldots,d_{p})$
\end_inset

 satisfies the gecon if and only if it is blocked in its universal cylinder.
\end_layout

\begin_layout Proof
If the cutting depth satisfies the constraint, there is a position 
\begin_inset Formula $i$
\end_inset

, s.t.
 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $c_{i}\not=\,?$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 and 
\begin_inset Formula $c_{i}\not=d_{i}$
\end_inset

.
 Hence 
\begin_inset Formula $d_{i}\not\in D_{i}$
\end_inset

 and the cylinder blocks the cutting.
 If the cutting depth violates the constraint, all 
\begin_inset Formula $d_{i}\in D_{i}$
\end_inset

 and hence the cylinder is opened by the cutting.
\end_layout

\begin_layout Standard
The lemma gives a mechanism to turn constraints into extension's locks.
 Given a lock-chart 
\begin_inset Formula $(K,L,E)$
\end_inset

 with 
\begin_inset Formula $n$
\end_inset

 gecons, an extension lock-chart 
\begin_inset Formula $(K,L',E,\hat{s})$
\end_inset

 is constructed by adding one new lock for each constraint: 
\begin_inset Formula $L'=L\cup\{u_{1},\ldots,u_{n}\}$
\end_inset

.
 The partial solution 
\begin_inset Formula $\hat{s}(u_{i})$
\end_inset

 fixes the 
\begin_inset Formula $i$
\end_inset

-th added lock to a universal cylinder associated with the 
\emph on

\begin_inset Formula $i$
\end_inset


\emph default
-th gecon.
 Because every key is blocked in every 
\begin_inset Formula $u_{i}$
\end_inset

, the newly added locks have the same effect on the solution as the gecons.
\end_layout

\begin_layout Corollary
Extension lock-charts in the vanilla framework are 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete.
\end_layout

\begin_layout Standard
Since gecons are 
\emph on
slightly
\emph default
 less expressive than blocking by (universal) cylinders, our result in the
 previous section is a 
\emph on
slight
\emph default
 generalization of Lawer's result.
\end_layout

\begin_layout Section
Melted profiles lock-charts
\end_layout

\begin_layout Standard
While designing commercial solvers, which all ran in exponential time, we
 were constantly bothered with the question whether basic lock-charts in
 the vanilla framework can't be in 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
 Such eventuality would turn all such algorithms in vain.
 The closest we got to answer this question is a result on melted profiles
 lock-charts.
\end_layout

\begin_layout Standard
There is also a second motivation.
 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-completeness results so far relied on a growing number of positions.
 However, in some real-world platforms, the 
\begin_inset Formula $p$
\end_inset

 parameter is fixed and quite low, sometimes as low as 
\begin_inset Formula $5$
\end_inset

.
 Practically speaking, this makes it possible to iterate over 
\begin_inset Formula $d^{p}$
\end_inset

 cuttings on current CPUs.
 From a theoretical point of view, having 
\begin_inset Formula $p$
\end_inset

 fixed makes 
\begin_inset Formula $d^{p}$
\end_inset

 a constant-factor slow-down.
 Hence a practical algorithm, which scales badly in 
\begin_inset Formula $d^{p}$
\end_inset

, but well in other parameters (
\begin_inset Formula $|K|,|L|,|E|,\ldots$
\end_inset

) might still exist.
\end_layout

\begin_layout Standard
Admittedly, we were unable neither to prove or disprove the existence of
 such algorithm for basic lock-charts.
 Instead, this section has an 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-completeness result on melted profiles lock-charts with the property of
 having 
\begin_inset Formula $p=1$
\end_inset

.
\end_layout

\begin_layout Theorem
Let 
\emph on

\begin_inset Formula $(V,F)$
\end_inset


\emph default
 be an undirected graph and 
\begin_inset Formula $k$
\end_inset

 a natural number.
 The graph colouring problem is translated into a melted profile lock-chart
 
\begin_inset Formula $(K,L,E,B)$
\end_inset

.
 The lock-chart has a key 
\begin_inset Formula $k_{i}$
\end_inset

 and a lock 
\begin_inset Formula $l_{i}$
\end_inset

 for each vertex 
\begin_inset Formula $v_{i}\in V$
\end_inset

.
 The relation 
\begin_inset Formula $E$
\end_inset

 connects 
\begin_inset Formula $i$
\end_inset

-th key with 
\begin_inset Formula $i$
\end_inset

-th lock only (as in the key-to-differ lock-chart).
 The relation of stopped keys and locks 
\begin_inset Formula $B$
\end_inset

 connects 
\begin_inset Formula $k_{i}$
\end_inset

 and 
\begin_inset Formula $l_{j}$
\end_inset

 if 
\begin_inset Formula $(v_{i},v_{j})\in F$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Since 
\begin_inset Formula $(V,E)$
\end_inset

 is simple, 
\begin_inset Formula $E\cap B=\emptyset$
\end_inset

, which ensures that 
\begin_inset Formula $(K,L,E,B)$
\end_inset

 is a valid melted profiles lock-chart.
 
\end_layout

\end_inset

 The vanilla framework is used with 
\begin_inset Formula $p=1$
\end_inset

 and 
\begin_inset Formula $d=k$
\end_inset

.
 Given a solution to the lock-chart 
\begin_inset Formula $s$
\end_inset

, a graph colouring function 
\begin_inset Formula $f$
\end_inset

 defined as 
\begin_inset Formula $f(v_{i})=s(k_{i})_{1}$
\end_inset

 is a solution to the graph colouring problem.
 Solving melted profiles lock-charts in the vanilla framework is 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete.
\end_layout

\begin_layout Standard
The proof will show that 
\begin_inset Formula $f$
\end_inset

 solves the graph colouring problem.
\end_layout

\begin_layout Proof
Graph colouring function cannot assign the same color to adjacent vertices.
 Suppose it does by having some 
\begin_inset Formula $(v_{i},v_{j})\in F$
\end_inset

, s.t.
 
\begin_inset Formula $f(v_{i})=f(v_{j})=x$
\end_inset

.
 Then both keys 
\begin_inset Formula $k_{i}$
\end_inset

 and 
\begin_inset Formula $k_{j}$
\end_inset

 were assigned the cutting 
\begin_inset Formula $(x)$
\end_inset

 and lock 
\begin_inset Formula $l_{i}$
\end_inset

 (which is opened by 
\begin_inset Formula $k_{i}$
\end_inset

 only) was assigned the cylinder 
\begin_inset Formula $(\{x\})$
\end_inset

.
 Therefore 
\begin_inset Formula $k_{j}$
\end_inset

 is not blocked in 
\begin_inset Formula $l_{i}$
\end_inset

, which is a contradiction.
\end_layout

\begin_layout Standard
This concludes the discussion of 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-completeness.
 The rest of this chapter will identify problems that are solvable in 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
\end_layout

\begin_layout Section
Lock-chart of independent keys
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "independent-lc-complexity-section"

\end_inset


\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-completeness from previous sections motivates finding classes of lock-charts,
 whose solution can be found in polynomial time.
 Mechanical constraints, which can be almost arbitrary in practice, make
 it difficult to devise polynomial-time algorithms.
 Therefore from now on, the proofs will be restricted to a simple class
 of mechanical constraints to achieve a polynomial-time algorithm.
 This section starts with lock-charts of independent keys.
\end_layout

\begin_layout Theorem
Let 
\begin_inset Formula $K$
\end_inset

 be the set of keys in a lock-chart of independent keys.
 The 
\begin_inset Formula $i$
\end_inset

-th key is associated numbers 
\begin_inset Formula $x,y$
\end_inset

, where 
\begin_inset Formula $x=1+(i-2)\div(d-1)$
\end_inset

 and 
\begin_inset Formula $y=2+(i-2)\mathop{\%}(d-1)$
\end_inset

, except for the key 
\begin_inset Formula $k_{1}$
\end_inset

 which gets 
\begin_inset Formula $x=y=1$
\end_inset

.
 The assignment 
\begin_inset Formula $s$
\end_inset

 is a solution, where 
\begin_inset Formula 
\[
s(k_{i})=(\underbrace{1,\ldots,1}_{x-1},y,\underbrace{1,\ldots,1}_{p-x})\ .
\]

\end_inset


\end_layout

\begin_layout Proof
First note that every key has a unique tuple 
\begin_inset Formula $(x,y)$
\end_inset

 (because the formula is reversible: 
\begin_inset Formula $i=(x-1)\cdot(d-1)+y$
\end_inset

).
 The proof follows Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sol-def"

\end_inset

.
 Take any lock 
\begin_inset Formula $l$
\end_inset

.
 From each key 
\begin_inset Formula $k\in E(l)$
\end_inset

, the cylinder 
\begin_inset Formula $s(l)$
\end_inset

 contains the cutting depth 
\begin_inset Formula $y$
\end_inset

 at the 
\begin_inset Formula $x$
\end_inset

-th position: 
\begin_inset Formula $y\in s(l)_{x}$
\end_inset

.
 Take any stopped key 
\begin_inset Formula $k'\in K\setminus E(l)$
\end_inset

 and its 
\begin_inset Formula $x'$
\end_inset

 and 
\begin_inset Formula $y'$
\end_inset

 values.
 By the same reasoning, 
\begin_inset Formula $y'\not\in s(l)_{x'}$
\end_inset

, therefore 
\begin_inset Formula $s(k')$
\end_inset

 is blocked in 
\begin_inset Formula $s(l)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="4">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Key
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $y$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
cutting
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k_{1}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(1,1,1)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k_{2}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(2,1,1)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k_{3}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(1,2,1)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $k_{4}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $3$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $(1,1,2)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Independent keys lock-chart's solution
\end_layout

\end_inset

Solution to the lock-chart of 
\begin_inset Formula $4$
\end_inset

 independent keys for 
\begin_inset Formula $p=3$
\end_inset

, 
\begin_inset Formula $d=2$
\end_inset

.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "independent-lc-table"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Example
Assume 
\begin_inset Formula $p=3$
\end_inset

, 
\begin_inset Formula $d=2$
\end_inset

.
 Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand vref
reference "independent-lc-figure"

\end_inset

 shows the corresponding lock-chart of independent keys with 
\begin_inset Formula $4$
\end_inset

 keys.
 The solution is shown in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "independent-lc-table"

\end_inset

.
\end_layout

\begin_layout Corollary
Lock-chart of independent keys in the vanilla framework is solvable in 
\begin_inset Formula $\mathcal{P}$
\end_inset

 merely by deciding 
\begin_inset Formula $|K|\leq p\cdot(d-1)+1$
\end_inset

.
\end_layout

\begin_layout Standard
For clarity, the theory is formulated for the vanilla framework, but it
 can be easily extended to asymmetric ones.
 The principle is to spread 
\begin_inset Formula $x,y$
\end_inset

 values across cutting depths on all positions.
 In vanilla framework, there are 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $1+p\cdot(d-1)$
\end_inset

 such pairs, meanwhile in the asymmetric framework, there are 
\begin_inset Formula 
\[
1+\prod_{1\leq i\leq p}(\tilde{d}_{i}-1)\text{ of them.}
\]

\end_inset


\end_layout

\begin_layout Section
Diagonal lock-charts
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "diagonal-lc-complexity-section"

\end_inset


\end_layout

\begin_layout Standard
The proof of diagonal lock-charts' feasibility in this section is one of
 the main results of the text.
 We were able to formulate the result in the vanilla framework.
\end_layout

\begin_layout Standard
The strategy for assigning key cuttings is not a new invention.
 In the industry, it is known as the 
\emph on
rotating constant method
\emph default
.
 To the best of our knowledge, the only publication on this subject is 
\begin_inset CommandInset citation
LatexCommand cite
key "oshall2015"

\end_inset

, even though the method is widely recognized and used by many business
 partners.
 This section does not provide a wide introduction into rotating constant
 method; we focus on a proof of its completeness and assumptions behind
 it.
\end_layout

\begin_layout Standard
This section starts with a lower bound on the size of the largest solvable
 diagonal lock-chart without assuming any particular constraint framework.
 Then, assuming vanilla framework, this we prove an upper bound, which concludes
 the 
\begin_inset Formula $\mathcal{P}$
\end_inset

 time solvability of vanilla diagonal lock-charts.
\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $\gamma_{g}$
\end_inset

 be the general key's cutting and 
\begin_inset Formula $q\in\mathbb{W}$
\end_inset

 s.t.
 
\begin_inset Formula $q\leq p$
\end_inset

, Then 
\begin_inset Formula $S_{\mathit{q}}$
\end_inset

 is a set of all key cuttings, which are 
\emph on
equal to the general key
\emph default
 exactly in 
\begin_inset Formula $q$
\end_inset

 positions.
\end_layout

\begin_layout Example
If the general key is 
\begin_inset Formula $(1,1,1,1)$
\end_inset

, the 
\begin_inset Formula $S_{1}$
\end_inset

 cuttings include e.g.
 
\begin_inset Formula $(1,2,2,2)$
\end_inset

 and 
\begin_inset Formula $(2,2,1,2)$
\end_inset

, but neither 
\begin_inset Formula $(1,2,2,1)$
\end_inset

 nor 
\begin_inset Formula $(2,2,2,2)$
\end_inset

.
 Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sol-ex"

\end_inset

 contains shapes only from the 
\begin_inset Formula $S_{2}$
\end_inset

 set.
\end_layout

\begin_layout Standard
Even though 
\begin_inset Formula $S_{p}$
\end_inset

 is a perfectly well defined set, 
\begin_inset Formula $q<p$
\end_inset

 is assumed in this section, which excludes 
\begin_inset Formula $S_{p}$
\end_inset

 from the reasoning.
 Cuttings from 
\begin_inset Formula $S_{q}$
\end_inset

 are used for individual keys in a diagonal lock-chart and since 
\begin_inset Formula $S_{p}=\{\gamma_{g}\}$
\end_inset

, it makes no sense to reuse the general key's cutting for the first and
 only individual key.
\end_layout

\begin_layout Theorem
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Lower bound
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "thm:lower-bound"

\end_inset

The largest solvable diagonal lock-chart has at least 
\begin_inset Formula $\max_{q}|S_{q}|$
\end_inset

 individual keys.
\end_layout

\begin_layout Proof
Take any key 
\begin_inset Formula $k_{i}$
\end_inset

, which should be blocked (
\begin_inset Formula $i\neq j$
\end_inset

) in some lock 
\begin_inset Formula $l_{j}$
\end_inset

, which is opened only by 
\begin_inset Formula $g$
\end_inset

 and 
\begin_inset Formula $k_{j}$
\end_inset

.
 Let key cuttings be 
\begin_inset Formula $s(k_{i})=(d_{1}^{i},\ldots,d_{p}^{i})$
\end_inset

, 
\begin_inset Formula $s(k_{j})=(d_{1}^{j},\ldots,d_{p}^{j})$
\end_inset

 and 
\begin_inset Formula $s(g)=(d_{1}^{g},\ldots,d_{p}^{g})$
\end_inset

 and cylinder pins 
\begin_inset Formula $s(l_{j})=(D_{1}^{j},\ldots D_{p}^{j})$
\end_inset

.
 The proof is done by finding some blocking position 
\begin_inset Formula $r$
\end_inset

, s.t.
 
\begin_inset Formula $d_{r}^{i}\not\in D_{r}^{j}$
\end_inset

.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $A_{i}=\{r_{1}^{i},\ldots,r_{q}^{i}\}$
\end_inset

 be the set of 
\begin_inset Formula $q$
\end_inset

 positions, where the cutting of 
\begin_inset Formula $k_{i}$
\end_inset

 is equal to the cutting of the general key 
\begin_inset Formula $g$
\end_inset

.
 Formally 
\begin_inset Formula 
\[
A_{i}=\left\{ r\in\mathbb{N}\ |\ s(k_{i})_{r}=s(g)_{r}\right\} \ .
\]

\end_inset


\end_layout

\begin_layout Proof
a) 
\begin_inset Formula $A_{i}=A_{j}$
\end_inset

.
 Since 
\begin_inset Formula $k_{i}$
\end_inset

, 
\begin_inset Formula $k_{j}$
\end_inset

 and 
\begin_inset Formula $g$
\end_inset

 have different cuttings (by Corollary
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "distinct-cor"

\end_inset

) and 
\begin_inset Formula $q<p$
\end_inset

, there must be at least one position 
\begin_inset Formula $r\not\in A_{i}$
\end_inset

 where 
\begin_inset Formula $d_{r}^{i}\neq d_{r}^{j}$
\end_inset

 and 
\begin_inset Formula $d_{r}^{i}\neq d_{r}^{g}$
\end_inset

.
 On 
\begin_inset Formula $r$
\end_inset

, pins 
\begin_inset Formula $D_{r}^{j}=\{d_{r}^{g},d_{r}^{j}\}$
\end_inset

, which implies 
\begin_inset Formula $d_{r}^{i}\not\in D_{r}^{j}$
\end_inset

.
\end_layout

\begin_layout Proof
b) 
\begin_inset Formula $A_{i}\neq A_{j}$
\end_inset

: Since 
\begin_inset Formula $|A_{i}|=|A_{j}|=q$
\end_inset

, there is at least one position 
\begin_inset Formula $r\in A_{j}\setminus A_{i}$
\end_inset

 where 
\begin_inset Formula $k_{j}$
\end_inset

 equals 
\begin_inset Formula $g$
\end_inset

 (
\begin_inset Formula $d_{r}^{j}=d_{r}^{g}$
\end_inset

), but 
\begin_inset Formula $k_{i}$
\end_inset

 is not 
\begin_inset Formula $d_{r}^{i}\neq d_{r}^{j}$
\end_inset

.
 On 
\begin_inset Formula $r$
\end_inset

, pins 
\begin_inset Formula $D_{r}^{j}=\{d_{r}^{g}\}$
\end_inset

, which implies 
\begin_inset Formula $d_{r}^{i}\not\in D_{r}^{j}$
\end_inset

.
\end_layout

\begin_layout Proof
In both cases, 
\begin_inset Formula $s(k_{i})$
\end_inset

 is blocked in 
\begin_inset Formula $s(l_{j})$
\end_inset

 on the 
\begin_inset Formula $r$
\end_inset

-th position.
\end_layout

\begin_layout Standard
The proof of the upper bound is preceded with a few lemmas.
 First, a code-space symmetry is described, which proves that using the
 cutting 
\begin_inset Formula $(1,\ldots,1)$
\end_inset

 for the general key is as good as any other cutting.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "diagonal-sq-size-lemma"

\end_inset

Given 
\begin_inset Formula $q$
\end_inset

, in the vanilla framework, the size of 
\begin_inset Formula $S_{q}$
\end_inset

 is constant, irrespective of the general key's cutting:
\begin_inset Formula 
\begin{equation}
|S_{q}|=\binom{p}{p-q}\cdot(d-1)^{p-q}\label{Sq-size-equation}
\end{equation}

\end_inset


\end_layout

\begin_layout Proof
Suppose there is a general key cutting 
\begin_inset Formula $(g_{1},\ldots,g_{p})$
\end_inset

 and a cutting 
\begin_inset Formula $(d_{1},\ldots,d_{p})\in S_{q}$
\end_inset

.
 There are 
\begin_inset Formula $q$
\end_inset

 positions where the cutting depth matches 
\begin_inset Formula $g_{i}=d_{i}$
\end_inset

.
 In the 
\begin_inset Formula $p-q$
\end_inset

 remaining positions, 
\begin_inset Formula $d_{i}$
\end_inset

 can take any value 
\begin_inset Formula $1\leq d_{i}\leq d$
\end_inset

 except for 
\begin_inset Formula $g_{i}$
\end_inset

.
\end_layout

\begin_layout Definition
Given the general key 
\begin_inset Formula $g$
\end_inset

, and two cuttings 
\begin_inset Formula $\gamma$
\end_inset

, 
\begin_inset Formula $\gamma'$
\end_inset

.
 The cutting 
\begin_inset Formula $\gamma$
\end_inset

 is 
\emph on
unsuitable for individual keys in a diagonal lock-chart
\emph default
 with 
\begin_inset Formula $\gamma'$
\end_inset

 if the cylinder 
\begin_inset Formula $g\cup\gamma$
\end_inset

 is entered by 
\begin_inset Formula $\gamma'$
\end_inset

 or the cylinder 
\begin_inset Formula $g\cup\gamma'$
\end_inset

 is entered by 
\begin_inset Formula $\gamma$
\end_inset

.
\end_layout

\begin_layout Definition
The plan behind unsuitable cuttings is to find the largest set of suitable
 cuttings, which then forms a solution for the diagonal lock-chart.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "diagonal-sq-ratio-lemma"

\end_inset

Let 
\begin_inset Formula $0\leq r\leq q\leq p$
\end_inset

.
 In a single lock-chart, every cutting 
\begin_inset Formula $\gamma_{q}\in S_{q}$
\end_inset

 has 
\begin_inset Formula $\binom{p-r}{q-r}$
\end_inset

 unsuitable cuttings in 
\begin_inset Formula $S_{r}$
\end_inset

.
 Every cutting 
\begin_inset Formula $\gamma_{r}\in S_{r}$
\end_inset

 has 
\begin_inset Formula $\binom{q}{q-r}\cdot(d-1)^{q-r}$
\end_inset

 unsuitable keys in 
\begin_inset Formula $S_{q}$
\end_inset

.
 The ratio of these numbers is 
\begin_inset Formula 
\begin{equation}
\Omega=\frac{\binom{p-r}{q-r}}{\binom{q}{q-r}\cdot(d-1)^{q-r}}=\frac{|S_{q}|}{|S_{r}|}\ \text{.}\label{omega-definition-equation}
\end{equation}

\end_inset


\end_layout

\begin_layout Proof
A cutting 
\begin_inset Formula $\gamma_{r}\in S_{r}$
\end_inset

 differs from the general key in 
\begin_inset Formula $p-r$
\end_inset

 positions.
 By “overwriting” them in some 
\begin_inset Formula $q-r$
\end_inset

 positions by the depth of the general key, the newly obtained cutting 
\begin_inset Formula $\gamma_{q}$
\end_inset

 differs from the general in 
\begin_inset Formula $(p-r)-(q-r)=p-q$
\end_inset

 positions, hence 
\begin_inset Formula $\gamma_{q}\in S_{q}$
\end_inset

.
 There are exactly 
\begin_inset Formula $\binom{p-r}{q-r}$
\end_inset

 such overwritings.
\end_layout

\begin_layout Proof
Similarly, there are exactly 
\begin_inset Formula $\binom{q}{q-r}$
\end_inset

 combinations of positions, where “diverting” from the general key moves
 a key from 
\begin_inset Formula $S_{q}$
\end_inset

 to 
\begin_inset Formula $S_{r}$
\end_inset

.
 In each of them, there are exactly 
\begin_inset Formula $d-1$
\end_inset

 available depths different from the general.
 This gives the 
\begin_inset Formula $\binom{q}{q-r}\cdot(d-1)^{q-r}$
\end_inset

 formula.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $\gamma_{q}$
\end_inset

 and 
\begin_inset Formula $\gamma_{r}$
\end_inset

 be cuttings obtained by overwriting or diverting.
 Cylinder 
\begin_inset Formula $g\cup\gamma_{r}$
\end_inset

 can only have more shear-lines than 
\begin_inset Formula $g\cup\gamma_{q}$
\end_inset

, which is entered by 
\begin_inset Formula $\gamma_{q}$
\end_inset

.
 Hence 
\begin_inset Formula $\gamma_{q}$
\end_inset

 also enters 
\begin_inset Formula $g\cup\gamma_{r}$
\end_inset

 and 
\begin_inset Formula $\gamma_{q}$
\end_inset

 and 
\begin_inset Formula $\gamma_{r}$
\end_inset

 are not suitable.
\end_layout

\begin_layout Proof
The last equality for 
\begin_inset Formula $\Omega$
\end_inset

 is proven by simple algebra (using 
\begin_inset Formula $x^{y}\cdot x^{z}=x^{y+z}$
\end_inset

, 
\begin_inset Formula $\binom{n}{k}=\binom{n}{n-k}$
\end_inset

 and the definition of the binomial coefficient.
\end_layout

\begin_layout Example
Let 
\begin_inset Formula $p=4$
\end_inset

, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $d=2$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 and 
\begin_inset Formula $(1,1,1,1)$
\end_inset

.
 The cutting 
\begin_inset Formula $\gamma=(1,1,2,2)\in S_{2}$
\end_inset

 is unsuitable with 
\begin_inset Formula $\binom{4-2}{3-2}=2$
\end_inset

 cuttings from 
\begin_inset Formula $S_{3}$
\end_inset

, namely 
\begin_inset Formula $(1,1,1,2)$
\end_inset

 and 
\begin_inset Formula $(1,1,2,1)$
\end_inset

, because neither of them is blocked in cylinder 
\begin_inset Formula $\gamma\cup g=(\{1\},\{1\},\{1,2\},\{1,2\})$
\end_inset

.
 Similarly 
\begin_inset Formula $\gamma$
\end_inset

 is unsuitable with 
\begin_inset Formula $\binom{2}{2-1}\cdot(2-1)^{2-1}=2$
\end_inset

 cuttings from 
\begin_inset Formula $S_{1}$
\end_inset

, namely 
\begin_inset Formula $\gamma'=(1,2,2,2)$
\end_inset

 and 
\begin_inset Formula $\gamma''=(2,1,2,2)$
\end_inset

, because 
\begin_inset Formula $\gamma$
\end_inset

 is blocked neither in 
\begin_inset Formula $g\cup\gamma'$
\end_inset

, nor in 
\begin_inset Formula $g\cup\gamma''$
\end_inset

.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "distinct-gamma-suitable-lemma"

\end_inset

No two distinct cuttings 
\begin_inset Formula $\gamma,\gamma'\in S_{q}$
\end_inset

 are unsuitable with the same set of cuttings from a different 
\begin_inset Formula $S_{r}$
\end_inset

 set.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $g$
\end_inset

 be the general key's cutting.
 a) 
\begin_inset Formula $r<q$
\end_inset

: If two keys are assigned 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
distinct 
\begin_inset Formula $\gamma,\gamma'$
\end_inset

, their opened locks have cylinders 
\begin_inset Formula $g\cup\gamma$
\end_inset

, 
\begin_inset Formula $g\cup\gamma'$
\end_inset

 that are also distinct and therefore both are opened by different sets
 of cuttings from 
\begin_inset Formula $S_{r}$
\end_inset

.
 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
b) 
\begin_inset Formula $r>q$
\end_inset

: Reasoning is similar, by considering cylinders of keys unsuitable with
 
\begin_inset Formula $\gamma$
\end_inset

 and 
\begin_inset Formula $\gamma'$
\end_inset

.
\end_layout

\begin_layout Proof
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset space \hspace{}
\length -1.5cm
\end_inset


\begin_inset Graphics
	filename UpperBoundIllustration.pdf

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Unsuitable cuttings grouped into 
\begin_inset Formula $S_{q}$
\end_inset

 sets
\end_layout

\end_inset

All cuttings from a vanilla framework 
\begin_inset Formula $p=3$
\end_inset

, 
\begin_inset Formula $d=3$
\end_inset

, grouped into 
\begin_inset Formula $S_{q}$
\end_inset

 sets w.r.t.
 the general key 
\begin_inset Formula $(1,1,1)$
\end_inset

.
 Selected pairs of unsuitable cuttings are joined by red lines.
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The last lemma needed for the main theorem generalises the binomial coefficient.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:n-choose-k-max-r"

\end_inset

 Let 
\begin_inset Formula $C$
\end_inset

 be a set of all subsets of 
\begin_inset Formula $\{1,\ldots,n\}$
\end_inset

, whose cardinality is 
\begin_inset Formula $k$
\end_inset

 (
\begin_inset Formula $\forall K\in C.\,|K|=k$
\end_inset

).
 If every 
\begin_inset Formula $i\in\{1,\ldots,n\}$
\end_inset

 appears in at most 
\begin_inset Formula $r$
\end_inset

 subsets, then 
\begin_inset Formula $|C|\leq\frac{n}{k}\cdot r$
\end_inset

.
 If moreover 
\begin_inset Formula $k$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

 are divisible, then 
\begin_inset Formula $|C|=\frac{n}{k}\cdot r$
\end_inset

.
\end_layout

\begin_layout Example*
For 
\begin_inset Formula $n=4$
\end_inset

, 
\begin_inset Formula $k=2$
\end_inset

 and 
\begin_inset Formula $r$
\end_inset

 unrestricted, 
\begin_inset Formula $C$
\end_inset

 has 
\begin_inset Formula $\binom{4}{2}=6$
\end_inset

 subsets 
\begin_inset Formula $C=\{\{1,2\}$
\end_inset

, 
\begin_inset Formula $\{1,3\}$
\end_inset

, 
\begin_inset Formula $\{1,4\}$
\end_inset

, 
\begin_inset Formula $\{2,3\}$
\end_inset

, 
\begin_inset Formula $\{2,4\}$
\end_inset

, 
\begin_inset Formula $\{3,4\}\}$
\end_inset

.
 By deleting 
\begin_inset Formula $\{1,2\}$
\end_inset

 and 
\begin_inset Formula $\{3,4\}$
\end_inset

, every number appears exactly 
\begin_inset Formula $r=2$
\end_inset

 times.
 Indeed 
\begin_inset Formula $\frac{n}{k}\cdot r=4$
\end_inset

 remaining subsets.
\end_layout

\begin_layout Note*
From the binomial coefficient 
\begin_inset Formula $\frac{n}{k}\cdot r=|C|\leq\binom{n}{k}$
\end_inset

.
 Therefore 
\begin_inset Formula $r\leq\binom{n}{k}/\frac{n}{k}$
\end_inset

 and hence 
\begin_inset Formula $r\leq\binom{n-1}{k-1}$
\end_inset

.
\end_layout

\begin_layout Proof
Inequality: Let 
\begin_inset Formula $C_{i}$
\end_inset

 denote the elements of 
\begin_inset Formula $C$
\end_inset

 which contain 
\begin_inset Formula $i$
\end_inset

.
 By definition 
\begin_inset Formula $|C_{i}|\leq r$
\end_inset

 and therefore 
\begin_inset Formula $\sum_{i=1}^{n}|C_{i}|\leq n\cdot r$
\end_inset

.
 Also 
\begin_inset Formula $|C|\cdot k=\sum_{i}|C_{i}|\leq n\cdot r$
\end_inset

 which yields the inequality.
\end_layout

\begin_layout Proof
Equality: 1.
\begin_inset space ~
\end_inset

Initialise 
\begin_inset Formula $r=0$
\end_inset

 and 
\begin_inset Formula $C=\emptyset$
\end_inset

.
 2.
\begin_inset space ~
\end_inset

Take a permutation 
\begin_inset Formula $\pi=\{\pi_{1},\ldots,\pi_{n}\}$
\end_inset

 of the set 
\begin_inset Formula $\{1,\ldots,n\}$
\end_inset

 and chop it into chunks of size 
\begin_inset Formula $k$
\end_inset

 (assuming 
\begin_inset Formula $n$
\end_inset

 and 
\begin_inset Formula $k$
\end_inset

 divisible) to obtain sets 
\begin_inset Formula $c_{1}=\{\pi_{1},\pi_{2},\ldots,\pi_{k}\}$
\end_inset

, 
\begin_inset Formula $c_{2}=\{\pi_{k+1},\ldots,\pi_{2k}\}$
\end_inset

, 
\begin_inset Formula $\ldots$
\end_inset

, 
\begin_inset Formula $c_{\frac{n}{k}}=\{\pi_{n-k+1},\ldots,\pi_{n}\}$
\end_inset

.
 3.
\begin_inset space ~
\end_inset

If 
\begin_inset Formula $C$
\end_inset

 does not contain any of the 
\begin_inset Formula $c$
\end_inset

 sets, then increase 
\begin_inset Formula $r$
\end_inset

 by 
\begin_inset Formula $1$
\end_inset

 and add all 
\begin_inset Formula $c$
\end_inset

 sets (
\begin_inset Formula $\frac{n}{k}$
\end_inset

 many of them) into
\begin_inset space ~
\end_inset


\begin_inset Formula $C$
\end_inset

.
 4.
\begin_inset space ~
\end_inset

Reiterate from step 2.
 This algorithm has 2 invariants: 
\begin_inset Formula $|C|=\frac{n}{k}\cdot r$
\end_inset

 and 
\begin_inset Formula $C_{i}=r$
\end_inset

.
\end_layout

\begin_layout Theorem
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Upper bound
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "thm:upper-bound"

\end_inset

The largest solvable diagonal lock-chart has at most 
\begin_inset Formula $\max_{q}|S_{q}|$
\end_inset

 individual keys.
\end_layout

\begin_layout Proof
Take any two distinct sets 
\begin_inset Formula $S_{r}$
\end_inset

 and 
\begin_inset Formula $S_{q}$
\end_inset

.
 Suppose there is a lock-chart with a solution 
\begin_inset Formula $s'$
\end_inset

, whose individual keys are assigned cuttings 
\begin_inset Formula $S_{r}'\cup S_{q}'$
\end_inset

, where 
\begin_inset Formula $S_{r}'\subseteq S_{r}$
\end_inset

 and 
\begin_inset Formula $S_{q}'\subseteq S_{q}$
\end_inset

.
 Their complements are denoted 
\begin_inset Formula $\bar{S}_{r}'=S_{r}\setminus S_{r}'$
\end_inset

 and 
\begin_inset Formula $\bar{S}_{q}'=S_{q}\setminus S_{q}'$
\end_inset

.
 This proof will show that there is another solvable lock-chart with at
 least 
\begin_inset Formula $\max\{|S_{r}|,|S_{q}|\}$
\end_inset

 individual keys.
\end_layout

\begin_layout Proof
Given that the solution is correct, all keys from 
\begin_inset Formula $S_{r}'\cup S_{q}'$
\end_inset

 are pair-wise suitable.
 Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "thm:lower-bound"

\end_inset

 implies that all keys from 
\begin_inset Formula $S_{r}$
\end_inset

 are pair-wise suitable, as well as keys from 
\begin_inset Formula $S_{q}$
\end_inset

.
 Therefore, the only pairs of unsuitable keys are I.
 in 
\begin_inset Formula $S_{r}'\times\bar{S}_{q}'$
\end_inset

, II.
 in 
\begin_inset Formula $S_{q}'\times\bar{S}_{r}'$
\end_inset

 and III.
 in 
\begin_inset Formula $\bar{S}_{r}'\times\bar{S}_{q}'$
\end_inset

.
\end_layout

\begin_layout Proof
Consider the case I.
 (resp.
 II.) and assume 
\begin_inset Formula $r<q$
\end_inset

 
\shape smallcaps
\size small
WLOG
\shape default
\size default
.
 By Lemma
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "diagonal-sq-ratio-lemma"

\end_inset

, every cutting in 
\begin_inset Formula $S_{r}'$
\end_inset

 (resp.
 
\begin_inset Formula $S_{q}'$
\end_inset

) has 
\begin_inset Formula $\binom{p-r}{q-r}$
\end_inset

 (resp.
 
\begin_inset Formula $\binom{q}{r}\cdot(d-1)^{q-r}$
\end_inset

) unsuitable cuttings in 
\begin_inset Formula $\bar{S}_{q}'$
\end_inset

 (resp.
 
\begin_inset Formula $\bar{S}_{r}'$
\end_inset

).
 By Lemma
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "distinct-gamma-suitable-lemma"

\end_inset

, for every cutting in 
\begin_inset Formula $S_{r}'$
\end_inset

 (resp.
 
\begin_inset Formula $S_{q}'$
\end_inset

), there is a distinct combination of cuttings in 
\begin_inset Formula $\bar{S}_{q}'$
\end_inset

 (resp.
 
\begin_inset Formula $\bar{S}_{r}'$
\end_inset

).
 By the same reasoning, a cutting can appear in at most 
\begin_inset Formula $\binom{q}{r}\cdot(d-1)^{q-r}$
\end_inset

 (resp.
 
\begin_inset Formula $\binom{p-r}{q-r}$
\end_inset

) such combinations (again by Lemma
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "diagonal-sq-ratio-lemma"

\end_inset

).
 This gives two formulas as applications of Lemma
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lem:n-choose-k-max-r"

\end_inset

:
\end_layout

\begin_layout Proof
\begin_inset Formula 
\begin{equation}
\frac{|\bar{S}_{q}'|}{\binom{p-r}{q-r}}\cdot\left[\binom{q}{q-r}\cdot(d-1)^{q-r}\right]=\frac{|S_{q}|-|S_{q}'|}{\Omega}\geq|S_{r}'|\ \text{.}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
\left(\text{resp. }\frac{|S_{r}|-|S_{r}'|}{\binom{q}{q-r}\cdot(d-1)^{q-r}}\cdot\binom{p-r}{q-r}=\Omega\cdot\left(|S_{r}|-|S_{r}'|\right)\geq|S_{q}'|\right)
\end{equation}

\end_inset


\end_layout

\begin_layout Proof
Next, assume 
\begin_inset Formula $S_{q}\geq S_{r}$
\end_inset

, which gives 
\begin_inset Formula $\Omega\geq1$
\end_inset

 (resp.
 
\begin_inset Formula $S_{r}\geq S_{q}$
\end_inset

, 
\begin_inset Formula $\Omega\leq1$
\end_inset

).
 The equation can be rewritten as 
\begin_inset Formula $|S_{q}|\geq|S_{r}'|\cdot\Omega+|S_{q}'|\geq|S_{r}'|+|S_{q}'|$
\end_inset

 (resp.
 
\begin_inset Formula $|S_{r}|\geq\frac{|S_{q}'|}{\Omega}+|S_{r}'|\geq|S_{q}'|+|S_{r}'|$
\end_inset

).
 Therefore 
\begin_inset Formula $S_{r}'\cup S_{q}'$
\end_inset

, arbitrarily chosen subsets of 
\begin_inset Formula $S_{r}$
\end_inset

 and 
\begin_inset Formula $S_{q}$
\end_inset

, cannot be larger than 
\begin_inset Formula $S_{q}$
\end_inset

 (resp.
 
\begin_inset Formula $S_{r}$
\end_inset

).
 Since 
\begin_inset Formula $S_{q}$
\end_inset

 is bigger than 
\begin_inset Formula $S_{r}$
\end_inset

 (resp.
 
\begin_inset Formula $S_{r}$
\end_inset

 is bigger than 
\begin_inset Formula $S_{q}$
\end_inset

), there is a diagonal lock-chart, whose individual keys take cuttings form
 
\begin_inset Formula $S_{q}$
\end_inset

 (resp.
 
\begin_inset Formula $S_{r}$
\end_inset

), which is bigger than 
\begin_inset Formula $|S_{r}'\cup S_{q}'|$
\end_inset

.
 By pair-wise comparison, we can maximize over all 
\begin_inset Formula $S_{0},\ldots,S_{p}$
\end_inset

.
\end_layout

\begin_layout Standard
Theorems
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "thm:lower-bound"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "thm:upper-bound"

\end_inset

 together imply that by finding some optimal value 
\begin_inset Formula $\hat{q}=\arg\max_{q}|S_{q}|$
\end_inset

 the cuttings from 
\begin_inset Formula $S_{\hat{q}}$
\end_inset

 allow solving the largest possible lock-chart.
 Next, we show how to find 
\begin_inset Formula $\hat{q}$
\end_inset

 even faster than by iterating over all 
\begin_inset Formula $S_{q}$
\end_inset

s.
\end_layout

\begin_layout Theorem
\begin_inset CommandInset label
LatexCommand label
name "optimalq-theorem"

\end_inset

An optimal value 
\begin_inset Formula $\hat{q}$
\end_inset

, which maximizes 
\begin_inset Formula $|S_{q}|$
\end_inset

 is 
\begin_inset Formula 
\begin{equation}
\hat{q}=\left\lfloor \frac{p+1}{d}\right\rfloor \ \text{.}\label{qHat-definition-equation}
\end{equation}

\end_inset


\end_layout

\begin_layout Proof
a) 
\begin_inset Formula $|S_{\hat{q}}|\geq|S_{\hat{q}+1}|$
\end_inset

:
\begin_inset Formula 
\begin{align}
\binom{p}{\hat{q}}\cdot(d-1)^{p-\hat{q}} & \geq\binom{p}{\hat{q}+1}\cdot(d-1)^{p-(\hat{q}+1)}\\
(d-1) & \geq\frac{p-\hat{q}}{\hat{q}+1}\\
\hat{q} & \geq\frac{p+1}{d}-1
\end{align}

\end_inset


\end_layout

\begin_layout Proof
b) 
\begin_inset Formula $|S_{\hat{q}}|\leq|S_{\hat{q}-1}|$
\end_inset

.
 Similar reasoning yields 
\begin_inset Formula $\hat{q}\leq\frac{p+1}{d}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Actual numbers.
\end_layout

\begin_layout Standard
The size of a diagonal lock-chart in the vanilla framework depends purely
 on two parameters (
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

) and can be easily computed using closed form formulas.
 Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "diagonal-lc-size-table"

\end_inset

 and Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "diagonal-lc-size-figure"

\end_inset

 show the actual numbers obtained by formulas (
\begin_inset CommandInset ref
LatexCommand ref
reference "Sq-size-equation"

\end_inset

 and 
\begin_inset CommandInset ref
LatexCommand ref
reference "qHat-definition-equation"

\end_inset

) in Lemma
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "diagonal-sq-size-lemma"

\end_inset

 and Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "optimalq-theorem"

\end_inset

.
 The 
\begin_inset Formula $\frac{d^{p}}{|S_{\hat{q}}|}$
\end_inset

 ratio in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "diagonal-lc-ratio-table"

\end_inset

 tells how many cuttings in the code space are there per one individual
 key in the largest diagonal lock-chart.
 They might be used a quick reference for comparing different platforms.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways true
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
include{DiagonalMaximum}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Diagonal lock-chart size in vanilla fr.
\end_layout

\end_inset

Exact size of the largest diagonal lock-chart in the vanilla framework.
 Notice how 
\begin_inset Formula $\hat{q}$
\end_inset

 changes between rows 
\begin_inset Formula $p=10$
\end_inset

 and 
\begin_inset Formula $p=11$
\end_inset

.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "diagonal-lc-size-table"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways true
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
include{DiagonalRatio}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Values of the 
\begin_inset Formula $\frac{d^{p}}{|S_{\hat{q}}|}$
\end_inset

 ratio in vanilla fr.
\end_layout

\end_inset

The 
\begin_inset Formula $\frac{d^{p}}{|S_{\hat{q}}|}$
\end_inset

 ratio tells how many cuttings in the code space are there per one individual
 key in the largest diagonal lock-chart.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "diagonal-lc-ratio-table"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{EigenHeatCont.tikz}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Diagonal lock-chart size in vanilla fr.
\end_layout

\end_inset

2D contour plot of the largest diagonal lock-chart size in vanilla framework
 in 
\begin_inset Formula $\log_{10}$
\end_inset

 scale.
 E.g.
 for 
\begin_inset Formula $p=14$
\end_inset

, 
\begin_inset Formula $d_{\mathrm{max}}=3$
\end_inset

, we get 
\begin_inset Formula $|S_{\hat{q}}|=|S_{5}|=1025024\simeq10^{6}$
\end_inset

, which corresponds to the value 
\begin_inset Formula $6$
\end_inset

 in the chart.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "diagonal-lc-size-figure"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Conclusion
\end_layout

\begin_layout Standard
Results of the entire chapter can be summarised as follows: In the general
 framework, all non-trivial lock-chart problems are 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete.
 In the asymmetric framework, the only known fact is a trivial result on
 key-to-differ lock-charts, which are in 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
 In the vanilla framework, melted profiles lock-charts and extension lock-charts
 are 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete, but diagonal and key-to-differ lock-charts are in 
\begin_inset Formula $\mathcal{P}$
\end_inset

.
 The situation in the vanilla framework is visualised in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lc-hierarchy-colour-figure"

\end_inset

.
\end_layout

\begin_layout Standard
Finally, let us conjecture that profiles do not express additional complexity
 over basic lock-charts.
 Consider a key-to-differ profiled lock-chart with a profile-map 
\begin_inset Formula $(P,\preceq)$
\end_inset

 in the vanilla framework with.
 If 
\begin_inset Formula $p=d=1$
\end_inset

, blockings must be ensured by the profile assignment 
\begin_inset Formula $a$
\end_inset

 and therefore lock 
\begin_inset Formula $k_{i}$
\end_inset

 is blocked in 
\begin_inset Formula $l_{j}$
\end_inset

 if and only if 
\begin_inset Formula $a(k_{i})$
\end_inset

 and 
\begin_inset Formula $a(l_{j})$
\end_inset

 are independent.
 Finding the largest set of independent profiles in a profile-map 
\begin_inset Formula $(P,\preceq)$
\end_inset

 corresponds to finding the largest anti-chain in the partial order 
\begin_inset Formula $\preceq$
\end_inset

, which is a problem in the 
\begin_inset Formula $\mathcal{P}$
\end_inset

 class 
\begin_inset CommandInset citation
LatexCommand cite
key "felsner2003"

\end_inset

.
 The interaction between profiles and positions is a good topic for future
 research.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename LockChartHierarchyColored.pdf

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Problem complexity in the vanilla fr.
\end_layout

\end_inset

Lock-chart problem complexity in the vanilla framework.
 
\begin_inset Formula $\mathcal{P}$
\end_inset

 variants are printed green, 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete variants are printed blue.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "lc-hierarchy-colour-figure"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Propositionalization
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "translations-chapter"

\end_inset


\end_layout

\begin_layout Standard
In combinatorial optimisation, there is usually a trade-off between algorithm's
 generality and its performance.
 Given a specific problem, one can improve the runtime by better analysis,
 discovering symmetries in the search-space or by improving data structures
 and their implementation.
 But development takes time.
 Hence a
\begin_inset space ~
\end_inset

“practical approach” to lock-chart solving should start from the other end.
 In this chapter, we try picking a state-of-the-art general solver geared
 towards 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete problems and translating the lock-chart problem into its formalism.
\end_layout

\begin_layout Standard
We called the approach 
\emph on
propositionalization
\emph default
, a term used by 
\begin_inset CommandInset citation
LatexCommand cite
key "lachiche2010"

\end_inset

 to describe a process of rephrasing a problem in a higher-complexity language
 into a lower-complexity one.
 Here lock-charts defined in relational algebra are rewritten into propositional
 logic.
\end_layout

\begin_layout Section
Preliminaries
\end_layout

\begin_layout Standard
This chapter will use notions of SAT, clause, formula and CNF, defined in
 the preliminaries of Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "complexity-chapter"

\end_inset

.
 However, for better readability, we use several concise notations, all
 of which preserve semantic equivalence.
\end_layout

\begin_layout Paragraph
Syntactic sugar for CNF.
\end_layout

\begin_layout Standard
A clause with the first 
\emph on

\begin_inset Formula $i$
\end_inset


\emph default
 literals negative can be written using the implication as 
\begin_inset Formula $(x_{1}\wedge x_{2},\wedge\cdots\wedge x_{i})\Rightarrow(x_{i+1}\vee x_{i+2}\vee\cdots\vee x_{j})$
\end_inset

.
 A clause with at most 1 positive literal is a 
\emph on
Horn clause
\emph default
.
 An equivalence with a disjunction 
\begin_inset Formula $x_{0}\Leftrightarrow(x_{1}\vee x_{2}\vee\cdots\vee x_{n})$
\end_inset

 is rewritten into a CNF with 
\begin_inset Formula $n+1$
\end_inset

 clauses: 
\begin_inset Formula $(x_{0}\Rightarrow(x_{1}\vee x_{2}\vee\cdots\vee x_{n}))\wedge(x_{0}\Leftarrow x_{1})\wedge(x_{0}\Leftarrow x_{2})\wedge\cdots\wedge(x_{0}\Leftarrow x_{n})$
\end_inset

.
 An equivalence with a conjunction 
\begin_inset Formula $x_{0}\Leftrightarrow(x_{1}\wedge x_{2}\wedge\cdots\wedge x_{n})$
\end_inset

 is rewritten into a CNF with 
\begin_inset Formula $n+1$
\end_inset

 clauses: 
\begin_inset Formula $(x_{0}\Rightarrow x_{1})\wedge(x_{0}\Rightarrow x_{2})\wedge\ldots\wedge(x_{0}\Rightarrow x_{n})\wedge(x_{0}\Leftarrow(x_{1}\wedge x_{2}\wedge\cdots\wedge x_{n}))$
\end_inset

.
 To remove most parentheses from the previous definitions, we define the
 
\emph on
operator priority 
\emph default
to parse 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\neg\bar{x}_{1}\vee x_{2}\wedge x_{3}\Rightarrow x_{4}\Leftrightarrow x_{5}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 into 
\begin_inset Formula $((((\text{\neg}(\bar{x}_{1}))\vee x_{2})\wedge x_{3})\Rightarrow x_{4})\Leftrightarrow x_{5}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Convex optimisation.
\end_layout

\begin_layout Standard

\emph on
Linear programming 
\emph default
is the problem of finding an 
\begin_inset Formula $n$
\end_inset

-dimensional vector 
\begin_inset Formula $x=(x_{1},\ldots,x_{n})$
\end_inset

 or rational numbers, which maximizes the dot product 
\begin_inset Formula $c^{\mathrm{T}}x$
\end_inset

 subject to 
\begin_inset Formula $Ax\leq b$
\end_inset

, where 
\begin_inset Formula $c$
\end_inset

 is a vector, 
\begin_inset Formula $A$
\end_inset

 is a 
\begin_inset Formula $n\times m$
\end_inset

 matrix and 
\begin_inset Formula $b$
\end_inset

 an 
\begin_inset Formula $m$
\end_inset

-dimensional vector (the inequality 
\begin_inset Formula $Ax\leq b$
\end_inset

 describes 
\begin_inset Formula $m$
\end_inset

 independent constraints, all of which must be satisfied).
 
\emph on
Integer linear programming
\emph default
 (ILP) is a linear problem, where 
\begin_inset Formula $x_{1},\ldots,x_{n}\in\mathbb{Z}$
\end_inset

.
 
\emph on
Quadratic programming
\emph default
 is the problem of finding an 
\begin_inset Formula $n$
\end_inset

-dimensional vector 
\begin_inset Formula $x=(x_{1},\ldots,x_{n})$
\end_inset

, which minimises 
\begin_inset Formula $\frac{1}{2}x^{\mathrm{T}}Qx+c^{\mathrm{T}}\cdot x$
\end_inset

 subject to 
\begin_inset Formula $Ax\leq b$
\end_inset

, where 
\begin_inset Formula $Q$
\end_inset

 is a 
\begin_inset Formula $n\times n$
\end_inset

 matrix.
 Linear programming is in 
\begin_inset Formula $\mathcal{P}$
\end_inset

, integer linear programming is 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-hard.
\end_layout

\begin_layout Section
Boolean satisfiability
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "sat-sec"

\end_inset


\end_layout

\begin_layout Standard
This section describes a procedure to translate the lock-chart problem in
 the general framework into a CNF, which can be solved by an off-the-shelf
 SAT solver.
\end_layout

\begin_layout Standard
There is a good motivation behind this idea.
 First, the quite large SAT solving community organizes yearly competitions,
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.satcompetition.org
\end_layout

\end_inset


\end_layout

\end_inset

 where SAT solvers are benchmarked on various industrial and synthetic instances.
 Using the final scores, one can quickly pick state-of-the-art algorithms
 from the vast pool of existing libraries.
 Second, there is a widely adopted text format for representing CNFs called
 DIMACS.
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.satcompetition.org/2009/format-benchmarks2009.html
\end_layout

\end_inset


\end_layout

\end_inset

 A simple format shared by most SAT solving libraries allows quick prototyping
 and benchmarking.
\end_layout

\begin_layout Standard
Algorithms for SAT are roughly of two types.
 
\emph on
Local search algorithms
\emph default
 start from a random interpretation (a point in the 
\begin_inset Formula $|X|$
\end_inset

-dimensional space), which might not satisfy the CNF.
 The assignment is gradually improved by flipping variable polarities (searching
 the neighbourhood of the point).
 A
\begin_inset space ~
\end_inset

notable example is the GSAT algorithm 
\begin_inset CommandInset citation
LatexCommand cite
key "selman1992"

\end_inset

, which picks the flipped variable by the number of unsatisfied clauses
 in which it appears.
 The danger of becoming trapped in local minima inspired the WalkSAT algorithm
 
\begin_inset CommandInset citation
LatexCommand cite
key "selman1993"

\end_inset

, which randomly picks an unsatisfied clause and flips one of its variables.
 Since WalkSAT is not guaranteed make the globally best move unlike GSAT,
 the two algorithms can be viewed as instances of hill-climbing and gradient
 descent respectively 
\begin_inset CommandInset citation
LatexCommand cite
key "kautz2004"

\end_inset

.
\end_layout

\begin_layout Standard
The second type of algorithms are descendants of the Davis–Putnam and Davis–Putn
am–Logemann–Loveland 
\begin_inset CommandInset citation
LatexCommand cite
key "davis1960,davis1962"

\end_inset

 algorithms, usually referred as 
\emph on
DPLL-based algorithms
\emph default
.
 They are backtracking algorithms with a 
\emph on
decision
\emph default
 phase and a 
\emph on
unit propagation
\emph default
 phase.
 In the simplest form, decision phase picks a variable and assigns a polarity
 to it.
 Clauses which contain the variable in a positive literal are ignored (until
 a backtrack).
 Negative literals of the assigned variable are removed from all clauses
 (until a backtrack).
 Clauses with exactly 1 unassigned remaining literal are called unitary.
 Unit propagation is a procedure that assigns the truth value of the remaining
 literal, possibly rendering more clauses unitary – a process which resembles
 a chain-reaction.
 If a variable is assigned both 
\begin_inset Formula $0$
\end_inset

 and 
\begin_inset Formula $1$
\end_inset

 during unit propagation, a 
\emph on
conflict
\emph default
 causes the algorithm to backtrack.
 The strength of DPLL algorithms stems from clever data structures, well
 described in a seminal paper on the MiniSat algorithm 
\begin_inset CommandInset citation
LatexCommand cite
key "een2003"

\end_inset

.
 The important message for this text is the polynomial runtime of unit propagati
on.
\end_layout

\begin_layout Standard
Modern DPLL (including MiniSAT) employ some sort of 
\emph on
Conflict-Driven Clause Learning
\emph default
 (CDCL).
 Particular implementations vary, but in general, CDCL algorithms can analyse
 the clauses which caused a conflict, simplify them and generate a 
\emph on
conflict clause
\emph default
.
 The conflict has two effects.
 First, it prunes the search space by allowing the unit propagation to propagate
 variables earlier.
 Second, the backtrack does not have to include a single variable, but more
 of them – a technique known as 
\emph on
backjumping
\emph default
 (or non-chronological backtracking).
 Readers interested in more details of such techniques are once again encouraged
 to read the paper on MiniSat 
\begin_inset CommandInset citation
LatexCommand cite
key "een2003"

\end_inset

.
 Other algorithms that we tried were Glucose 
\begin_inset CommandInset citation
LatexCommand cite
key "audemard2009"

\end_inset

 and CryptoMiniSat 
\begin_inset CommandInset citation
LatexCommand cite
key "cryptominisat"

\end_inset

.
 
\end_layout

\begin_layout Standard
The translation of the lock-chart problem into SAT uses the idea of “grounding”.
 Every cutting depth at every position both in keys and locks will be represente
d by 
\begin_inset Formula $1$
\end_inset

 propositional variable.
 Albeit simple and straightforward, the procedure handles all features from
 Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "chapter-formalization"

\end_inset

: extensions and melted profiles, which imply support for profiled lock-charts.
 Since vanilla and asymmetric frameworks are instances of the general framework,
 the only unsupported framework is the explicit one.
\end_layout

\begin_layout Paragraph
Notation.
\end_layout

\begin_layout Standard
This section will translate arbitrary extension mel\SpecialChar softhyphen
ted-pro\SpecialChar softhyphen
files lock-chart
 
\begin_inset Formula $(K,L,E,B)$
\end_inset

 with a partial solution 
\begin_inset Formula $\hat{s}\cup\hat{t}$
\end_inset

 into a CNF.
 For convenience, variable 
\begin_inset Formula $k$
\end_inset

 will iterate over all keys 
\begin_inset Formula $K$
\end_inset

, 
\begin_inset Formula $l$
\end_inset

 over all locks 
\begin_inset Formula $L$
\end_inset

, 
\begin_inset Formula $i$
\end_inset

 over positions 
\begin_inset Formula $\{1,\ldots,p\}$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

 over all cutting depths 
\begin_inset Formula $\{1,\ldots,d\}$
\end_inset

 if not stated otherwise.
\end_layout

\begin_layout Paragraph
Keys and cuttings.
\end_layout

\begin_layout Standard
Each position in a key must be assigned a cutting depth.
 Hence, for each position, we allocate 
\begin_inset Formula $d$
\end_inset

 propositional variables and enforce only 1 of them to be true in every
 model.
 In coding theory, this is known as “1-of-N code”.
\end_layout

\begin_layout Standard
The variable, which encodes cutting depth 
\begin_inset Formula $j$
\end_inset

 on position 
\begin_inset Formula $i$
\end_inset

 in key 
\begin_inset Formula $k$
\end_inset

, will be denoted 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathsf{key}_{i,j}^{k}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.
 At least one such variable must be true on every position.
 Given 
\begin_inset Formula $k$
\end_inset

 and 
\begin_inset Formula $i$
\end_inset

, the requirement is expressed in the clause
\begin_inset Formula 
\begin{equation}
\mathsf{key}_{i,1}^{k}\vee\mathsf{key}_{i,2}^{k}\vee\cdots\vee\mathsf{key}_{i,d}^{k}\ .\label{at-least-1ofN-equation}
\end{equation}

\end_inset

Also, at most one variable must be true for every key 
\begin_inset Formula $k$
\end_inset

 and position 
\begin_inset Formula $i$
\end_inset

.
 A clause for every two distinct cutting depths 
\begin_inset Formula $j$
\end_inset

 and 
\begin_inset Formula $j'$
\end_inset

 forbids any two cutting depths to be active at the same time:
\begin_inset Formula 
\begin{equation}
\mathsf{key}_{i,j}^{k}\Rightarrow\overline{\mathsf{key}}_{i,j'}^{k}\label{at-most-1ofN-equation}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
In total there are 
\begin_inset Formula $|K|\cdot p\cdot d$
\end_inset

 variables and 
\begin_inset Formula $|K|\cdot p\cdot\left(1+\frac{d\cdot(d-1)}{2}\right)$
\end_inset

 clauses.
\begin_inset Foot
status open

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Notice that 
\begin_inset Formula $\mathsf{key}_{i,j}^{k}\Rightarrow\overline{\mathsf{key}}_{i,j'}^{k}$
\end_inset

 and 
\begin_inset Formula $\mathsf{key}_{i,j'}^{k}\Rightarrow\overline{\mathsf{key}}_{i,j}^{k}$
\end_inset

 are two identical clauses.
 This explains the 
\begin_inset Formula $\frac{1}{2}$
\end_inset

 term.
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Locks and cylinders.
\end_layout

\begin_layout Standard
A cylinder is encoded using the same idea as a key.
 We assign 
\begin_inset Formula $p\cdot d$
\end_inset

 propositional variables denoted as 
\begin_inset Formula $\mathsf{lock}_{i,j}^{l}$
\end_inset

.
 However, in this case, the 1-of-N constraints are not needed, because a
 cylinder can have an arbitrary number of cutting depths in each position.
 This gives 
\begin_inset Formula $|L|\cdot p\cdot d$
\end_inset

 variables and no clause.
\end_layout

\begin_layout Paragraph
Opening.
\end_layout

\begin_layout Standard
If a key 
\begin_inset Formula $k$
\end_inset

 enters lock 
\begin_inset Formula $l$
\end_inset

, then its cutting must be among the shear-lines of the cylinder.
 We do so by including clauses
\end_layout

\begin_layout Standard
\begin_inset Formula 
\begin{equation}
\mathsf{key}_{i,j}^{k}\Rightarrow\mathsf{lock}_{i,j}^{l}\label{opening-impl-equation}
\end{equation}

\end_inset

for each position and cutting depth.
 This generates 
\begin_inset Formula $p\cdot d\cdot|E|$
\end_inset

 clauses.
\end_layout

\begin_layout Standard
There is one brawback of this formula.
 The implications allow models to add pins into locks even if no key needs
 it, which violates Proposition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "least-cut-prop"

\end_inset

.
 As a counter-measure, we can replace the implication by an equivalence
\begin_inset Formula 
\begin{equation}
\left(\bigvee_{k\in E(l)}\mathsf{key}_{i,j}^{k}\right)\Leftrightarrow\mathsf{lock}_{i,j}^{l}\ .\label{opening-equi-equation}
\end{equation}

\end_inset

for each position and cutting depth, which generates 
\begin_inset Formula $p\cdot d\cdot(|E|+|L|)$
\end_inset

 clauses.
 Also note that the expansion of the equivalence (
\begin_inset CommandInset ref
LatexCommand ref
reference "opening-equi-equation"

\end_inset

) into a CNF will generate the implications (
\begin_inset CommandInset ref
LatexCommand ref
reference "opening-impl-equation"

\end_inset

).
 
\end_layout

\begin_layout Standard
However, any difference in SAT solvers' performance must be tested empirically.
 The equivalence generates a smaller search-space, because the 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathsf{lock}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 variables are fully determined by the 
\begin_inset Formula $\mathsf{key}$
\end_inset

 variables.
 On the other hand, the additional clauses might clog data structures of
 a solver's engine and slow down its inference.
\end_layout

\begin_layout Paragraph
Blocking.
\end_layout

\begin_layout Standard
Supppose a key 
\begin_inset Formula $k$
\end_inset

 is blocked in lock 
\begin_inset Formula $l$
\end_inset

.
 Then there must be 
\begin_inset Formula $1$
\end_inset

 position, where the cutting depth of the key is blocked by a missing pin
 in the lock.
 First, we define auxiliary variables that detect the blocking
\begin_inset Formula 
\begin{equation}
\mathsf{key}_{i,j}^{k}\wedge\overline{\mathsf{lock}}_{i,j}^{l}\text{\Rightarrow}\mathsf{block}_{i,j}^{k,l}\label{block-var-definition-equation}
\end{equation}

\end_inset

for each position, cutting depth, lock and a stopped key.
 The key' cutting is blocked if at least one blocking variable is true
\begin_inset Formula 
\begin{equation}
\bigvee_{i,j}\mathsf{block}_{i,j}^{k,l}\label{block-var-clause-equation}
\end{equation}

\end_inset

which gives 
\begin_inset Formula $(pd+1)\cdot|B|$
\end_inset

 clauses and 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $pd\cdot|B|$
\end_inset

 variables.
\end_layout

\begin_layout Standard
Note that the auxiliary blocking variables appear a positive literal in
 both types of clauses.
 Therefore they cannot be removed by resolution, which is a common pre-processin
g step in SAT solving.
 
\end_layout

\begin_layout Standard
Similarly to the previous case, it is possible to replace the implications
 in (
\begin_inset CommandInset ref
LatexCommand ref
reference "block-var-definition-equation"

\end_inset

) by equivalences.
\end_layout

\begin_layout Paragraph
Partial solution.
\end_layout

\begin_layout Standard
Extension lock-chart's solution must satisfy the partial solution 
\begin_inset Formula $\hat{s}\cup\hat{t}$
\end_inset

: In every solution, keys' cuttings and lock's cylinders must remain the
 same as in 
\begin_inset Formula $\hat{s}\cup\hat{t}$
\end_inset

.
 This is achieved by adding unitary clauses 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathtt{\mathsf{lock}}_{i,j}^{l}$
\end_inset

 if 
\begin_inset Formula $\hat{t}(l)_{i}=j$
\end_inset

 and its negation 
\begin_inset Formula $\overline{\mathsf{lock}}_{i,j}^{l}$
\end_inset

 otherwise.
 The same idea applies to keys, even though the negative literals may be
 implied by unit propagation in DPLL algorithms.
 To see this, 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
notice that a unitary clause 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathsf{key}_{i,j}^{k}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 renders left side of the implication 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
(
\begin_inset CommandInset ref
LatexCommand ref
reference "at-most-1ofN-equation"

\end_inset

) true and hence the right side 
\begin_inset Formula $\overline{\mathsf{key}}_{i,j'}^{k}$
\end_inset

 must be also true for all 
\begin_inset Formula $j'\not=j$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.
\end_layout

\begin_layout Standard
The DPLL algorithms have a great advantage here.
 Since unit propagation affects all clauses in the CNF, the solver only
 deals with variables, literals and clauses not determined by the partial
 solution 
\begin_inset Formula $\hat{s}$
\end_inset

.
 In other words, the complexity of solving the generated CNF correlates
 with the number of unassigned keys, not the number of all keys.
 Consequently, DPLL solvers are very strong at finding small extensions
 of arbitrarily large lock-charts, which can be confirmed from our experience.
\end_layout

\begin_layout Standard
Including the redundant literals, there are 
\begin_inset Formula $p\cdot d\cdot|\hat{s}|$
\end_inset

 generated unit clauses.
\end_layout

\begin_layout Paragraph
Constraints.
\end_layout

\begin_layout Standard
This straightforward translation is well suited for incorporating mechanical
 constraints.
 One gecon translates to one clause for each key.
 Let 
\begin_inset Formula $(c_{1},\ldots,c_{p})$
\end_inset

 be a gecon with 
\begin_inset Formula $p-r$
\end_inset

 wildcards and 
\begin_inset Formula $i_{1},\ldots,i_{r}$
\end_inset

 be positions, where the gecon has non-wildcard values.
 The clause
\begin_inset Formula 
\begin{equation}
\overline{\mathsf{key}}_{i_{1},c_{i_{1}}}^{k}\vee\overline{\mathsf{key}}_{i_{2},c_{i_{2}}}^{k}\vee\cdots\vee\overline{\mathsf{key}}_{i_{r},c_{i_{r}}}^{k}\label{gecon2sat-equation}
\end{equation}

\end_inset

ensures that the cutting differs from the gecon on at least 1 non-wildcard
 position.
 This exactly follows the definition of gecons.
\end_layout

\begin_layout Standard
Since the asymmetric framework is a special case of the general framework,
 asymmetric constraints are covered by this approach as well.
 See the last paragraphs of Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "constraints-definition-section"

\end_inset

 for details.
 Given that the gecons (
\begin_inset CommandInset ref
LatexCommand ref
reference "asym2gen-eq"

\end_inset

) translate to a unitary clause, they take advantage of unitary propagation.
\end_layout

\begin_layout Standard
The problem with adapting the explicit framework into the general one and
 the need for an exponential translation procedure is described in the same
 place.
\end_layout

\begin_layout Definition
Assume a general framework and let 
\begin_inset Formula $(K,L,E,B)$
\end_inset

 be a melted profiles lock-chart and 
\begin_inset Formula $\hat{s}$
\end_inset

 its partial solution.
 The CNF which composes of all clauses (
\begin_inset CommandInset ref
LatexCommand ref
reference "at-least-1ofN-equation"

\end_inset

)-(
\begin_inset CommandInset ref
LatexCommand ref
reference "gecon2sat-equation"

\end_inset

) is called the lock-chart's 
\emph on
straightforward translation
\emph default
.
\end_layout

\begin_layout Proposition
The straightforward translation is satisfiable if and only if the translated
 lock-chart has a solution.
\end_layout

\begin_layout Standard
This proposition is left without a formal proof.
 There is a 1:1 correspondence between every definition of the lock-chart
 problem and a clause in the straightforward translation; hence a proof
 would provide no additional insight.
\end_layout

\begin_layout Standard
Given this proposition and a model to the CNF, one can easily recreate a
 solution to the original lock-chart.
 For every key and position 
\begin_inset Formula $s(k)_{i}=j$
\end_inset

 if and only if 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathcal{I}\left(\mathsf{key}_{i,j}^{k}\right)=1$
\end_inset

.
\end_layout

\begin_layout Paragraph
Summary.
\end_layout

\begin_layout Standard
Table 
\begin_inset CommandInset ref
LatexCommand ref
reference "sat-summary-table"

\end_inset

 contains the size of the CNF generated by the straightforward translation.
 Since real-world lock-charts (for example diagonal lock-charts) have 
\begin_inset Formula $|B|\sim|K|\cdot|L|$
\end_inset

, we can see that the blocking clauses and variables dominate all other
 types.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="5">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Variables
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\series bold
Clauses
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Allocated
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Rightarrow$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\Leftrightarrow$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
keys
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{key}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $pd\cdot|K|$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $p\cdot\left(1+\frac{d\cdot(d-1)}{2}\right)\cdot|K|$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
locks
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{lock}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $pd\cdot|L|$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
enterings
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $pd\cdot|E|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $pd\cdot(|E|+|L|)$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
blockings
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\mathsf{block}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $pd\cdot|B|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $(pd+1)\text{\cdot}|B|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset Formula $(3pd+1)\text{\cdot}|B|$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
constraints
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\text{number of gecons}\cdot|K|$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
extension
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multicolumn="1" alignment="center" valignment="top" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $pd\cdot|\hat{s}|$
\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Size of the straightforward translation
\end_layout

\end_inset

Size of the straightforward translation.
 The number of clauses is given for both implication and equivalence models.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sat-summary-table"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Evaluation.
\end_layout

\begin_layout Standard
Before the SAT translation algorithm shows its strengths, which comes no
 earlier than in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "backtrackers-chapter"

\end_inset

, I would like to discuss its limitations.
 The theoretical limits have been described in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "complexity-chapter"

\end_inset

, but what about the practical ones?
\end_layout

\begin_layout Standard
As the simplest benchmark, we picked vanilla diagonal lock-charts, because
 such a benchmark only depends on 3 parameters – 
\begin_inset Formula $p$
\end_inset

, 
\begin_inset Formula $d$
\end_inset

 and the number of individual keys.
 All results can be summarised in a single table.
\end_layout

\begin_layout Standard
Implementation-wise, we used a C++ binary API instead of exporting the CNFs
 to the DIMACS format.
 The API allows incremental solving, which was used for adding keys and
 locks one by one, until a the entire lock-chart was solved, the 1
\begin_inset space ~
\end_inset

hour timeout occurred or an out-of-memory error was raised.
\end_layout

\begin_layout Standard
One may question such benchmark on the grounds of “torturing” a SAT solver
 on a polynomial instance.
 Indeed, if the SAT solver could somehow discover the solution, which was
 proved optimal in Theorems
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "thm:lower-bound"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "thm:upper-bound"

\end_inset

, such a benchmark would certainly be meaningless.
\end_layout

\begin_layout Standard
We still believe that such a benchmark is a reasonable estimate of SAT solvers'
 performance on real-world lock-charts with many constraints.
 SAT solvers rarely attempt at analyzing its input or discovering symmetries
 in the search-space.
 They are designed and tuned for solving 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-hard problems, largely relying on their brute-force performance.
\end_layout

\begin_layout Standard
Tables
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sat-diag-abs-table"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sat-diag-rel-table"

\end_inset

 show the results.
 They were obtained by using the MiniSat library on an Intel Core i5 CPU
 running at 2.70
\begin_inset space ~
\end_inset

GHz with 16
\begin_inset space ~
\end_inset

GiB RAM.
 The CNFs were obtained using the implication model both for 
\begin_inset Formula $\mathsf{lock}$
\end_inset

 and 
\begin_inset Formula $\mathsf{block}$
\end_inset

 variables.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
 During internal testing, we found out that MiniSat beats Glucose and CryptoMini
Sat and that the implication model beats equivalence mode.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Until the diagonal lock-chart has 700 individual keys or less, the solver
 is very likely to find a solution.
 Apparently the solver's performance peaks at around 1700 keys.
 With increasing 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

, it fails to exploit the larger code space and even the absolute numbers
 tend to decrease.
\end_layout

\begin_layout Standard
The main reason for dwindling performance in large code spaces is memory
 depletion.
 Most instances, which did not achieve 100% score, ended up on an out-of-memory
 error.
 This can be attributed to the fact that DPLL-based algorithms rely on many
 clever data structures.
 For example, every variable is associated with a list of clauses, in which
 it appears 
\begin_inset CommandInset citation
LatexCommand cite
key "een2003"

\end_inset

 to speed up propagation.
 Since all relevant formulas in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sat-summary-table"

\end_inset

 have the 
\begin_inset Formula $pd$
\end_inset

 factor and 
\begin_inset Formula $|B|$
\end_inset

 scales quadratically with 
\begin_inset Formula $|K|$
\end_inset

, MiniSat runs out of memory faster with larger code space.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways true
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
include{SatDiagAbs}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
MiniSat absolute performance
\end_layout

\end_inset

Number of individual keys in a vanilla diagonal lock-chart, which were found
 by the MiniSat algorithm.
 Values in italics correspond to runs, which ended by a timeout or by an
 out-of-memory error.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sat-diag-abs-table"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways true
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
include{SatDiagRel}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
MiniSat relative performance
\end_layout

\end_inset

Percentage of individual keys solved in a vanilla diagonal lock-chart by
 MiniSat.
 Value 100% means all invidiual keys in the largest solvable lock-chart
 
\begin_inset Formula $|S_{\hat{q}}|$
\end_inset

.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sat-diag-rel-table"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Integer linear programming
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "ilp-sec"

\end_inset


\end_layout

\begin_layout Standard
Beside SAT solvers there are ILP solvers, which are also employed in hard
 combinatorial tasks.
 This section summarises our reasoning about writing a similar translation
 procedure from the lock-chart problem to ILP.
\end_layout

\begin_layout Question
Can ILP solvers perform better than SAT solvers at solving the lock-chart
 problem?
\end_layout

\begin_layout Standard
Because 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-hard solving algorithms are tricky to compare, a definitive answer needs
 an experimental evaluation.
 Nevertheless, we decided to skip it in order to focus on domain-specific
 algorithms.
 Still, we think there are good reasons to believe ILP solvers stand a good
 chance.
\end_layout

\begin_layout Standard
First, there is a pragmatic argument.
 Libraries such as CPLEX
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "cplex"

\end_inset

 or Gurobi
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "gurobi"

\end_inset

 are big commercial endeavours.
 Merely judging from the code-base size (current binaries take up between
 
\begin_inset Formula $25\,\text{MB}$
\end_inset

 and 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $100\,\text{MB}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 of disk space) and commercial price (Gurobi license costs between 
\begin_inset Formula $\$\,14\,000$
\end_inset

 and 
\begin_inset Formula $\$\,56\,000$
\end_inset

),
\begin_inset Foot
status open

\begin_layout Plain Layout
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.gurobi.com/products/licensing-pricing/commercial-pricing
\end_layout

\end_inset


\end_layout

\end_inset

 these libraries have been invested a lot of endeavour.
\end_layout

\begin_layout Standard
Second, the CNF obtained by the translation procedure from the previous
 section can be translated once again into a binary ILP instance easily.
 Assume that for every propositional variable in the CNF, there is one binary
 (
\begin_inset Formula $0\leq x\leq1$
\end_inset

) integer variable in the ILP instance.
 A clause
\begin_inset Formula 
\begin{equation}
C=\bar{x}_{1}\vee\bar{x}_{2}\vee\cdots\vee\bar{x}_{i}\vee x_{i+1}\vee x_{i+2}\vee\cdots\vee x_{j}
\end{equation}

\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
is satisfied under an interpretation 
\begin_inset Formula $\mathcal{I}$
\end_inset

 if 
\begin_inset Formula $\mathcal{I}(C)=1$
\end_inset

.
 This condition is implied by an ILP constraint
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula 
\begin{equation}
(1-x_{1})+(1-x_{2})+\cdots+(1-x_{i})+x_{i+1}+x_{i+2}+\cdots+x_{j}\geq1\ \text{.}
\end{equation}

\end_inset

This “retranslation” of the lock-chart problem might not be the most efficient
 encoding, but is certainly an easy start given that the procedure for generatin
g CNF is implemented.
\end_layout

\begin_layout Paragraph
Initial solution.
\end_layout

\begin_layout Standard
Next, consider a common technique to attack ILP problems: First, the “integer”
 constraint is relaxed, all variables are considered real, which gives an
 
\emph on
LP relaxation
\emph default
.
 Unlike the original problem, the relaxation is in 
\begin_inset Formula $\mathcal{P}$
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "khachiyan1979"

\end_inset

 and can be solved by many existing algorithms quickly.
 Given a solution to the relaxation, ILP solver starts the backtracking
 procedure by rounding off the variables.
\end_layout

\begin_layout Standard
Given a good optimisation criterion, the LP relaxation can bring the backtrackin
g part close to an integer solution, which might reduce the algorithm's
 runtime.
 At least for diagonal lock-charts, that clog MiniSAT, a good criterion
 respects the “equal to the general key” value 
\begin_inset Formula $q$
\end_inset

 from Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "diagonal-lc-complexity-section"

\end_inset

.
\end_layout

\begin_layout Standard
Assume that the general key is 
\begin_inset Formula $g$
\end_inset

 and take any other key 
\begin_inset Formula $k$
\end_inset

.
 If the cuttings of the two keys differ on position 
\begin_inset Formula $i$
\end_inset

, then
\begin_inset Formula 
\begin{equation}
\sum_{j=1}^{d}\left|\mathsf{key}_{i,j}^{g}-\mathsf{key}_{i,j}^{k}\right|=2
\end{equation}

\end_inset

Then by summing over all positions and all keys and rephrasing the constriant
 as an optimisation criterion, the 
\begin_inset Formula $c$
\end_inset

 vector can be formed to minimise 
\begin_inset Formula 
\begin{equation}
\left|\left(\sum_{k\in K\setminus\{g\}}\sum_{i=1}^{p}\sum_{j=1}^{d}\left|\mathsf{key}_{i,j}^{g}-\mathsf{key}_{i,j}^{k}\right|\right)-2\cdot q\cdot|K|\right|
\end{equation}

\end_inset

This criterion is becomes linear by replacing every absolute value by auxiliary
 variables 
\begin_inset CommandInset citation
LatexCommand cite
key "boyd2004"

\end_inset

.
 The absolute values will generate 
\begin_inset Formula $pd\cdot|K|$
\end_inset

 auxiliary variables, which is still linear in the number of keys.
\end_layout

\begin_layout Paragraph
Compression.
\end_layout

\begin_layout Standard
Finally, the blocking constraints, which are behind MiniSat's high memory
 consumption, can be encoded more efficiently.
 To ensure a blocking on at least 1 position, the following constraint can
 be formulated:
\begin_inset Formula 
\begin{equation}
\sum_{i,j}\mathsf{key}_{i,j}^{k}\cdot(1-\mathsf{lock}{}_{i,j}^{l})\geq1
\end{equation}

\end_inset

The constraint is quadratic, which calls for quadratic programming.
 If for whatever reason, quadratic programming was undesirable, every binary
 quadratic integer program can be translated into a binary ILP 
\begin_inset CommandInset citation
LatexCommand cite
key "bliek2014"

\end_inset

.
\end_layout

\begin_layout Chapter
Cutting counting
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "count-chap"

\end_inset


\end_layout

\begin_layout Standard
The cutting counting problem occurs when new mechanical platforms are created.
 While fiddling with the physical layout of cuttings and cylinders, the
 number of positions, cutting depths and mechanical constraints, engineers
 need to know how their design choices affect master-keyed systems.
 An algorithm for counting key cuttings does exactly that.
\end_layout

\begin_layout Standard
The counting problems are also related to some theoretical questions, because
 several problems in lock-chart solving reduce to counting problems.
 For example, finding a solution to a key-to-differ lock-chart is as hard
 counting solutions to a 
\begin_inset Formula $1\times0$
\end_inset

 lock-chart (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sat-correspondence-section"

\end_inset

).
 Out of many similar questions, by 
\emph on
cutting counting
\emph default
, we specifically mean the following question:
\end_layout

\begin_layout Question
How to calculate the size of the code space 
\begin_inset Formula $|S|$
\end_inset

 or the size of the largest solvable diagonal-lock chart?
\end_layout

\begin_layout Standard
The first major result on cutting counting is the formula (
\begin_inset CommandInset ref
LatexCommand ref
reference "Sq-size-equation"

\end_inset

) in the vanilla framework, which gives the size of largest solvable diagonal
 lock-chart as 
\begin_inset Formula $|S_{\hat{q}}|$
\end_inset

.
 Besides that, the simple formula 
\begin_inset Formula $|S|=d^{p}$
\end_inset

 can also be considered as a trivial result on count cutting.
 This chapter extends such results to the remaining constraint frameworks.
\end_layout

\begin_layout Section
Asymmetric framework
\end_layout

\begin_layout Definition
Let 
\begin_inset Formula $(\tilde{d}_{1},\ldots,\tilde{d}_{p})$
\end_inset

 be the deepest cutting.
 The function 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Gamma:\left\{ 0,\ldots,p\right\} \times T\times T\rightarrow\mathbb{W}$
\end_inset

, denoted 
\begin_inset Formula $\Gamma(q,E,B)$
\end_inset

, counts the number of cuttings, which have exactly 
\begin_inset Formula $q$
\end_inset

 cutting depths present in the cylinder 
\begin_inset Formula $E$
\end_inset

 (on respective positions) and which are blocked in the cylinder 
\begin_inset Formula $B$
\end_inset

.
 Formally 
\begin_inset Formula 
\begin{equation}
\Gamma(q,E,B)=\left\{ \gamma\in S\ \middle|\ B\text{ blocks }\gamma\text{ and }q=q_{\gamma}^{E}\right\} \text{, where}
\end{equation}

\end_inset


\begin_inset Formula 
\begin{equation}
q_{\gamma}^{E}=\sum_{1\leq i\leq p}\begin{cases}
1 & \text{if }\gamma_{i}\in E_{i}\\
0 & \text{if }\gamma_{i}\not\in E_{i}
\end{cases}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
This function has many applications.
 For a start, it answers the cutting counting question in the asymmetric
 framework:
\end_layout

\begin_layout Enumerate

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Let 
\begin_inset Formula $q=0$
\end_inset

 and 
\begin_inset Formula $E=B=\overbrace{(\emptyset,\ldots,\emptyset)}^{p\text{ times}}$
\end_inset

, which will be written concisely as 
\begin_inset Formula $E=B=\emptyset$
\end_inset

 in this chapter.
 Then every cutting 
\begin_inset Formula $\gamma$
\end_inset

 is blocked in 
\begin_inset Formula $B$
\end_inset

 and 
\begin_inset Formula $q_{\gamma}^{E}=0=q$
\end_inset

.
 Therefore every cutting satisfies the conditions and 
\begin_inset Formula $\Gamma$
\end_inset

 function calculates the size of the code space 
\begin_inset Formula $|S|$
\end_inset

: 
\begin_inset Formula 
\begin{equation}
\Gamma(0,\emptyset,\emptyset)=\tilde{d}_{1}\cdot\tilde{d}_{2}\cdot\ldots\cdot\tilde{d}_{p}=|S|\ .
\end{equation}

\end_inset

In the vanilla framework, all cutting depths of the deepest cutting 
\begin_inset Formula $\tilde{d}$
\end_inset

 are equal, and hence 
\begin_inset Formula $\Theta(p,0,\emptyset,\emptyset)=d^{p}=|S|$
\end_inset

.
\end_layout

\begin_layout Enumerate
By definition, value 
\begin_inset Formula $\Gamma(q,(\overbrace{\{1\},\ldots,\{1\}}^{p\text{ times}}),\emptyset)$
\end_inset

 is the number of cuttings equal to any general key
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
In the asymmetric framework, the size 
\begin_inset Formula $|S_{q}|$
\end_inset

 is constant regardless of the general key's cutting.
 The reasoning is similar to the proof of Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "diagonal-sq-size-lemma"

\end_inset

.
\end_layout

\end_inset

 on exactly 
\begin_inset Formula $q$
\end_inset

 positions, a number known as 
\begin_inset Formula $|S_{q}|$
\end_inset

.
 By Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "thm:lower-bound"

\end_inset

, which holds in all frameworks, the value 
\begin_inset Formula $\max_{q}|S_{q}|$
\end_inset

 is the lower bound on the size of the largest solvable diagonal lock-chart.
 In the vanilla framework, the Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "thm:upper-bound"

\end_inset

 holds and hence the bound is tight.
\end_layout

\begin_layout Standard
Through this section, we will be finding a faster way to evaluate the 
\begin_inset Formula $\Gamma$
\end_inset

 function.
 First, a recurrence relation is formulated, which avoids a brute-force
 iteration over all 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
cuttings 
\begin_inset Formula $\gamma\in S$
\end_inset

.
 Its evaluation will reduce the number of operations from the order of 
\begin_inset Formula $d^{p}$
\end_inset

 to 
\begin_inset Formula $4^{p}$
\end_inset

.
\end_layout

\begin_layout Lemma
The 
\begin_inset Formula $\Gamma(q,E,B)$
\end_inset

 function is equal to 
\begin_inset Formula $\Theta(p,q,E,B)$
\end_inset

, where
\end_layout

\begin_layout Lemma
\begin_inset Formula 
\begin{equation}
\Theta(i,q,E,B)=\begin{cases}
0 & \text{if }q<0\text{ or }i<q\\
|E_{1}\setminus B_{1}| & \text{if }i=1\text{ and }q=1\\
\tilde{d}_{1}-|E_{1}\cup B_{1}| & \text{if }i=1\text{ and }q=0\\
\theta(i,q,E,B) & \text{otherwise}
\end{cases}\label{big-theta-equation}
\end{equation}

\end_inset


\end_layout

\begin_layout Lemma
\begin_inset Formula 
\begin{equation}
\begin{aligned}\theta(i,q,E,B)=|B_{i}\setminus E_{i}| & \cdot\,\Theta(i-1,q,E,B)\,+ & \text{(case 1)}\\
+\,|B_{i}\cap E_{i}| & \cdot\,\Theta(i-1,q-1,E,B)\,+ & \text{(case 2)}\\
+\,|E_{i}\setminus B_{i}| & \cdot\,\Theta(i-1,q-1,E,\emptyset)\,+ & \text{(case 3)}\\
+\,(\tilde{d}_{i}-|E_{i}\cup B_{i}|) & \cdot\,\Theta(i-1,q,E,\emptyset) & \text{(case 4)}
\end{aligned}
\label{small-theta-equation}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The terminating condition is defined in the formula (
\begin_inset CommandInset ref
LatexCommand ref
reference "big-theta-equation"

\end_inset

) and the recursion in (
\begin_inset CommandInset ref
LatexCommand ref
reference "small-theta-equation"

\end_inset

).
 Note that the 
\begin_inset Formula $\theta$
\end_inset

 function is merely a substitution for better typography on a narrow page
 layout.
\end_layout

\begin_layout Standard
Before a general proof, we feel obliged to do a “sanity check”.
\end_layout

\begin_layout Example

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset CommandInset label
LatexCommand label
name "theta-example"

\end_inset

Let 
\begin_inset Formula $p=3$
\end_inset

, 
\begin_inset Formula $d=2$
\end_inset

 (deepest cutting is 
\begin_inset Formula $(2,2,2)$
\end_inset

 in the asymmetric framework), 
\begin_inset Formula $q=2$
\end_inset

, 
\begin_inset Formula $E=(\{1\},\{1\},\{1\})$
\end_inset

 and 
\begin_inset Formula $B=(\{1,2\},\{1\},\{2\})$
\end_inset

.
 The expected value of 
\begin_inset Formula $\Theta(p,q,E,B)$
\end_inset

 is 
\begin_inset Formula $2$
\end_inset

, because only cuttings 
\begin_inset Formula $(1,1,2)$
\end_inset

, 
\begin_inset Formula $(1,2,1)$
\end_inset

 and 
\begin_inset Formula $(2,1,1)$
\end_inset

 have 
\begin_inset Formula $q=2$
\end_inset

 cuttings depths within 
\begin_inset Formula $E$
\end_inset

, but 
\begin_inset Formula $1$
\end_inset

 of them enters 
\begin_inset Formula $B$
\end_inset

, namely 
\begin_inset Formula $(1,1,2)$
\end_inset

.
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula 
\begin{multline*}
\Theta(3,2,E,B)=\overbrace{1\cdot\Theta(2,2,E,B)}^{\text{by case 1}}+\overbrace{1\cdot\Theta(2,1,E,\emptyset)}^{\text{by case 3}}=\\
=\left(\overbrace{1\cdot\Theta(1,1,E,B)}^{\text{by case 2}}+\overbrace{1\cdot\Theta(1,2,E,\emptyset)}^{\text{by case 4}}\right)+\\
+\left(\overbrace{1\cdot\Theta(1,0,E,\emptyset)}^{\text{by case 3}}+\overbrace{1\cdot\Theta(1,1,E,\emptyset)}^{\text{by case 4}}\right)=
\end{multline*}

\end_inset


\begin_inset Formula 
\[
=\left(\overbrace{|\{1\}\setminus\{1,2\}|}^{\text{by }i=q=1}+\overbrace{0}^{\text{by }i<q}\right)+\left(\overbrace{2-|\{1\}\cup\emptyset|}^{\text{by }i=1\text{ and }q=0}+\overbrace{|\{1\}\setminus\emptyset|}^{\textrm{by }i=q=1}\right)=2
\]

\end_inset


\end_layout

\begin_layout Standard
A second “sanity check” is done by checking two special cases in the vanilla
 framework:
\end_layout

\begin_layout Enumerate

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
The code space size 
\begin_inset Formula $|S|$
\end_inset

 is given by 
\begin_inset Formula $\Theta(p,0,\emptyset,\emptyset)$
\end_inset

.
 This follows from 
\begin_inset Formula $E_{i}=B_{i}=\emptyset$
\end_inset

, which makes the factors in cases 1 to 3 evaluate to 
\begin_inset Formula $0$
\end_inset

.
 Case
\begin_inset space ~
\end_inset

4 multiplies 
\begin_inset Formula $\tilde{d}_{i}-|E_{i}\cup B_{i}|=d$
\end_inset

 exactly 
\begin_inset Formula $p-1$
\end_inset

 times and the terminating condition adds the last 
\begin_inset Formula $d^{\text{th}}$
\end_inset

 factor.
 Therefore 
\begin_inset Formula $\Theta(p,0,\emptyset,\emptyset)=d^{p}$
\end_inset

.
\end_layout

\begin_layout Enumerate

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
When deriving 
\begin_inset Formula $|S_{q}|=\Theta(p,q,(\{1\},\ldots,\{1\}),\emptyset)$
\end_inset

, cases 1 and 2 do not apply, because 
\begin_inset Formula $B_{i}=\emptyset$
\end_inset

.
 First note that the 
\begin_inset Formula $\Theta$
\end_inset

 function is a sum of products.
 Every call sequence picks 
\begin_inset Formula $p-1$
\end_inset

 times either case 3 or 4, arrives at some terminating condition and yields
 one product to the sum.
 If we were to arrive at the terminating condition 
\begin_inset Formula $q=1$
\end_inset

, case 3 must be picked exactly 
\begin_inset Formula $q-1$
\end_inset

 times.
 Hence the 
\begin_inset Formula $|\tilde{d}_{i}-\{1\}|=d-1$
\end_inset

 value is multiplied in the remaining 
\begin_inset Formula $p-q$
\end_inset

 invocations of case
\begin_inset space ~
\end_inset

4.
 This gives the 
\begin_inset Formula $(d-1)^{p-q}$
\end_inset

 factor, which is obtained 
\begin_inset Formula $\binom{p-1}{q-1}$
\end_inset

-many times.
 If we were to arrive at the terminating condition 
\begin_inset Formula $q=0$
\end_inset

, a similar reasoning gives the same factor 
\begin_inset Formula $\binom{p-1}{q}$
\end_inset

-many times.
 The sum of these two factors gives formula (
\begin_inset CommandInset ref
LatexCommand ref
reference "Sq-size-equation"

\end_inset

), because
\begin_inset Formula 
\[
\left[\binom{p-1}{q-1}+\binom{p-1}{q}\right]\cdot(d-1)^{p-q}=\binom{p}{p-q}\cdot(d-1)^{p-q}\ .
\]

\end_inset


\end_layout

\begin_layout Proof
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Proof of the lemma.
\end_layout

\end_inset

The first parameter 
\begin_inset Formula $i$
\end_inset

 iterates over all positions and lets the function “restrict all reasoning”
 only to positions 
\begin_inset Formula $\{1,\ldots,i\}$
\end_inset

 and ignore the remaining positions 
\begin_inset Formula $\{i+1,\ldots,p\}$
\end_inset

.
 Every recursive step “extends” the reasoning to cuttings one position longer.
 The proof is done by induction on 
\begin_inset Formula $i$
\end_inset

.
\end_layout

\begin_layout Proof
The base case assumes 
\begin_inset Formula $i=1$
\end_inset

: The 
\begin_inset Formula $\theta$
\end_inset

 function is never invoked.
 Hence only the first 3 lines of (
\begin_inset CommandInset ref
LatexCommand ref
reference "big-theta-equation"

\end_inset

) are proved.
 There is only 1 position to block a cutting, hence cutting depths 
\begin_inset Formula $B_{1}$
\end_inset

 are never counted.
 The second and third line count remaining depths either inside (resp.
 outside) 
\begin_inset Formula $E_{i}$
\end_inset

 when 
\begin_inset Formula $q=1$
\end_inset

 (resp.
 
\begin_inset Formula $q=0$
\end_inset

).
\end_layout

\begin_layout Proof
The inductive step proves correctness of 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Theta(i,q,E,B)=\theta(i,q,E,B)$
\end_inset

 in (
\begin_inset CommandInset ref
LatexCommand ref
reference "small-theta-equation"

\end_inset

) by assuming 
\begin_inset Formula $\Theta(i-1,q,E,B)$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 is correct.
 First note the partitioning of cutting depths.
 Every cutting depth on the 
\begin_inset Formula $i$
\end_inset

-th position is either in 
\begin_inset Formula $E_{i}\cap B_{i}$
\end_inset

, in 
\begin_inset Formula $E_{i}\setminus B_{i}$
\end_inset

, in 
\begin_inset Formula $B_{i}\setminus E_{i}$
\end_inset

 or outside both sets, of which there are 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\tilde{d}_{i}-|E_{i}\cup B_{i}|$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 many ones.
 Sizes of these sets are multiplicative factors in cases 1 to 4.
 This ensures that no cutting is counted twice.
\end_layout

\begin_layout Proof
Next, take any cutting 
\begin_inset Formula $\gamma$
\end_inset

 which matches 
\begin_inset Formula $E$
\end_inset

 on 
\begin_inset Formula $q$
\end_inset

 positions between 
\begin_inset Formula $1$
\end_inset

 and 
\begin_inset Formula $i$
\end_inset

.
 If 
\begin_inset Formula $\gamma_{i}\in E_{i}$
\end_inset

 then the cutting matches 
\begin_inset Formula $E$
\end_inset

 on 
\begin_inset Formula $q-1$
\end_inset

 positions between 
\begin_inset Formula $1$
\end_inset

 and 
\begin_inset Formula $i-1$
\end_inset

 (cases 2 and 3).
 Otherwise, the 
\begin_inset Formula $q$
\end_inset

 remains the same between the recursive steps (cases 1 and 4).
 Hence the recursive formula does not depend on 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
values 
\begin_inset Formula $q-2$
\end_inset

 or less and no cutting is left out.
\end_layout

\begin_layout Proof
Similarly if the cutting depth 
\begin_inset Formula $\gamma_{i}\in B_{i}$
\end_inset

, the cutting is not blocked on the 
\begin_inset Formula $i$
\end_inset

-th position.
 Therefore it must have been blocked 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
somewhere between positions 
\begin_inset Formula $1$
\end_inset

 and 
\begin_inset Formula $i-1$
\end_inset

.
 Therefore cases 1 and 2 extend 
\begin_inset Formula $\Theta(i,*,E,B)$
\end_inset

 cuttings.
 Cases 3 and 4 assume
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 
\begin_inset Formula $\gamma_{i}\not\in B_{i}$
\end_inset

, which ensures (possibly additional) blocking on the 
\begin_inset Formula $i$
\end_inset

-th position and extend 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Theta(i,*,E,\emptyset)$
\end_inset

.
\end_layout

\begin_layout Standard
Having defined and understood 
\begin_inset Formula $\Gamma$
\end_inset

 and 
\begin_inset Formula $\Theta$
\end_inset

 functions, there is the question of their evaluation.
 A third, equivalent, closed-form formula is unlikely to exist, and a naive
 execution of both functions is exponential in 
\begin_inset Formula $p$
\end_inset

.
 Observing that parameters 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 can only decrease during the execution of 
\begin_inset Formula $\Theta$
\end_inset

 calls for its evaluation via a simple dynamic programming scheme.
 Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "vanilla-counting-algorithm"

\end_inset

 implements the scheme and runs in quadratic time.
 The algorithm merely turns the terminating condition (
\begin_inset CommandInset ref
LatexCommand ref
reference "big-theta-equation"

\end_inset

) into initialisation and then applies the recursive case (
\begin_inset CommandInset ref
LatexCommand ref
reference "small-theta-equation"

\end_inset

).
 A better version would save memory (which implies better cache usage on
 modern CPUs) by eliminating the first dimension from the 
\begin_inset Formula $\varTheta$
\end_inset

 array by observing that 
\begin_inset Formula $\varTheta(i,*,*)$
\end_inset

 only depends on 
\begin_inset Formula $\varTheta(i-1,*,*)$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LinesNumbered
\end_layout

\begin_layout Plain Layout


\backslash
DontPrintSemicolon
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{Input}{input}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{Output}{output}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{Count}{count}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{Function}{
\backslash
string:}{}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
Input{The deepest cutting $(
\backslash
tilde{d}_{1},
\backslash
ldots,
\backslash
tilde{d}_{p})$, a whole number $q$ and two cylinders $E,B$}
\end_layout

\begin_layout Plain Layout


\backslash
Output{Value of the $
\backslash
Theta(1,q,E,B)$}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
Fn(){$
\backslash
Count((
\backslash
tilde{d}_1,
\backslash
ldots,
\backslash
tilde{d}_p),q,E,B)$}{
\end_layout

\begin_layout Plain Layout

  declare $
\backslash
varTheta$ as an array of size $p 
\backslash
cdot (p+1) 
\backslash
cdot 2$, values initialised to $0$,
\end_layout

\begin_layout Plain Layout

    for convenience indexed by $
\backslash
{1,
\backslash
ldots,p
\backslash
} 
\backslash
times 
\backslash
{0,
\backslash
ldots,p
\backslash
} 
\backslash
times 
\backslash
{B,
\backslash
emptyset
\backslash
}$ 
\backslash
;
\end_layout

\begin_layout Plain Layout

  $
\backslash
varTheta(1,1,B) 
\backslash
gets |E_1
\backslash
setminus B_1|$ 
\backslash
;
\end_layout

\begin_layout Plain Layout

  $
\backslash
varTheta(1,0,B) 
\backslash
gets 
\backslash
tilde{d}_1-|E_1
\backslash
cup B_1|$ 
\backslash
;
\end_layout

\begin_layout Plain Layout

  $
\backslash
varTheta(1,1,
\backslash
emptyset) 
\backslash
gets |E_1|$ 
\backslash
;
\end_layout

\begin_layout Plain Layout

  $
\backslash
varTheta(1,0,
\backslash
emptyset) 
\backslash
gets 
\backslash
tilde{d}_p-|E_1|$ 
\backslash
;
\end_layout

\begin_layout Plain Layout

  
\backslash
For(){$i 
\backslash
in 
\backslash
{2,
\backslash
ldots,p
\backslash
}$}{
\end_layout

\begin_layout Plain Layout

    
\backslash
For(){$q 
\backslash
in 
\backslash
{0,
\backslash
ldots,i
\backslash
}$}{
\end_layout

\begin_layout Plain Layout

      $
\backslash
begin{aligned}
\end_layout

\begin_layout Plain Layout

      
\backslash
varTheta(i,q,B) 
\backslash
gets |B_i
\backslash
setminus E_i| & 
\backslash
cdot
\backslash
,
\backslash
varTheta(i-1,q,B)
\backslash
,+
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

                              + 
\backslash
,|B_i
\backslash
cap E_i| & 
\backslash
cdot
\backslash
,
\backslash
varTheta(i-1,q-1,B)
\backslash
,+
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

                         + 
\backslash
,|E_i
\backslash
setminus B_i| & 
\backslash
cdot
\backslash
,
\backslash
varTheta(i-1,q-1,
\backslash
emptyset)
\backslash
,+
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

              + 
\backslash
,(
\backslash
tilde{d}_{i}-|E_i
\backslash
cup B_i|) & 
\backslash
cdot
\backslash
,
\backslash
varTheta(i-1,q,
\backslash
emptyset)
\end_layout

\begin_layout Plain Layout

      
\backslash
end{aligned} $
\backslash
;
\end_layout

\begin_layout Plain Layout

      
\backslash
BlankLine
\end_layout

\begin_layout Plain Layout

      $
\backslash
begin{aligned}
\end_layout

\begin_layout Plain Layout

      
\backslash
varTheta(i,q,
\backslash
emptyset) 
\backslash
gets |E_i| & 
\backslash
cdot
\backslash
,
\backslash
varTheta(i-1,q-1,
\backslash
emptyset)
\backslash
,+
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

                 + 
\backslash
,(
\backslash
tilde{d}_{i}-|E_i|) & 
\backslash
cdot
\backslash
,
\backslash
varTheta(i-1,q,
\backslash
emptyset)
\end_layout

\begin_layout Plain Layout

      
\backslash
end{aligned} $
\backslash
;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\backslash
Return $A(p,q,B)$ 
\backslash
;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Cutting-counting in the asymmetric fr.
\end_layout

\end_inset

Cutting-counting algorithm for the asymmetric framework.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "vanilla-counting-algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
General framework
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "count-gen-sec"

\end_inset


\end_layout

\begin_layout Standard
Having formulated a cutting counting procedure for the asymmetric framework,
 can the same be done for the general framework?
\end_layout

\begin_layout Standard
First, recall a fundamental limitation.
 Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sat-correspondence-section"

\end_inset

 established that the problem is 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete, namely, it sits in the 
\begin_inset Formula $\#\mathcal{P}$
\end_inset

 class, which kills any hope for a polynomial procedure.
\end_layout

\begin_layout Paragraph
SAT-based approach.
\end_layout

\begin_layout Standard
The SAT correspondence may yield the first practical algorithm, which would
 be easy to implement.
 Theorem 
\begin_inset CommandInset ref
LatexCommand ref
reference "sat-correspondence-theorem"

\end_inset

 shows that every solution of the 
\begin_inset Formula $1\times0$
\end_inset

 lock-chart corresponds to one cutting in 
\begin_inset Formula $S$
\end_inset

.
 Can we take the straightforward translation of the 
\begin_inset Formula $1\times0$
\end_inset

 lock-chart to CNF (from Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sat-sec"

\end_inset

) and use existing efficient libraries 
\begin_inset CommandInset citation
LatexCommand cite
key "biere2009"

\end_inset

 to solve the #SAT problem?
\end_layout

\begin_layout Standard
Interested readers may try this approach, but we remain sceptical.
 There are several issues that would have to be addressed:
\end_layout

\begin_layout Itemize
Take the DPLL-Based Model Counters (discussed in Section 20.2.1 of 
\begin_inset CommandInset citation
LatexCommand cite
key "biere2009"

\end_inset

).
 Their idea is to obtain a partial solution 
\begin_inset Formula $\mathcal{I}:\,X\rightharpoonup\{0,1\}$
\end_inset

, which do not have to assign all variables 
\begin_inset Formula $X$
\end_inset

, but stop once every clause has at least 
\begin_inset Formula $1$
\end_inset

 positive literal.
 The remaining 
\begin_inset Formula $|X|-|\mathcal{I}|$
\end_inset

 variables can be assigned arbitrarily, and hence the partial solution captures
 
\begin_inset Formula $2^{|X|-|\mathcal{I}|}$
\end_inset

 models.
 However, considering the CNF instances from Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sat-sec"

\end_inset

, the solution cannot be partial (
\begin_inset Formula $|X|=|\mathcal{I}|$
\end_inset

), because of the binary clauses coming from the “1-of-N encoding”.
 If a variable 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\mathsf{key}_{i,j}^{k}$
\end_inset

 is assigned 
\begin_inset Formula $1$
\end_inset

, all other variables 
\begin_inset Formula $\mathsf{key}_{i,j'}^{k}$
\end_inset

 (for 
\begin_inset Formula $j\neq j'$
\end_inset

) must be assigned 
\begin_inset Formula $0$
\end_inset

, otherwise the binary clauses have no positive literal.
\end_layout

\begin_layout Itemize
Another strong idea of model counters is a 
\emph on
component analysis
\emph default
.
 Connected components of the 
\emph on
constraint graph
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "biere2009"

\end_inset

 may be solved independently.
 Variables encoding different positions of a cutting indeed appear in different
 connected components, but only as long as they are not joined by a gecon,
 which is often the case.
 Hence this idea works well only in the asymmetric framework (for which
 there is a polynomial procedure).
\end_layout

\begin_layout Standard
On a different note, one may try solving a series of key-to-differ lock-charts
 with increasing size by a non-counting (aka standard) SAT-solver.
 Lemma
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "key2diff-sat-lemma"

\end_inset

 shows that a solution to the largest solvable key-to-differ lock-chart
 gives the set 
\begin_inset Formula $|S|$
\end_inset

.
 However, it is hard to believe that such a solver would get much further
 than 
\begin_inset Formula $\sim2000$
\end_inset

 cuttings we obtained in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sat-sec"

\end_inset

 by MiniSAT on diagonal lock-charts.
 Instead, here we aim at results in the order of 
\begin_inset Formula $\sim10^{7}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Inclusion-exclusion procedure.
\end_layout

\begin_layout Standard
The probably simplest form of the 
\emph on
inclusion-exclusion
\emph default
 principle says that given two sets 
\begin_inset Formula $A,B$
\end_inset

, their sizes are related as following:
\begin_inset Formula 
\[
|A\cup B|=|A|+|B|-|A\cap B|
\]

\end_inset

The principle may be known from the high-school formula on the probability
 of two dependent events.
 Here, it will be applied to counting cuttings that are satisfied by a set
 of gecons.
\end_layout

\begin_layout Standard
Recall that a gecon is associated with a universal cylinder, formally defined
 in Lemma
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "universal-cylinder-lemma"

\end_inset

.
 A cutting satisfies the gecon if and only if the cutting is blocked in
 the associated universal cylinder.
 Therefore counting cuttings that satisfy a set of gecons is equivalent
 to the number of cuttings blocked in all associated universal cylinders.
\end_layout

\begin_layout Lemma
Let 
\begin_inset Formula $C=(C_{1},\ldots,C_{p})$
\end_inset

 and 
\begin_inset Formula $D=(D_{1},\ldots,D_{p})$
\end_inset

 be two cylinders.
 Their intersection denoted as 
\begin_inset Formula 
\[
C\cap D=(C_{1}\cap D_{1},\ldots,C_{p}\cap D_{p})
\]

\end_inset

blocks exactly those cuttings that are blocked in both 
\begin_inset Formula $C$
\end_inset

 and 
\begin_inset Formula $D$
\end_inset

.
\end_layout

\begin_layout Proof
A cutting 
\begin_inset Formula $(c_{1},\ldots,c_{p})$
\end_inset

 is blocked in 
\begin_inset Formula $C$
\end_inset

 if there is 
\begin_inset Formula $i\in\{1,\ldots,p\}$
\end_inset

 s.t.
 
\begin_inset Formula $c_{i}\not\in C_{i}$
\end_inset

.
 Therefore 
\begin_inset Formula $c_{i}\not\in C_{i}\cap D_{i}$
\end_inset

 and hence the cutting is blocked in 
\begin_inset Formula $C\cap D$
\end_inset

.
 If the cutting is blocked in 
\begin_inset Formula $C\cap D$
\end_inset

, then there is 
\begin_inset Formula $i\in\{1,\ldots,p\}$
\end_inset

 s.t.
 
\begin_inset Formula $c_{i}\not\in C_{i}\cap D_{i}$
\end_inset

.
 Therefore either 
\begin_inset Formula $c_{i}\not\in C_{i}$
\end_inset

 or 
\begin_inset Formula $c_{i}\not\in D_{i}$
\end_inset

 and the cutting is blocked in 
\begin_inset Formula $C$
\end_inset

 or 
\begin_inset Formula $D$
\end_inset

.
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Having defined an intersection of cylinders, we can count the number of
 blocked cuttings.
\end_layout

\begin_layout Corollary
Let 
\begin_inset Formula $C$
\end_inset

 and 
\begin_inset Formula $D$
\end_inset

 be two cylinders.
 Number of cuttings blocked by both 
\begin_inset Formula $C$
\end_inset

 and 
\begin_inset Formula $D$
\end_inset

 is (I.) the number of cuttings blocked by 
\begin_inset Formula $C$
\end_inset

 
\emph on
plus
\emph default
 (II.) the number of cuttings blocked by 
\begin_inset Formula $D$
\end_inset

 
\emph on
minus
\emph default
 (III.) the number of cuttings blocked by 
\begin_inset Formula $C\cap D$
\end_inset

.
\end_layout

\begin_layout Proof
If a cutting is blocked in the cylinder 
\begin_inset Formula $C$
\end_inset

 only, it is only counted in the (I.) term.
 If a cutting is blocked by both 
\begin_inset Formula $C$
\end_inset

 and 
\begin_inset Formula $D$
\end_inset

, it is counted in all 3 terms (I.), (II.) and (III.).
 Given the polarities, two of the terms cancel out.
 Hence the cutting is counted only once.
 Other cases are similar or trivial.
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
The inclusion-exclusion principle generalises the corollary to an arbitrary
 number of cylinders.
\end_layout

\begin_layout Definition

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Let 
\begin_inset Formula $\bar{\Gamma}(q,E,\{B_{1},\ldots,B_{n}\})$
\end_inset

 be the generalised 
\begin_inset Formula $\Gamma$
\end_inset

 function, which counts the number of cuttings, which have exactly 
\begin_inset Formula $q$
\end_inset

 cutting depths present in the cylinder 
\begin_inset Formula $E$
\end_inset

 (on respective positions) and which are blocked by all cylinders 
\begin_inset Formula $B_{i}$
\end_inset

.
 The inclusion-exclusion principle states
\begin_inset Formula 
\begin{align}
\bar{\Gamma}(q,E,\{B_{1},\ldots,B_{n}\})= & \sum_{i=1}^{n}\Gamma(q,E,B_{i})-\\
- & \sum_{i=1}^{n-1}\sum_{j=i+1}^{n}\Gamma(q,E,B_{i}\cap B_{j})+\\
+ & \sum_{i=1}^{n-2}\sum_{j=i+1}^{n-1}\sum_{k=j+1}^{n}\Gamma(q,E,B_{i}\cap B_{j}\cap B_{k})-\cdots\\
\cdots & \ \Gamma(q,E,B_{1}\cap\cdots\cap B_{n})\text{ .}
\end{align}

\end_inset


\end_layout

\begin_layout Example

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
\begin_inset CommandInset label
LatexCommand label
name "theta-generalized-example"

\end_inset

Let 
\begin_inset Formula $p=3$
\end_inset

, 
\begin_inset Formula $d=2$
\end_inset

, 
\begin_inset Formula $q=2$
\end_inset

, 
\begin_inset Formula $E=(\{1\},\{1\},\{1\})$
\end_inset

 and the three gecons are 
\begin_inset Formula $(?,1,2)$
\end_inset

, 
\begin_inset Formula $(1,1,?)$
\end_inset

 and 
\begin_inset Formula $(?,2,?)$
\end_inset

.
 The expected answer is 
\begin_inset Formula $\bar{\Gamma}(q,E,\{B_{1},B_{2},B_{3}\})=1$
\end_inset

, because from the 3 candidate cuttings 
\begin_inset Formula $S_{q}=S_{2}=\{(1,1,2),(1,2,1),(2,1,1)\}$
\end_inset

 only 
\begin_inset Formula $(2,1,1)$
\end_inset

 satisfies all 3 gecons.
\end_layout

\begin_layout Example

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
First state the universal cylinders associated with the 3 gecons: 
\begin_inset Formula 
\[
B_{1}=(\{1,2\},\{1\},\{2\})\text{, }B_{2}=(\{1\},\{1\},\{1,2\})
\]

\end_inset


\begin_inset Formula 
\[
\text{ and }B_{3}=(\{1,2\},\{2\},\{1,2\})\text{ .}
\]

\end_inset


\end_layout

\begin_layout Example
Let us save some work by noting that 
\begin_inset Formula $B_{2}\cap B_{3}=(\{1\},\emptyset,\{1,2\})$
\end_inset

.
 Every cutting is blocked on the middle position, hence 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\Gamma(q,E,B_{2}\cap B_{3})=\Gamma(q,E,\emptyset)=|S_{q}|$
\end_inset

.
 The same is true for 
\begin_inset Formula $B_{1}\cap B_{2}\cap B_{3}$
\end_inset

, because the additional cylinder 
\begin_inset Formula $B_{1}$
\end_inset

 in the intersection cannot remove 
\begin_inset Formula $\emptyset$
\end_inset

 from the 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
middle
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 position.
 Therefore the terms 
\begin_inset Formula $\Gamma(q,E,B_{2}\cap B_{3})$
\end_inset

 and 
\begin_inset Formula $\Gamma(q,E,B_{1}\cap B_{2}\cap B_{3})$
\end_inset

 cancel out:
\begin_inset Formula 
\begin{multline*}
\bar{\Gamma}(q,E,\{B_{1},B_{2},B_{3}\})=\\
=\Gamma(q,E,B_{1})+\Gamma(q,E,B_{2})+\Gamma(q,E,B_{3})-\\
-\Gamma(q,E,B_{1}\cap B_{2})-\Gamma(q,E,B_{1}\cap B_{3})
\end{multline*}

\end_inset


\end_layout

\begin_layout Example

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "theta-example"

\end_inset

 already calculated 
\begin_inset Formula $\Gamma(q,E,B_{1})=2$
\end_inset

.
 By a similar calculation, by invoking 
\begin_inset Formula $\mathtt{count(}\ldots\mathtt{)}$
\end_inset

, or by observing that both 
\begin_inset Formula $B_{2}$
\end_inset

 and 
\begin_inset Formula $B_{3}$
\end_inset

 block exactly 
\begin_inset Formula $2$
\end_inset

 cuttings from 
\begin_inset Formula $S_{2}$
\end_inset

, we get 
\begin_inset Formula $\Gamma(q,E,B_{2})=\Gamma(q,E,B_{3})=2$
\end_inset

.
 The cylinder 
\begin_inset Formula $B_{1}\cap B_{2}=(\{1\},\{1\},\{2\})$
\end_inset

 is entered only by the cutting 
\begin_inset Formula $(1,1,2)$
\end_inset

, hence 
\begin_inset Formula $\Gamma(q,E,B_{1}\cap B_{3})=2$
\end_inset

.
 The cylinder 
\begin_inset Formula $B_{1}\cap B_{3}=(\{1,2\},\emptyset,\{2\})$
\end_inset

 has the middle position empty, which yields 
\begin_inset Formula $\Gamma(q,E,B_{1}\cap B_{3})=|S_{q}|=3$
\end_inset

.
 Substituting the values gives 
\begin_inset Formula 
\[
\bar{\Gamma}(q,E,\{B_{1},B_{2},B_{3}\})=2+2+2-2-3=1\text{ .}
\]

\end_inset


\end_layout

\begin_layout Standard
How to apply the formula to cutting counting?
\end_layout

\begin_layout Enumerate

\series bold
Code space size:
\series default
 The code space size is given simply by
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula 
\begin{equation}
|S|=\sum_{q=0}^{p}\bar{\Gamma}(q,\emptyset,\{B_{1},\ldots,B_{n}\})\text{ ,}
\end{equation}

\end_inset

where 
\begin_inset Formula $B_{i}$
\end_inset

 is the universal cylinder associated with the 
\begin_inset Formula $i$
\end_inset

-th gecon.
\end_layout

\begin_layout Enumerate

\series bold
Diagonal lock-charts:
\series default
 Unfortunatelly, in the general framework, not all cutting depths are treated
 equally.
 Some may be more constrained by gecons, some less.
 Therefore not all general keys are equal and the lock-chart size depends
 on the general key's cutting.
 Assume for a moment that it is given as 
\begin_inset Formula $(g_{1},\ldots,g_{p})$
\end_inset

.
 Then the number of individual keys in a diagonal lock-chart is at least
 
\begin_inset Formula 
\begin{equation}
\max_{q\in\{0,\ldots,p-1\}}\bar{\Gamma}(q,(\{g_{1}\},\ldots,\{g_{p}\}),\{B_{1},\ldots,B_{n}\})\label{generalized-diagonal-size-equation}
\end{equation}

\end_inset


\end_layout

\begin_layout Enumerate

\series bold
Finding a good general key:
\series default
 The last formula evaluates a cutting for the general key by the number
 of individual keys that can be added to its diagonal lock-chart.
 By sampling 
\begin_inset Formula $(g_{1},\ldots,g_{p})\in S$
\end_inset

, one can pick the one which maximizes the (
\begin_inset CommandInset ref
LatexCommand ref
reference "generalized-diagonal-size-equation"

\end_inset

).
 However, the repeated evaluation of this formula may not be the fastest
 way to go.
 Faster algorithms are left for future research.
\end_layout

\begin_layout Paragraph
Evaluation.
\end_layout

\begin_layout Standard
The inclusion-exclusion procedure might ex\SpecialChar softhyphen
plo\SpecialChar softhyphen
re all 
\begin_inset Formula $2^{n}$
\end_inset

 combinations of 
\begin_inset Formula $n$
\end_inset

 gecons, which defines its worst-case time complexity.
 Depending on 
\begin_inset Formula $p,d$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

, it may or may not be faster than searching 
\begin_inset Formula $d^{p}$
\end_inset

 cuttings and checking against all constraints.
 In a joint project with Václav Voráček, an efficient procedure is currently
 being developed.
 The pseudo-code and details of the actual implementation will be published
 in his bachelor's thesis.
 Here is merely a short list of ideas for an efficient implementation and
 a short justification of the entire approach.
\end_layout

\begin_layout Itemize

\series bold
Pruning:
\series default
 Once any intersection becomes empty, then its intersection with additional
 cylinders must yield an empty intersection.
 This idea was used in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "theta-generalized-example"

\end_inset

.
 A clever strategy inspired by the Apriori algorithm for mining itemsets
 
\begin_inset CommandInset citation
LatexCommand cite
key "agrawal1994"

\end_inset

 may avoid evaluating intersections, whose subsets are empty.
 From our experience, this idea is the major factor for the efficiency of
 the inclusion-exclusion principle.
\end_layout

\begin_layout Itemize

\series bold
Unitary constraints:
\series default
 An unitary constraint is a gecon which has exactly 1 non-wildcard position.
 Such constraints can be eliminated in the same way as unitary propagation
 works in the DPLL algorithm.
\end_layout

\begin_layout Itemize

\series bold
Caching:
\series default
 Assume 
\begin_inset Formula $E=\emptyset$
\end_inset

.
 Then the value of 
\begin_inset Formula $\Gamma(0,\emptyset,B)$
\end_inset

 depends purely on the number of cutting depths on each position, not their
 actual values.
 Hash-based caching can use a sorted array 
\begin_inset Formula $[|B_{1}|,\ldots,|B_{p}|]$
\end_inset

, which is shared among multiple different cylinders.
 This avoids redundant executions of the 
\begin_inset Formula $\mathtt{count(}...,B\mathtt{)}$
\end_inset

 procedure.
\end_layout

\begin_layout Standard
For a quick empirical evaluation, two real-world platforms were shortlisted,
 to which we had the complete list of gecons, and which had the highest
 known 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

 values.
 Due to a non-disclosure agreement, we cannot report specific details.
 Speaking of approximate numbers, the first platform had 
\begin_inset Formula $12$
\end_inset

 positions and between 
\begin_inset Formula $6$
\end_inset

 and 
\begin_inset Formula $7$
\end_inset

 cutting depths and the number of unconstrained cuttings (which satisfy
 merely 
\begin_inset Formula $1\leq d_{i}\leq\tilde{d}_{i}$
\end_inset

) was 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\tilde{d}_{1}\cdots\tilde{d}_{p}\simeq3\cdot10^{9}$
\end_inset

.
 Such cuttings were constrained by 
\begin_inset Formula $\sim70$
\end_inset

 gecons, most of which had 
\begin_inset Formula $2$
\end_inset

 non-wildcard positions and the remaining ones had 
\begin_inset Formula $3$
\end_inset

 non-wildcard positions.
 The second platform had 
\begin_inset Formula $12$
\end_inset

 positions and 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
between 
\begin_inset Formula $2$
\end_inset

 and 
\begin_inset Formula $4$
\end_inset

 cutting depths and the number of unconstrained cuttings was 
\begin_inset Formula $\tilde{d}_{1}\cdots\tilde{d}_{p}\simeq108\cdot10^{15}.$
\end_inset

 The number of gecons was 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\sim65$
\end_inset

 and they were
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 structurally similar to the first platform.
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $\bar{\Gamma}$
\end_inset

 function was evaluated on a 16-core Intel Xeon clocked at 
\begin_inset Formula $3.10\text{ GHz}$
\end_inset

.
 On the first platform, the inclusion-exclusion approach was able to count
 
\begin_inset Formula $\sim840\cdot10^{6}$
\end_inset

 valid cuttings (and gave an exact value).
 The calculation took in 
\begin_inset Formula $60\thinspace\text{s}$
\end_inset

 and consumed 
\begin_inset Formula $\sim40\,\text{GB RAM}$
\end_inset

.
 The results are summarised in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "valid-cuttings-table"

\end_inset

.
 The table also indicate that 
\begin_inset Formula $27\%$
\end_inset

 unconstrained keys indeed satisfy all gecons.
\end_layout

\begin_layout Standard
On the second platform, the calculation was not successful.
 For values 
\begin_inset Formula $q<25$
\end_inset

, 
\begin_inset Formula $128\,\text{GB}$
\end_inset

 RAM was not enough and resulted in an out-of-memory error.
 This might be surprising, since both platforms had similar constraints,
 both in their structure and total number.
 The reason is a less efficient pruning.
 With a larger 
\begin_inset Formula $p$
\end_inset

, more constraints might be intersected before reaching an empty cylinder.
\end_layout

\begin_layout Standard
The implementation is still evolving rapidly, and the presented results
 are still preliminary.
 Curious readers should wait for Václav Voráček's thesis to see the full
 potential of this algorithm.
 Nevertheless the 
\begin_inset Formula $\bar{\Gamma}$
\end_inset

 function implemented using the inclusion-exclusion principle will see an
 application in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "impli-sec"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="15" columns="3">
<features tabularvalignment="middle">
<column alignment="right" valignment="top">
<column alignment="right" valignment="top">
<column alignment="right" valignment="top">
<row>
<cell alignment="right" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $q$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $|S_{q}|$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
runtime
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $0$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $64\cdot10^{6}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $7996 \text{ms}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $200\cdot10^{6}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $7298 \text{ms}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $260\cdot10^{6}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $7832 \text{ms}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $3$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $210\cdot10^{6}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $7044 \text{ms}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $4$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $110\cdot10^{6}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $6734 \text{ms}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $5$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $40\cdot10^{6}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $6754 \text{ms}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $6$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $11\cdot10^{6}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $3967 \text{ms}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $7$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $2\cdot10^{6}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $4011 \text{ms}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $8$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $280\thinspace000$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1755 \text{ms}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $9$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $27\thinspace000$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $483 \text{ms}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $10$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1\thinspace700$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $144 \text{ms}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $11$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $60$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $68 \text{ms}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="right" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $12$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $1$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="right" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $64 \text{ms}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $\sum$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $840\cdot10^{6}$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Formula $60\text{ s}$
\end_inset


\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Code space size on a real-world
\end_layout

\end_inset

Code space size on a real-world platform with 
\begin_inset Formula $p=12$
\end_inset

 and 
\begin_inset Formula $\tilde{d}_{i}$
\end_inset

 between 
\begin_inset Formula $3$
\end_inset

 and 
\begin_inset Formula $4$
\end_inset

.
 Values are rounded to 2 places.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "valid-cuttings-table"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Explicit framework
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "counting-explicit-section"

\end_inset


\end_layout

\begin_layout Standard
In the explicit framework, some counting problems become trivial.
 The set 
\begin_inset Formula $S$
\end_inset

 is given as the algorithm's input and hence the code space size 
\begin_inset Formula $|S|$
\end_inset

 is obtained by a linear scan that adds 
\begin_inset Formula $1$
\end_inset

 for every cutting in 
\begin_inset Formula $S$
\end_inset

.
 Also, given a cutting for the general key 
\begin_inset Formula $\gamma_{g}$
\end_inset

 and a value 
\begin_inset Formula $q$
\end_inset

, the algorithm scans 
\begin_inset Formula $S$
\end_inset

 and counts only those cuttings that are equal to 
\begin_inset Formula $\gamma_{g}$
\end_inset

 on exactly 
\begin_inset Formula $q$
\end_inset

 positions.
 Such linear algorithm gives the 
\begin_inset Formula $|S_{q}|$
\end_inset

 size, which is also a lower bound on the largest solvable diagonal lock-chart.
 A quadratic algorithm might consider all choices 
\begin_inset Formula $\gamma_{g}\in S$
\end_inset

 and pick the best cutting for the general key as: 
\begin_inset Formula 
\begin{equation}
\mathop{\arg\max}_{\gamma_{g}\in S,\ 0\leq q\leq p}|S_{q}|\ .\label{best-explicit-general-equation}
\end{equation}

\end_inset


\end_layout

\begin_layout Question
Are there diagonal lock-charts with more individual keys than the formula
 (
\begin_inset CommandInset ref
LatexCommand ref
reference "best-explicit-general-equation"

\end_inset

) gives?
\end_layout

\begin_layout Standard
First, note the principal limitation.
 The answer to the question can only be based on the violation of Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "thm:upper-bound"

\end_inset

.
 In other words, if all 
\begin_inset Formula $d^{p}$
\end_inset

 cuttings from a vanilla framework were given in 
\begin_inset Formula $S$
\end_inset

 explicitly, the Theorem would hold, and formula (
\begin_inset CommandInset ref
LatexCommand ref
reference "best-explicit-general-equation"

\end_inset

) would give the size of the largest diagonal lock-charts.
 Better algorithms must be able to exploit asymmetries in the code space.
\end_layout

\begin_layout Paragraph
Template lock-charts.
\end_layout

\begin_layout Standard
One such algorithm, which will be described in a moment, is suited for a
 bigger class of lock-charts than the diagonal ones.
 It will be described in its general form and then applied to diagonal lock-char
ts as a special case.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "template-definition"

\end_inset

The 
\emph on
template lock-chart
\emph default
 is a lock-chart 
\begin_inset Formula $(K,L,E)$
\end_inset

 and the 
\emph on
expansion function
\emph default
 
\begin_inset Formula $e:\,L\rightarrow\mathbb{W}$
\end_inset

 that assigns a number of individual keys to each lock in the template.
 Let 
\begin_inset Formula $K=\{k_{1},\ldots,k_{m}\}$
\end_inset

 and 
\begin_inset Formula $L=\{l_{1},\ldots,l_{n}\}$
\end_inset

.
 A template lock-chart is equivalent to the 
\emph on
expansion lock-chart
\emph default
 
\begin_inset Formula $(K',L',E')$
\end_inset

 s.t.
\begin_inset Formula 
\[
K'=\{k_{1},\ldots,k_{m},\overbrace{k_{1}^{1},\ldots,k_{1}^{e(l_{1})}}^{\text{expansion of }l_{1}},\ldots,\overbrace{k_{n}^{1},\ldots,k_{n}^{e(l_{n})}}^{\text{expansion of }l_{n}}\}\text{ ,}
\]

\end_inset


\begin_inset Formula 
\[
L'=\{\underbrace{l_{1}^{1},\ldots,l_{1}^{e(l_{1})}}_{\text{expansion of }l_{1}},\ldots,\underbrace{l_{n}^{1},\ldots,l_{n}^{e(l_{n})}}_{\text{expansion of }l_{n}}\}\text{ .}
\]

\end_inset


\end_layout

\begin_layout Definition
The keys 
\begin_inset Formula $k_{i}$
\end_inset

 from the template will be referred as 
\emph on
master
\emph default
 keys and the additional keys 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $k_{i}^{x}$
\end_inset

 as 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
individual
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 keys.
 The lock 
\begin_inset Formula $l_{j}$
\end_inset

 serves as the 
\family default
\series default
\shape default
\size default
\emph on
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
prototype
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 for all individual keys 
\begin_inset Formula $k_{j}^{1},\ldots,k_{j}^{e(l_{j})}$
\end_inset

 and locks 
\begin_inset Formula $l_{j}^{?}$
\end_inset

.
\end_layout

\begin_layout Definition
The edges 
\begin_inset Formula $E'$
\end_inset

 are defined as follows: Individual key 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $k_{i}^{x}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 opens lock 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $l_{j}^{y}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 if and only if 
\begin_inset Formula $i=j$
\end_inset

 and 
\begin_inset Formula $x=y$
\end_inset

.
 Master key 
\begin_inset Formula $k_{i}$
\end_inset

 opens lock 
\begin_inset Formula $l_{j}^{y}$
\end_inset

, formally 
\begin_inset Formula $(k_{i},l_{j}^{y})\in E'$
\end_inset

, if and only if 
\begin_inset Formula $k_{i}$
\end_inset

 opens 
\begin_inset Formula $l_{j}$
\end_inset

 in the template lock-chart 
\begin_inset Formula $(k_{i},l_{j})\in E$
\end_inset

.
\end_layout

\begin_layout Standard
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "template-expansion-figure"

\end_inset

 shows an example of a template and its expansion.
\end_layout

\begin_layout Standard
A so-called individual key 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $k_{i}^{x}$
\end_inset

 in the expansion is always an individual key according to the Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "gmik-def"

\end_inset

.
 This is because 
\begin_inset Formula $k_{i}^{x}$
\end_inset

 opens 
\begin_inset Formula $l_{i}^{x}$
\end_inset

 only.
 Master keys are more complicated.
\end_layout

\begin_layout Standard

\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
A so-called master key 
\begin_inset Formula $k_{i}$
\end_inset

 is also a master key by Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "gmik-def"

\end_inset

 if and only if 
\begin_inset Formula $e(l)\geq2$
\end_inset

 for some of opened locks 
\begin_inset Formula $l\in E(k_{i})$
\end_inset

.
 For example 
\begin_inset Formula $k_{1}$
\end_inset

 in 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:indgraph"

\end_inset


\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 is not a master key, because 
\begin_inset Formula $e(l_{1})$
\end_inset

 is only 
\begin_inset Formula $1$
\end_inset

.
 You may also notice 
\begin_inset Formula $E(k_{1})=E(k_{1}^{1})$
\end_inset

, which violates Assumption
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "distinct-ass"

\end_inset

.
\end_layout

\begin_layout Standard
However, such problems are only terminological and do not affect the algorithm
 presented here.
 To avoid confusion, by master and individual keys in this section we refer
 to Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "template-definition"

\end_inset

.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "template-diagonal-remark"

\end_inset

A diagonal lock-charts with 
\begin_inset Formula $n$
\end_inset

 individual keys is an extension of a 
\begin_inset Formula $1\times1$
\end_inset

 lock-chart 
\begin_inset Formula $(\{g\},\{l\},\{(g,l)\})$
\end_inset

 with expansion function 
\begin_inset Formula $s(l)=n$
\end_inset

.
\end_layout

\begin_layout Paragraph
Motivation.
\end_layout

\begin_layout Standard
Template lock-charts serve as a way to dissociate algorithms for master
 keys and individual keys (a similar idea can be found in 
\begin_inset CommandInset citation
LatexCommand cite
key "lawer2004"

\end_inset

).
 In this section, we assume that all master keys have been assigned by a
 suitable algorithm and here an algorithm is proposed to maximize the total
 number of individual keys that can be added to the system 
\begin_inset Formula 
\begin{equation}
\sum_{l\in L}e(l)\ .\label{max-expansion-equation}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Loose chaining of two different algorithms usually breaks completeness or
 explodes the practical time efficiency.
 We admit this, but only for a portion of lock-charts.
 It is a common practice for human operators to assign the general key manually
 to save “good” cuttings for hard lock-charts.
 In such a scenario there are only 
\begin_inset Formula $|S|^{\max_{l}|E(l)|-2}$
\end_inset

 such solutions to the template lock-chart.
 Moreover, iterating over all assignments of master keys is practically
 feasible, because from on our experience, many lock-charts have a small
 number of them.
 Approximate algorithms that work reasonably fast are evaluated in Chapter
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "backtrackers-chapter"

\end_inset

.
\end_layout

\begin_layout Paragraph
Translation to MIS.
\end_layout

\begin_layout Standard
The algorithm proposed here takes a template lock-chart with its solution
 and generates an undirected graph.
 The maximum independent set on this graph maximizes (
\begin_inset CommandInset ref
LatexCommand ref
reference "max-expansion-equation"

\end_inset

).
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "def:independence"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Independence graph
\end_layout

\end_inset

 Let 
\begin_inset Formula $(K,L,E)$
\end_inset

 be a template lock-chart and 
\begin_inset Formula $s$
\end_inset

 its solution.
 The
\emph on
 independence graph
\emph default
 is an undirected graph 
\begin_inset Formula $(N,H)$
\end_inset

, whose nodes are pairs of locks and cuttings 
\begin_inset Formula $N\subseteq L\times S$
\end_inset

.
 The graph contains a vertex 
\begin_inset Formula $(l,\gamma)$
\end_inset

 if 
\begin_inset Formula $s(l)\cup\gamma$
\end_inset

 blocks all cuttings 
\begin_inset Formula $s(k)$
\end_inset

 of stopped keys 
\begin_inset Formula $k\in K\setminus E(l)$
\end_inset

.
 There is an edge between 
\begin_inset Formula $(l,\gamma)$
\end_inset

 and 
\begin_inset Formula $(l',\gamma')$
\end_inset

 if either 
\begin_inset Formula $\gamma'$
\end_inset

 enters 
\begin_inset Formula $s(l)\cup\gamma$
\end_inset

 or 
\begin_inset Formula $\gamma$
\end_inset

 enters 
\begin_inset Formula $s(l')\cup\gamma'$
\end_inset

.
\end_layout

\begin_layout Lemma
Let 
\begin_inset Formula $(K,L,E)$
\end_inset

 be a template lock-chart, 
\begin_inset Formula $s$
\end_inset

 its solution and 
\begin_inset Formula $I=\{(l_{i},\gamma_{x}),(l_{j},\gamma_{y}),\ldots\}$
\end_inset

 be an independent set of the independence graph.
 Let 
\begin_inset Formula $(K',L',E')$
\end_inset

 be an expansion from 
\begin_inset Formula $e$
\end_inset

, where 
\begin_inset Formula 
\[
e(l)=\left|\left\{ (l_{i},\gamma_{x})\in I\ \middle|\ l_{i}=l\right\} \right|\ .
\]

\end_inset

The assignment 
\begin_inset Formula $s'=s\cup(k_{i}^{x},\gamma_{x})\cup(k_{j}^{y},\gamma_{y})\cup\cdots$
\end_inset

 is a solution to 
\begin_inset Formula $(K',L',E')$
\end_inset

.
\end_layout

\begin_layout Proof
Correctness is checked by inspecting all “empty cells” in the lock-chart.
 Take any lock 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $l_{i}^{x}$
\end_inset

 and an individual key 
\begin_inset Formula $k_{j}^{y}$
\end_inset

 which is blocked in 
\begin_inset Formula $l_{i}^{x}$
\end_inset

 (
\begin_inset Formula $i\neq j$
\end_inset

 or 
\begin_inset Formula $x\neq y$
\end_inset

).
 By definition 
\begin_inset Formula $s'(k_{j}^{y})=\gamma_{y}$
\end_inset

 and 
\begin_inset Formula $s'(l_{i}^{x})=s(l_{i})\cup\gamma_{x}$
\end_inset

.
 Since 
\begin_inset Formula $I$
\end_inset

 is an independent set, vertices 
\begin_inset Formula $(l_{i},\gamma_{x})$
\end_inset

 and 
\begin_inset Formula $(l_{j},\gamma_{y})$
\end_inset

 not adjacent in 
\begin_inset Formula $(N,H)$
\end_inset

 and therefore 
\begin_inset Formula $\gamma_{y}$
\end_inset

 does not enter 
\begin_inset Formula $s(l_{i})\cup\gamma_{x}$
\end_inset

.
 In other words, 
\begin_inset Formula $s'(k_{j}^{y})$
\end_inset

 is blocked by 
\begin_inset Formula $s'(l_{i}^{x})$
\end_inset

.
\end_layout

\begin_layout Proof
If a master key 
\begin_inset Formula $k_{j}$
\end_inset

 should be blocked in 
\begin_inset Formula $l_{i}^{x}$
\end_inset

, then 
\begin_inset Formula $s'(k_{j})=s(k_{j})$
\end_inset

 must be blocked in 
\begin_inset Formula $s'(l_{i}^{x})=s(l_{i})\cup\gamma_{x}$
\end_inset

.
 If it were not, then by definition 
\begin_inset Formula $(l_{i},\gamma_{x})$
\end_inset

 would not be a vertex in 
\begin_inset Formula $N$
\end_inset

.
\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "independence-graph-example"

\end_inset

Consider the lock-chart in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "template-expansion-figure"

\end_inset

 in the vanilla framework 
\begin_inset Formula $p=2$
\end_inset

, 
\begin_inset Formula $d=3$
\end_inset

.
 The template is solved as follows: 
\begin_inset Formula $s(k_{G})=(1,1)$
\end_inset

, 
\begin_inset Formula $s(k_{1})=(2,2)$
\end_inset

 and 
\begin_inset Formula $s(k_{2})=(1,3)$
\end_inset

.
 The result is shown in Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:indgraph"

\end_inset

.
 Vertices with self-loops (vertices 
\begin_inset Formula $(l,\gamma)$
\end_inset

, where 
\begin_inset Formula $\gamma$
\end_inset

 is a shear-line of 
\begin_inset Formula $s(l)$
\end_inset

) were omitted from the figure, because they can never be a part of any
 independent set.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "40col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename MiniLockChart.pdf
	lyxscale 200

\end_inset


\end_layout

\end_inset


\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "50col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename MiniMaximized.pdf
	lyxscale 400

\end_inset


\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Template and its expansion
\end_layout

\end_inset

A template lock-chart (left) and its expansion from 
\begin_inset Formula $e(l_{1})=1$
\end_inset

 and 
\begin_inset Formula $e(l_{2})=2$
\end_inset

 (right).
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "template-expansion-figure"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Box Frameless
position "t"
hor_pos "c"
has_inner_box 1
inner_pos "t"
use_parbox 0
use_makebox 0
width "60col%"
special "none"
height "1in"
height_special "totalheight"
thickness "0.4pt"
separation "3pt"
shadowsize "4pt"
framecolor "black"
backgroundcolor "none"
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Graphics
	filename IndependenceGraph.pdf
	lyxscale 300

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Independence graph
\end_layout

\end_inset

Example of an independence graph with a detailed description in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "independence-graph-example"

\end_inset

.
 The maximum independent set is shown in bold.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:indgraph"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Corollary
Maximizing the number of individual keys, which can be added to a template
 lock-chart, can be done by finding the maximum independent set of the independe
nce graph.
\end_layout

\begin_layout Proof
This corollary is justified by the formula
\begin_inset Formula 
\[
\sum_{l\in L}e(l)=\sum_{l\in L}\left|\left\{ (l_{i},\gamma_{x})\in I\ \middle|\ l_{i}=l\right\} \right|=|I|\ ,
\]

\end_inset

because all sets 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
in the sum are disjoint.
\end_layout

\begin_layout Standard
Diagonal lock-charts are expansions of the 
\begin_inset Formula $1\times1$
\end_inset

 lock-chart defined in Remark
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "template-diagonal-remark"

\end_inset

.
 Hence finding the MIS of the independence graph created from 
\begin_inset Formula $1\times1$
\end_inset

 lock-chart constitutes the largest diagonal lock-chart and solves the cutting
 counting problem.
\end_layout

\begin_layout Standard
How to find 
\begin_inset Formula $I$
\end_inset

? The maximum independent set is an 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete problem in general with an exponential best-known runtime.
 Our experience suggests a greedy approximation scheme, which picks the
 minimum degree vertex in each step 
\begin_inset CommandInset citation
LatexCommand citep
key "berman1994,halldorsson1997"

\end_inset

.
 Since the guaranteed approximation ratio on graphs with a bounded degree
 is inverse proportional to the maximum degree in the independence graph
 (which is quite high), the idea should be evaluated empirically.
\end_layout

\begin_layout Standard
A final disclaimer.
 This translation is not a proof of 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-hardness.
 If it were, the MIS would have to be translated into the problem of finding
 the largest diagonal lock-chart – not the other way round.
 In fact, whether the studied problem is in 
\begin_inset Formula $\mathcal{P}$
\end_inset

 or 
\begin_inset Formula $\mathcal{NP}$
\end_inset

 is still unknown to us and makes a good research question.
\end_layout

\begin_layout Paragraph
Evaluation.
\end_layout

\begin_layout Standard
Finally, the technique is evaluated by finding a solution to the largest
 diagonal lock-chart in the explicit framework.
 Here is the procedure to reproduce the experiments:
\end_layout

\begin_layout Enumerate
Uniformly sample 
\begin_inset Formula $1\leq p\leq6$
\end_inset

 and 
\begin_inset Formula $2\leq d\leq8$
\end_inset

.
\end_layout

\begin_layout Enumerate
Generate the 
\begin_inset Formula $S$
\end_inset

 set using two different methods:
\end_layout

\begin_deeper
\begin_layout Enumerate
In the 
\emph on
uniform
\emph default
 dataset there are no mechanical constraints and hence 
\begin_inset Formula $|S|=d^{p}$
\end_inset

.
 Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "thm:upper-bound"

\end_inset

 holds in the uniform dataset, and formula (
\begin_inset CommandInset ref
LatexCommand ref
reference "best-explicit-general-equation"

\end_inset

) gives the size of the largest diagonal lock-chart.
\end_layout

\begin_layout Enumerate
In the 
\emph on
realistic 
\emph default
dataset, mechanical constraints defined by our industrial partner were initialis
ed to random values, and the size of 
\begin_inset Formula $S$
\end_inset

 was reduced.
\begin_inset Foot
status open

\begin_layout Plain Layout
We do not list the exact constraints due to a non-disclosure agreement.
\end_layout

\end_inset


\end_layout

\end_deeper
\begin_layout Enumerate
Sample a uniform distribution over 
\begin_inset Formula $S$
\end_inset

 to obtain the cutting of the general key 
\begin_inset Formula $s(g)$
\end_inset

.
\end_layout

\begin_layout Enumerate
Use a non-backtracking algorithm, which adds one individual key and a lock
 at a time.
 1)
\begin_inset space ~
\end_inset

Initialise the lock-chart with the general key 
\begin_inset Formula $g$
\end_inset

 only and assign its cutting from the previous step.
 2)
\begin_inset space ~
\end_inset

Add 1 individual key 
\begin_inset Formula $k$
\end_inset

 and a lock 
\begin_inset Formula $l$
\end_inset

, s.t.
 
\begin_inset Formula $E(l)=\{g,k\}$
\end_inset

.
 3)
\begin_inset space ~
\end_inset

Pick a cutting from 
\begin_inset Formula $S$
\end_inset

 by one of the evaluated heuristics, assign it to
\begin_inset space ~
\end_inset


\begin_inset Formula $k$
\end_inset

.
 4)
\begin_inset space ~
\end_inset

If the solution is correct, reiterate from step
\begin_inset space ~
\end_inset

2.
 If not, find a different cutting in step 3.
 If there is no such cutting, terminate and report the size of the lock-chart.
\end_layout

\begin_deeper
\begin_layout Enumerate

\emph on
Baseline
\emph default
: The heuristic picks a random key from the uniform distribution over 
\begin_inset Formula $S$
\end_inset

.
\end_layout

\begin_layout Enumerate

\emph on
Same-As-General heuristics
\emph default
 (SAG): First sort 
\begin_inset Formula $S_{q}$
\end_inset

s by their cardinality.
\begin_inset Foot
status open

\begin_layout Plain Layout
The cardinality was measured by iterating over 
\begin_inset Formula $S$
\end_inset

, just as the formula (
\begin_inset CommandInset ref
LatexCommand ref
reference "best-explicit-general-equation"

\end_inset

).
 The result from Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "optimalq-theorem"

\end_inset

 was not used due to the bias in the realistic dataset.
\end_layout

\end_inset

 In step 3), start with keys from a larger 
\begin_inset Formula $S_{q}$
\end_inset

.
 Among keys with the same 
\begin_inset Formula $S_{q}$
\end_inset

, choose randomly.
 The result on the uniform dataset is guaranteed to be optimal.
\end_layout

\end_deeper
\begin_layout Enumerate
Generate the independence graph by Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "def:independence"

\end_inset

 with a 
\begin_inset Formula $1\times1$
\end_inset

 lock-chart as a template, whose only key has the cutting of the general
 key.
\end_layout

\begin_deeper
\begin_layout Enumerate

\emph on
Exact
\emph default
: If size permits, find a MIS using an exact, exponential procedure.
 If a result is found, it is guaranteed to be the optimal one regardless
 of the dataset.
\end_layout

\begin_layout Enumerate

\emph on
Greedy
\emph default
: In each iteration of a greedy approximation 
\begin_inset CommandInset citation
LatexCommand citep
key "halldorsson1997"

\end_inset

, pick the min-degree vertex and remove its neighbours from the graph.
\end_layout

\end_deeper
\begin_layout Enumerate
For all the methods above, we recorded the number of individual keys, referred
 as the 
\emph on
score
\emph default
.
\end_layout

\begin_layout Enumerate
When two algorithms are compared, we report the ratio of their scores.
 To aggregate more runs we used the geometric mean,
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Example: In one run, the baseline score is 10 and the SAG score 20.
 In the next one, the respective scores are 3 and 4.
 The final score would be 
\begin_inset Formula $\sqrt{\frac{20}{10}\cdot\frac{4}{3}}=1.63$
\end_inset

.
 We say that on average, the SAG heuristic achieves 63% better results than
 the baseline.
\end_layout

\end_inset

 shown in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:comparison"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset CommandInset include
LatexCommand input
filename "DiagonalStats.tex"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Cutting counting in explicit fr.
\end_layout

\end_inset

Cutting counting algorithms' performance in the explicit framework.
 Value larger than 1 means that the row-algorithm beats the column-algorithm.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "tab:comparison"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Conclusions.
\end_layout

\begin_layout Standard
Let us focus on the uniform dataset first.
 The 
\begin_inset Formula $1.0$
\end_inset

 value in the SAG column of Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "tab:comparison"

\end_inset

 above corroborate the optimality proof of the SAG heuristic from Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "thm:upper-bound"

\end_inset

.
 If 
\begin_inset Formula $|S|$
\end_inset

 is small enough for the exact procedure to produce a result, the greedy
 algorithm achieves a near-optimal score (up to the round-off error).
 However as 
\begin_inset Formula $|S|$
\end_inset

 grows, the greedy approximation loses 
\begin_inset Formula $7\%$
\end_inset

 on average to the optimum.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset CommandInset include
LatexCommand input
filename "BaselineSagSkew.tex"

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset CommandInset include
LatexCommand input
filename "SagExactSkew.tex"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Same-as-general heuristic evaluation
\end_layout

\end_inset

Scatterplot of the number of individual keys evaluates the same-as-general
 heuristic on the realistic dataset.
 Jitter is 
\begin_inset Formula $\pm0.25$
\end_inset

.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:same-as-general"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Results in the realistic dataset are similar, merely with smaller differences
 in scores.
 Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:same-as-general"

\end_inset

 above shows that the baseline can win over SAG only on very small lock-charts,
 by a factor of 2 at most.
 With more keys, the randomness inside the baseline heuristic is more likely
 to do wrong decisions and above 
\begin_inset Formula $100$
\end_inset

 keys SAG always performed better.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset CommandInset include
LatexCommand input
filename "GreedyExactSkew.tex"

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset CommandInset include
LatexCommand input
filename "SagGreedySkew.tex"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Greedy approximation evaluation
\end_layout

\end_inset

Scatterplot of the number of individual keys evaluates the greedy approximation
 on the realistic dataset.
 Jitter is 
\begin_inset Formula $\pm0.25$
\end_inset

.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "fig:greedy-approx"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
We consider the Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:greedy-approx"

\end_inset

 below as the most interesting.
 It shows that until 
\begin_inset Formula $10$
\end_inset

 keys, the greedy procedure achieves a better score than SAG.
 This is true up to 
\begin_inset Formula $\sim100$
\end_inset

 keys, where both heuristics are roughly even.
 With increasing code space, the greedy procedure loses, which also explains
 the overall 
\begin_inset Formula $3\%$
\end_inset

 loss.
 When focused on the small instances where the exact procedure found a result,
 the greedy heuristic won over SAG by 
\begin_inset Formula $2\%$
\end_inset

.
\end_layout

\begin_layout Chapter
Backtrackers
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "backtrackers-chapter"

\end_inset


\end_layout

\begin_layout Standard
A solution is a function that assigns cuttings to keys.
 A function is a set of binary tuples.
 Hence by 
\emph on
backtrackers
\emph default
 we mean algorithms that systematically explore subsets of 
\begin_inset Formula $K\times S$
\end_inset

.
 Unlike most previous ideas, they do not rely on a translation to a different
 formalism (e.g.
 SAT).
\end_layout

\begin_layout Standard
Since the search space is vast, we only deal with depth-first-search algorithms.
 Unlike breadth-first-search, their memory requirements scale linearly with
 
\begin_inset Formula $|K|$
\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LinesNumbered
\end_layout

\begin_layout Plain Layout


\backslash
DontPrintSemicolon
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{Input}{input}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{Output}{output}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{Null}{null}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{Prune}{prune}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{Dfs}{dfs}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{Function}{
\backslash
string:}{}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
Input{Melted profiles lock-chart $(K, L, E, B)$, a set of available key
 cuttings $S$ and a partial solution $
\backslash
hat{s}$}
\end_layout

\begin_layout Plain Layout


\backslash
Output{Algorithm 
\backslash
Dfs{$
\backslash
hat{s}$} returns a solution $s:
\backslash
, K 
\backslash
rightarrow S$ of the lock-chart or 
\backslash
Null if no solution exists}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
BlankLine
\end_layout

\begin_layout Plain Layout


\backslash
Fn(){
\backslash
Dfs{$
\backslash
hat{s}: K 
\backslash
rightharpoonup S$}}{
\end_layout

\begin_layout Plain Layout

  
\backslash
BlankLine
\end_layout

\begin_layout Plain Layout

  
\backslash
textrm{pick an unassigned key} $k$
\backslash
; 
\backslash
label{var-heur-line}
\end_layout

\begin_layout Plain Layout

  
\backslash
ForEach(){$
\backslash
textrm{candidate cutting }
\backslash
gamma 
\backslash
in S$}{ 
\backslash
label{val-heur-line}
\end_layout

\begin_layout Plain Layout

    $
\backslash
hat{s}' 
\backslash
leftarrow 
\backslash
hat{s} 
\backslash
cup (k, 
\backslash
gamma)$
\backslash
; 
\backslash
label{assigned-line}
\end_layout

\begin_layout Plain Layout

    
\backslash
If{$
\backslash
hat{s}'
\backslash
textrm{ is perspective}$
\backslash
label{persp-line}}{ 
\end_layout

\begin_layout Plain Layout

      $s 
\backslash
leftarrow$ 
\backslash
Dfs{$
\backslash
hat{s}'$}
\backslash
; 
\backslash
label{recursion-line}
\end_layout

\begin_layout Plain Layout

      
\backslash
If{$s 
\backslash
neq 
\backslash
Null$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
Return{$s$}
\backslash
;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\backslash
Return 
\backslash
Null
\backslash
;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Depth-first-search solver
\end_layout

\end_inset

Depth-first-search solver for melted profiles extension lock-charts.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "dfs-algorithm"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "dfs-algorithm"

\end_inset

 shows the template for all algorithms in this chapter.
 As a domain-specific algorithm, it is easy to modify and tweak.
 Specifically, there are 4 questions that can be addressed:
\end_layout

\begin_layout Enumerate
Which keys to pick first on line 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{var-heur-line}
\end_layout

\end_inset

?
\end_layout

\begin_layout Enumerate
Which cuttings to choose from on line 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{val-heur-line}
\end_layout

\end_inset

?
\end_layout

\begin_layout Enumerate
Which cuttings to pick first on line 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{val-heur-line}
\end_layout

\end_inset

?
\end_layout

\begin_layout Enumerate
Which assignment is perspective on line 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{persp-line}
\end_layout

\end_inset

?
\end_layout

\begin_layout Standard
The plain version of the algorithm answers the questions as follows: 1.
\begin_inset space ~
\end_inset

Pick keys sequentially from 
\begin_inset Formula $k_{1}$
\end_inset

 to 
\begin_inset Formula $k_{|K|}$
\end_inset

.
 2.
\begin_inset space ~
\end_inset

Try all cuttings.
 3.
\begin_inset space ~
\end_inset

Pick cuttings randomly.
 4.
\begin_inset space ~
\end_inset

Consider a partial assignment perspective if it is a solution.
\end_layout

\begin_layout Standard
Before finding better answers, please notice that the plain algorithm is
 not very bad.
 Section
\series bold

\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "counting-explicit-section"

\end_inset


\series default
 used a non-backtracking version called the “baseline”.
 On average it was able to solve a diagonal lock-chart with 
\begin_inset Formula $59\%$
\end_inset

 keys of the largest solvable lock-chart.
 Speaking about the worst-case, it found at least 
\begin_inset Formula $10\%$
\end_inset

 keys of the optimum (see Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:same-as-general"

\end_inset

).
 With backtracking in place, the algorithm's performance might only increase.
\end_layout

\begin_layout Section
Automorphism algorithm
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "amorf-sec"

\end_inset


\end_layout

\begin_layout Standard
Lawer's seminal work 
\begin_inset CommandInset citation
LatexCommand cite
key "lawer2004"

\end_inset

 on lock-chart solving provided a technique to prune large portions of the
 search-space.
 Perhaps surprisingly, the technique does not sacrifice completeness – if
 the lock-chart has a solution, the algorithm finds it.
\end_layout

\begin_layout Standard
In this section, its main idea is presented.
 We decided to reformulate the algorithm for two reasons.
 First, Lawer's work was hard to digest.
 A lengthier introduction might help some readers.
 Moreover, the actual implementation of her algorithm was never publicly
 released.
 For the experimental part of this text, we have reimplemented the idea
 exactly as described here.
 For a complete formal treatment, readers are encouraged to go through the
 original document.
\end_layout

\begin_layout Paragraph
Preliminaries.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $(V,E)$
\end_inset

 be a graph.
 An 
\emph on
automorphism
\emph default
 is a bijection 
\begin_inset Formula $a:\,V\rightarrow V$
\end_inset

 s.t.
 
\begin_inset Formula $a(v)$
\end_inset

 is adjacent to 
\begin_inset Formula $a(w)$
\end_inset

 if and only if 
\begin_inset Formula $v$
\end_inset

 is adjacent to 
\begin_inset Formula $w$
\end_inset

.
 A group of automorphisms on 
\begin_inset Formula $(V,E)$
\end_inset

 
\emph on
induces
\emph default
 an equivalence relation 
\begin_inset Formula $\simeq$
\end_inset

 on the set 
\begin_inset Formula $V$
\end_inset

: Two nodes are related 
\begin_inset Formula $v\simeq w$
\end_inset

 if there is an automorphism 
\begin_inset Formula $a$
\end_inset

 on 
\begin_inset Formula $(V,E)$
\end_inset

 s.t.
 
\begin_inset Formula $a(v)=w$
\end_inset

.
 Every equivalence relation 
\begin_inset Formula $\simeq$
\end_inset

 defines a 
\emph on
partition
\emph default
 of 
\begin_inset Formula $V$
\end_inset

 into sets 
\begin_inset Formula $P_{1},\ldots,P_{m}$
\end_inset

 called 
\emph on
classes
\emph default
: Two vertices 
\begin_inset Formula $v,w\in P_{i}$
\end_inset

 if and only if 
\begin_inset Formula $v\simeq w$
\end_inset

.
 The classes are disjoint (for every two distinct classes 
\begin_inset Formula $P_{i}$
\end_inset

 and 
\begin_inset Formula $P_{j}$
\end_inset

: 
\begin_inset Formula $P_{i}\cap P_{j}=\emptyset$
\end_inset

) and they partition 
\begin_inset Formula $V$
\end_inset

 (
\begin_inset Formula $P_{1}\cup\cdots\cup P_{m}=V$
\end_inset

).
 Hence a group of 
\begin_inset Formula $n$
\end_inset

 automorphisms on 
\begin_inset Formula $(V,E)$
\end_inset

 can be efficiently represented using 
\begin_inset Formula $P_{1},\ldots,P_{m}$
\end_inset

 classes of vertices s.t.
 
\begin_inset Formula $n=P_{1}!\cdot\cdots\cdot P_{m}!$
\end_inset

.
\end_layout

\begin_layout Standard
For convenience and a concise notation, an empty partition 
\begin_inset Formula $\emptyset$
\end_inset

 does not modify the set of automorphisms.
 Hence 
\begin_inset Formula $P_{1},\ldots,P_{m}$
\end_inset

 and 
\begin_inset Formula $P_{1},\ldots,P_{m},\emptyset$
\end_inset

 define exactly the same group of automorphisms.
 Given 
\begin_inset Formula $0!=1$
\end_inset

, the sizes are consistent 
\begin_inset Formula $P_{1}!\cdots P_{m}!=P!\cdots P_{m}!\cdot\emptyset!$
\end_inset

.
\end_layout

\begin_layout Standard
As of writing this text, it is not known whether the problem of finding
 a non-trivial automorphism is 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete or in 
\begin_inset Formula $\mathcal{P}$
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
key "mckay2014"

\end_inset

.
 The algorithm with the best known asymptotic time complexity runs in quasipolyn
omial time 
\begin_inset CommandInset citation
LatexCommand cite
key "babai2016,babai2017"

\end_inset

.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $(V',E')$
\end_inset

 be another graph.

\emph on
 
\emph default
The 
\emph on
induced subgraph isomorphism 
\emph default
is a function 
\begin_inset Formula $s:V\rightarrow V'$
\end_inset

 s.t.
 
\begin_inset Formula $s(v)$
\end_inset

 is adjacent to 
\begin_inset Formula $s(w)$
\end_inset

 in 
\begin_inset Formula $(V',E')$
\end_inset

 if and only if 
\begin_inset Formula $v$
\end_inset

 is adjacent to 
\begin_inset Formula $w$
\end_inset

 in 
\begin_inset Formula $(V,E)$
\end_inset

.
 Consequently, the subgraph of 
\begin_inset Formula $(V',E')$
\end_inset

 induced by vertices mapped by 
\begin_inset Formula $s$
\end_inset

 is isomorphic to 
\begin_inset Formula $(V,E)$
\end_inset

.
 The problem of finding an induced subgraph isomorphism is 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete 
\begin_inset CommandInset citation
LatexCommand cite
key "syslo1982"

\end_inset

.
 If the two graphs are bipartite 
\begin_inset Formula $V=V_{1}\cup V_{2}$
\end_inset

, 
\begin_inset Formula $V'=V_{1}'\cup V_{2}'$
\end_inset

, the 
\emph on
bipartite induced subgraph isomorphism
\emph default
 (BISI) is an induced subgraph isomorphism that maps only matching partite
 sets: 
\begin_inset Formula $s\subseteq\left(V_{1}\times V_{1}'\right)\cup\left(V_{2}\times V_{2}'\right)$
\end_inset

.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $n,k$
\end_inset

 be two integers.
 There 
\emph on
number of combinations with repetition
\emph default
 
\begin_inset Formula $\left(\binom{n}{k}\right)$
\end_inset

 denotes the number of 
\begin_inset Formula $k$
\end_inset

-tuples 
\begin_inset Formula $(x_{1},x_{2},\ldots,x_{k})$
\end_inset

 s.t.
 
\begin_inset Formula $1\leq x_{i}\leq n$
\end_inset

 which are ordered 
\begin_inset Formula $x_{1}\leq x_{2}\leq\cdots\leq x_{n}$
\end_inset

.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
If the ordering was strict 
\begin_inset Formula $x_{1}<x_{2}<\cdots<x_{n}$
\end_inset

, there would be 
\begin_inset Formula $\binom{n}{k}$
\end_inset

 such tuples.
 If there was no prescribed ordering, there would by 
\begin_inset Formula $n^{k}$
\end_inset

 tuples.
\end_layout

\end_inset

 The number can be evaluated using the binomial cofficient 
\begin_inset Formula $\left(\binom{n}{k}\right)=\binom{n+k-1}{k}$
\end_inset

.
\end_layout

\begin_layout Paragraph
Search space graph.
\end_layout

\begin_layout Standard
Lawer's algorithm will be presented in several steps.
 The first step reduces the lock-chart problem to finding a bipartite induced
 subgraph isomorphism.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "search-space-graph-definition"

\end_inset

The 
\emph on
search space graph
\emph default
 is a bipartite graph 
\begin_inset Formula $(S\cup T,R)$
\end_inset

, where 
\begin_inset Formula $S$
\end_inset

 is the set of all valid cuttings, 
\begin_inset Formula $T$
\end_inset

 the set of all cylinders and 
\begin_inset Formula $(\gamma,\lambda)\in R$
\end_inset

 if 
\begin_inset Formula $\gamma$
\end_inset

 enters 
\begin_inset Formula $\lambda$
\end_inset

.
\end_layout

\begin_layout Remark
\begin_inset CommandInset label
LatexCommand label
name "search-space-solution-remark"

\end_inset

Lock-chart 
\begin_inset Formula $(K,L,E)$
\end_inset

 has a correct solution 
\begin_inset Formula $s$
\end_inset

 if and only 
\begin_inset Formula $s$
\end_inset

 is a BISI from 
\begin_inset Formula $(K\cup L,E)$
\end_inset

 to the search space graph 
\begin_inset Formula $(S\cup T,R)$
\end_inset

.
\end_layout

\begin_layout Proof
Let 
\begin_inset Formula $s$
\end_inset

 be a correct solution.
 Then 
\begin_inset Formula $k$
\end_inset

 is adjacent to 
\begin_inset Formula $l$
\end_inset

 iff 
\begin_inset Formula $s(k)$
\end_inset

 enters 
\begin_inset Formula $s(l)$
\end_inset

 by Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand vref
reference "sol-def"

\end_inset

.
 This is equivalent to 
\begin_inset Formula $s(k)$
\end_inset

 being adjacent to 
\begin_inset Formula $s(l)$
\end_inset

 in the search space graph by Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "search-space-graph-definition"

\end_inset

.
 Hence 
\begin_inset Formula $s$
\end_inset

 is a BISI.
 The other direction is similar.
\end_layout

\begin_layout Paragraph
Symmetries.
\end_layout

\begin_layout Standard
The second step provides a way to prune the search space by finding symmetries
 (automorphisms) in the search space graph.
 The motivation behind it is to somehow “skip” isomorphic solutions, but
 still ensure that the algorithm can reach a solution (if it exists).
\end_layout

\begin_layout Theorem
Let 
\begin_inset Formula $(K,L,E)$
\end_inset

 be a lock-chart, 
\begin_inset Formula $s$
\end_inset

 its solution and 
\begin_inset Formula $a$
\end_inset

 an automorphism on the search space graph.
 Assignment 
\begin_inset Formula $s'$
\end_inset

 defined as 
\begin_inset Formula $s'(x)=a(s(x))$
\end_inset

 is a solution.
\end_layout

\begin_layout Proof
If 
\begin_inset Formula $a$
\end_inset

 is an automorphism in the search space graph, 
\begin_inset Formula $s(k)$
\end_inset

 and 
\begin_inset Formula $s(l)$
\end_inset

 are adjacent iff 
\begin_inset Formula $a(s(k))$
\end_inset

 and 
\begin_inset Formula $a(s(l))$
\end_inset

 are adjacent.
 Therefore 
\begin_inset Formula $s'$
\end_inset

 is a BISI, and by Remark
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "search-space-solution-remark"

\end_inset

, 
\begin_inset Formula $s'$
\end_inset

 is a solution.
\end_layout

\begin_layout Standard
The theorem explains why having an automorphism prunes the search space.
 How to find automorphisms?
\end_layout

\begin_layout Paragraph
Automorphisms by brute-force.
\end_layout

\begin_layout Standard
Before proceeding, let us report some experience with a brute-force approach,
 which constructs a restricted version of the search space graph in memory.
 The restriction exploits Remark
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "cylinder-count-remark"

\end_inset

 and reduces the number of cylinders 
\begin_inset Formula $|T|$
\end_inset

 from 
\begin_inset Formula $2^{d\cdot p}$
\end_inset

 to 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $|S|^{\max_{l\in L}|E(l)|}$
\end_inset

 without sacrificing completeness.
 For diagonal lock-charts, the size of 
\begin_inset Formula $|T|$
\end_inset

 is at most 
\begin_inset Formula $|S|^{2}$
\end_inset

 and the size of 
\begin_inset Formula $|U|$
\end_inset

 is at most 
\begin_inset Formula $|S|^{3}$
\end_inset

.
\end_layout

\begin_layout Standard
For experiments, we took the vanilla framework, generated all 
\begin_inset Formula $d^{p}$
\end_inset

 cuttings, all 
\begin_inset Formula $\left(\frac{1}{2}\cdot d\cdot(d+1)\right)^{p}$
\end_inset

 cylinders and the respective connections 
\begin_inset Formula $R$
\end_inset

.
 Next we took a few small real-world platforms and their set 
\begin_inset Formula $S$
\end_inset

.
 For finding all automorphisms the 
\family typewriter
nauty
\family default
 program 
\begin_inset CommandInset citation
LatexCommand cite
key "mckay2014"

\end_inset

 was used.
\end_layout

\begin_layout Standard
Quite surprisingly, 
\family typewriter
nauty
\family default
 was able to find all 
\begin_inset Formula $d^{p}!$
\end_inset

 automorphisms at least for small vanilla code spaces (roughly 
\begin_inset Formula $d,p\leq5$
\end_inset

) within the timeout.
 However, behind a certain border (around 
\begin_inset Formula $d\sim p\sim8$
\end_inset

), the runtime suddenly spiralled, and no solution was found under 1
\begin_inset space \thinspace{}
\end_inset

hour.
 We
\begin_inset space ~
\end_inset

attributed this to a switch between modes inside 
\family typewriter
nauty
\family default
.
\end_layout

\begin_layout Standard
Out of the real-world platforms, none were processed in a reasonable time.
 Even with only 
\begin_inset Formula $|S|\sim700$
\end_inset

 cuttings, the asymmetries in the code space prevented 
\family typewriter
nauty
\family default
 from finding any isomorphism.
 The brute-force approach is probably not usable for a practical algorithm.
\end_layout

\begin_layout Paragraph
Lawer's automorphisms.
\end_layout

\begin_layout Standard
Instead, automorphisms in 
\begin_inset CommandInset citation
LatexCommand cite
key "lawer2004"

\end_inset

 are derived theoretically.
 They are composed of two separate isomorphisms, one on cutting depths and
 one on positions.
 For representing both isomorphisms, the algorithm keeps track of classes
 of depths and classes of positions.
 An automorphism on the search space graph is a composition of the cutting
 depth automorphism and position automorphism.
\end_layout

\begin_layout Standard
The group of automorphisms is “reduced” by a partial assignment 
\begin_inset Formula $\hat{s}$
\end_inset

 that enters the function 
\begin_inset Formula $\mathtt{dfs}$
\end_inset

.
 Even though the automorphisms should be as “big” as possible to prune large
 numbers of candidate cuttings, they must also be defined in a way that
 the partial solution 
\begin_inset Formula $\hat{s}$
\end_inset

 remains unchanged.
 For any automorphism induced by the classes of depths and the classes of
 positions, we expect 
\begin_inset Formula 
\begin{equation}
\hat{s}(k)=a(\hat{s}(k))\text{ for all already assigned keys in }\hat{s}.
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
The 
\emph on
depth-classes
\emph default
 partition the set 
\begin_inset Formula $\{1,\ldots,d\}$
\end_inset

 and are represented by two disjoint sets 
\begin_inset Formula $U,R\subseteq\{1,\ldots,d\}$
\end_inset

 s.t.
 
\begin_inset Formula $U\cup R=\{1,\ldots,d\}$
\end_inset

.
 The set 
\begin_inset Formula $U$
\end_inset

 contains cutting depths that form 
\emph on
unitary
\emph default
 classes.
 In other words, if there is a unitary cutting depth 
\begin_inset Formula $u_{i}\in U$
\end_inset

, then there is one class 
\begin_inset Formula $\{u_{i}\}$
\end_inset

 in the partition.
 The set 
\begin_inset Formula $R$
\end_inset

 of 
\emph on
remaining
\emph default
 cutting depths forms a separate class.
 Hence given sets 
\begin_inset Formula $U=\{u_{1},\ldots,u_{|U|}\}$
\end_inset

 and 
\begin_inset Formula $R=\{1,\ldots,d\}\setminus U$
\end_inset

, the automorphism group on cutting depths is defined by the partition 
\begin_inset Formula $\{u_{1}\},\ldots,\{u_{|U|}\},R$
\end_inset

 that generates 
\begin_inset Formula $|R|!$
\end_inset

 automorphisms.
\end_layout

\begin_layout Standard
The idea behind the isomorphism on depths is similar to the proof of Lemma
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "diagonal-sq-size-lemma"

\end_inset

.
 Despite cutting depths are numbers, there is no particular order among
 them.
 In any solution 
\begin_inset Formula $\hat{s}$
\end_inset

, by swapping any two cutting depths on a certain position in every cutting
 and every cylinder, one must arrive at a solution as well.
 Hence, the set 
\begin_inset Formula $U$
\end_inset

 associated with the 
\begin_inset Formula $i$
\end_inset

-th position will contain cutting depths that appeared as 
\begin_inset Formula $\hat{s}(k)_{i}$
\end_inset

 for some already defined key 
\begin_inset Formula $k$
\end_inset

.
 Since 
\begin_inset Formula $R$
\end_inset

 contains all unused cutting depths, a
\begin_inset space ~
\end_inset

candidate cutting can try any arbitrarily chosen value from 
\begin_inset Formula $R$
\end_inset

, yet still retain completeness.
\end_layout

\begin_layout Standard
The 
\emph on
position-classes
\emph default
 partition the set of positions 
\begin_inset Formula $\{1,\ldots,p\}$
\end_inset

 into 
\begin_inset Formula $m$
\end_inset

 classes 
\begin_inset Formula $P=\{P_{1},\ldots,P_{m}\}$
\end_inset

.
 Every class 
\begin_inset Formula $P_{x}$
\end_inset

 represents positions that can be “freely permuted”.
 For any two positions 
\begin_inset Formula $i,j\in P_{x}$
\end_inset

, if cuttings 
\begin_inset Formula $d_{i}$
\end_inset

 and 
\begin_inset Formula $d_{j}$
\end_inset

 were swapped in every cuttings 
\begin_inset Formula $\hat{s}(k)$
\end_inset

 and sets of depths 
\begin_inset Formula $D_{i}$
\end_inset

 and 
\begin_inset Formula $D_{j}$
\end_inset

 were swapped in every cylidner 
\begin_inset Formula $\hat{s}(l)$
\end_inset

, the solution 
\begin_inset Formula $\hat{s}$
\end_inset

 would remain exactly the same.
\end_layout

\begin_layout Standard
Every position-class is 
\emph on
mapped
\emph default
 to one group of depth-classes by the function 
\begin_inset Formula $u:\,P\rightarrow2^{\{1,\ldots,d\}}$
\end_inset

.
 Let 
\begin_inset Formula 
\[
U_{x}=u(P_{x})\text{ and }R_{x}=\left\{ 1,\ldots,d\right\} \setminus U_{x}\ .
\]

\end_inset

 Now we can describe how 
\begin_inset Formula $u$
\end_inset

 prescribes all combinations of candidate depths 
\begin_inset Formula $d_{i},d_{j},\ldots$
\end_inset

 to positions 
\begin_inset Formula $P_{x}=\{i,j,\ldots\}$
\end_inset

.
 First note that by picking only one depth from the unused cutting depths
 
\begin_inset Formula $R_{x}$
\end_inset

 (if there is one) and all choices of 
\begin_inset Formula $U_{x}$
\end_inset

, every position can be assigned 
\begin_inset Formula $|U_{x}|+1$
\end_inset

 candidate cutting depths.
 Second, depths on positions 
\begin_inset Formula $P_{x}$
\end_inset

 can be freely permuted (see the previous paragraph), hence by considering
 only sequences of increasing cutting depths 
\begin_inset Formula $d_{i}\leq d_{j}\leq\cdots$
\end_inset

, completeness is not sacrificed.
 The number of candidate cutting depths assignable to 
\begin_inset Formula $|P_{x}|$
\end_inset

 positions is given by the 
\begin_inset Formula $z$
\end_inset

 function, defined using the number of combinations with repetition 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula 
\begin{equation}
z(P_{x},U_{x},R_{x})=\begin{cases}
\left({\displaystyle \binom{|U_{x}|+1}{|P_{x}|}}\right) & \text{if }R_{x}\neq\emptyset\\
\\
\left({\displaystyle \binom{|U_{x}|}{|P_{x}|}}\right) & \text{if }R_{x}=\emptyset
\end{cases}
\end{equation}

\end_inset

By combining mupltiple position-classes, one arrives at the total number
 of candidate cuttings
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula 
\begin{equation}
\prod_{_{x=1}}^{m}z(P_{x},U_{x},R_{x})\ .\label{amorf-cand-eq}
\end{equation}

\end_inset


\end_layout

\begin_layout Example
\begin_inset CommandInset label
LatexCommand label
name "automorf-ex1"

\end_inset

Let 
\begin_inset Formula $p=4$
\end_inset

, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $d=3$
\end_inset

 and the partial solution 
\begin_inset Formula $\hat{s}$
\end_inset

 assigns two keys: 
\begin_inset Formula $\hat{s}(k_{1})=(1,1,1,1)$
\end_inset

 and 
\begin_inset Formula $\hat{s}(k_{2})=(1,1,1,2)$
\end_inset

.
 Which candidate cuttings are there for 
\begin_inset Formula $k_{3}$
\end_inset

?
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 The first three positions have the same depth.
 Hence 
\begin_inset Formula $P_{1}=\{1,2,3\}$
\end_inset

 and 
\begin_inset Formula $P_{2}=\{2\}$
\end_inset

.
 On positions from 
\begin_inset Formula $P_{1}$
\end_inset

 only the cutting depth 
\begin_inset Formula $1$
\end_inset

 has been used: 
\begin_inset Formula $U_{1}=\{1\}$
\end_inset

 and 
\begin_inset Formula $R_{1}=\{2,3\}$
\end_inset

.
 In 
\begin_inset Formula $P_{2}$
\end_inset

 two cutting depths were used: 
\begin_inset Formula $U_{2}=\{1,2\}$
\end_inset

 and 
\begin_inset Formula $R_{2}=\{3\}$
\end_inset

.
 We expect
\begin_inset Formula 
\[
\prod_{_{x=1}}^{m}z(P_{x},U_{x},R_{x})=\prod_{_{x=1}}^{m}\binom{|P_{x}|+|U_{x}|}{|P_{x}|}=\binom{3+1}{3}\cdot\binom{1+2}{1}=12
\]

\end_inset

candidate cuttings to be generated (by using 
\begin_inset Formula $\left(\binom{n}{k}\right)=\binom{n+k-1}{k}$
\end_inset

 and 
\begin_inset Formula $R_{x}\neq\emptyset$
\end_inset

).
 The class 
\begin_inset Formula $P_{1}$
\end_inset

 generates 4 “partial” cuttings 
\begin_inset Formula $(1,1,1,*)$
\end_inset

, 
\begin_inset Formula $(1,1,2,*)$
\end_inset

, 
\begin_inset Formula $(1,2,2,*)$
\end_inset

 and 
\begin_inset Formula $(2,2,2,*)$
\end_inset

.
 The class 
\begin_inset Formula $P_{2}$
\end_inset

 generates 
\begin_inset Formula $(*,*,*,1)$
\end_inset

, 
\begin_inset Formula $(*,*,*,2)$
\end_inset

 and 
\begin_inset Formula $(*,*,*,3)$
\end_inset

.
 Their product is indeed 12 cuttings:
\begin_inset Formula 
\[
\begin{array}{cccc}
(1,1,1,1) & (1,1,2,1) & (1,2,2,1) & (2,2,2,1)\\
(1,1,1,2) & (1,1,2,2) & (1,2,2,2) & (2,2,2,2)\\
(1,1,1,3) & (1,1,2,3) & (1,2,2,3) & (2,2,2,3)
\end{array}
\]

\end_inset


\end_layout

\begin_layout Paragraph
Modifying the DFS algorithm.
\end_layout

\begin_layout Standard
A straightforward application of Lawer's algorithm is to modify line
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{val-heur-line}
\end_layout

\end_inset

 of Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "dfs-algorithm"

\end_inset

 by adding two lines of code: 1) compute 
\begin_inset Formula $P$
\end_inset

 and 
\begin_inset Formula $u$
\end_inset

 from a partial solution 
\begin_inset Formula $\hat{s}$
\end_inset

 and 2) generate all candidate cuttings.
 However, the first step might be implemented more efficiently.
\end_layout

\begin_layout Standard
Given the freshly assigned cutting 
\begin_inset Formula $\gamma$
\end_inset

, the isomorphism group 
\begin_inset Formula $P,u$
\end_inset

 can be “updated” more quickly just before passing the updated isomorphisms
 into the recursive call on line
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{recursion-line}
\end_layout

\end_inset

.
 Here we describe how to calculate the updated 
\begin_inset Formula $P',u',r'$
\end_inset

 from 
\begin_inset Formula $P,u,r$
\end_inset

 and 
\begin_inset Formula $\gamma$
\end_inset

.
\end_layout

\begin_layout Standard
Initialisation is simple.
 Since an empty partial solution 
\begin_inset Formula $\hat{s}=\emptyset$
\end_inset

 defines no cuttings, all positions are equal and no cutting depth has been
 used: 
\begin_inset Formula $P=\{\{1,\ldots,p\}\}$
\end_inset

 and 
\begin_inset Formula $u(\{1,\ldots,p\})=\emptyset$
\end_inset

.
\end_layout

\begin_layout Standard
The update function will be defined concisely using the following notion.
 Let 
\begin_inset Formula $\gamma=(d_{1},\ldots,d_{p})$
\end_inset

.
 The 
\emph on
cutting-based partition
\emph default
 
\begin_inset Formula $Q^{\gamma}$
\end_inset

 is a partitioning of positions into 
\begin_inset Formula $y$
\end_inset

 classes s.t.
 positions 
\begin_inset Formula $i$
\end_inset

 and 
\begin_inset Formula $j$
\end_inset

 are in the same class 
\begin_inset Formula $i,j\in Q_{y}^{\gamma}$
\end_inset

 if and only if 
\begin_inset Formula $d_{i}=d_{j}$
\end_inset

.
 For example the cutting 
\begin_inset Formula $\gamma=(1,1,1,2)$
\end_inset

 is associated with 
\begin_inset Formula $Q^{(1,1,1,2)}=\{\{1,2,3\},\{4\}\}$
\end_inset

.
\end_layout

\begin_layout Standard
Let there be 
\begin_inset Formula $m$
\end_inset

 position-classes 
\begin_inset Formula $P=P_{1},\ldots,P_{m}$
\end_inset

 and 
\begin_inset Formula $n$
\end_inset

 cutting-based classes 
\begin_inset Formula $Q^{\gamma}=\{Q_{1}^{\gamma},\ldots,Q_{n}^{\gamma}\}$
\end_inset

.
 Then the updated partition is
\begin_inset Formula 
\begin{equation}
\begin{array}{cccccc}
P'=\{ & P_{1}\cap Q_{1}^{\gamma}, & P_{1}\cap Q_{2}^{\gamma}, & \cdots, & P_{1}\cap Q_{n}^{\gamma},\\
 & P_{2}\cap Q_{1}^{\gamma}, & P_{2}\cap Q_{2}^{\gamma}, & \cdots, & P_{2}\cap Q_{n}^{\gamma},\\
 & \vdots, & \vdots, & \ddots, & \vdots,\\
 & P_{m}\cap Q_{1}^{\gamma}, & P_{m}\cap Q_{2}^{\gamma}, & \cdots, & P_{m}\cap Q_{n}^{\gamma} & \}\ .
\end{array}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Function 
\begin_inset Formula $u$
\end_inset

 is updated as follows.
 Let 
\begin_inset Formula $Q_{y}^{\gamma}$
\end_inset

 contain positions, where cutting 
\begin_inset Formula $\gamma$
\end_inset

 has depth 
\begin_inset Formula $d_{i}$
\end_inset

.
 The updated mapping adds depth 
\begin_inset Formula $d_{i}$
\end_inset

 to the set of used depths 
\begin_inset Formula $u(P_{x})$
\end_inset

:
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula 
\[
u'(P_{x}\cap Q_{y}^{\gamma})=u(P_{x})\cup\{d_{i}\}\text{ .}
\]

\end_inset


\end_layout

\begin_layout Example
Let 
\begin_inset Formula $p=4$
\end_inset

, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $d=3$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.
 Isomorphism on positions is initialised to 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $P=\{\{1,2,3,4\}\}$
\end_inset

.
 The only class of positions has depth isomorphism defined by 
\begin_inset Formula $u(\{1,2,3,4\})=\emptyset$
\end_inset

.
 The first key has only 
\begin_inset Formula $\binom{4+0}{4}=1$
\end_inset

 candidate cutting, namely 
\begin_inset Formula $(1,1,1,1)$
\end_inset

.
 Let's proceed to the second key.

\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 Since 
\begin_inset Formula $Q^{(1,1,1,1)}=\{\{1,2,3,4\}\}$
\end_inset

 has only one class, 
\begin_inset Formula $P$
\end_inset

 remains unchanged.
 By moving depth 
\begin_inset Formula $1$
\end_inset

 from 
\begin_inset Formula $R$
\end_inset

 to 
\begin_inset Formula $U$
\end_inset

, the only class of positions becomes mapped as 
\begin_inset Formula $u(\{1,2,3,4\})=\{1\}$
\end_inset

.
 Consequently, the next key has 
\begin_inset Formula $\binom{4+1}{4}$
\end_inset

 candidate cuttings.
 Indeed, there are 
\begin_inset Formula $5$
\end_inset

 combinations with repetitions of cutting depths 
\begin_inset Formula $\{1,2\}$
\end_inset

 to be assigned to all 4 positions: 
\begin_inset Formula $(1,1,1,1)$
\end_inset

, 
\begin_inset Formula $(1,1,1,2)$
\end_inset

, 
\begin_inset Formula $(1,1,2,2)$
\end_inset

, 
\begin_inset Formula $(1,2,2,2)$
\end_inset

 and 
\begin_inset Formula $(2,2,2,2)$
\end_inset

.
\end_layout

\begin_layout Example
Let's assume 
\begin_inset Formula $(1,1,1,2)$
\end_inset

 was picked.
 Since 
\begin_inset Formula $Q^{(1,1,1,2)}=\{\{1,2,3\},\{4\}\}$
\end_inset

, the partitioning 
\begin_inset Formula $P$
\end_inset

 is updated to 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\{\{1,2,3\},\{4\}\}$
\end_inset

.
 The first class 
\begin_inset Formula $P_{1}=\{1,2,3\}$
\end_inset

 is still mapped to 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit

\begin_inset Formula $u(P_{1})=\{1\}$
\end_inset

, because on these positions, the only used cutting depth is 
\begin_inset Formula $1$
\end_inset

.
 The second class 
\begin_inset Formula $P_{2}=\{4\}$
\end_inset

 becomes mapped to 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $u(P_{2})=\{1,2\}$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.
 The automorphism is now exactly same as in Example
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "automorf-ex1"

\end_inset

 and the third key can has 
\begin_inset Formula $12$
\end_inset

 candidate cuttings.
\end_layout

\begin_layout Standard
The example illustrates something we consider a “killer feature” of Lawer's
 automorphisms.
 In a diagonal lock-chart, the first key is the general key, which always
 gets only 1 candidate cutting.
 This is in line with Lemma
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "diagonal-sq-size-lemma"

\end_inset

, which can be summarised as: “In the vanilla framework, the cutting of
 the general key is irrelevant”.
 For the first individual key, it attempts to assign exactly 1 candidate
 from every 
\begin_inset Formula $S_{q}$
\end_inset

 set.
\end_layout

\begin_layout Paragraph
Other frameworks.
\end_layout

\begin_layout Standard
The automorphisms are defined for the vanilla framework.
 An extension to the asymmetric framework is straightforward.
 If the deepest cutting is 
\begin_inset Formula $(\tilde{d}_{1},\ldots,\tilde{d}_{p})$
\end_inset

, the position-classes can be initialised to 
\begin_inset Formula $P=Q^{(\tilde{d}_{1},\ldots,\tilde{d}_{p})}$
\end_inset

.
 Like this, the symmetries between positions with a different number of
 available cutting depths is broken but retained for positions with an equal
 number of available cutting depths.
 An extension to the explicit framework is hard to imagine (see the brute-force
 experiment above).
 What about the general framework?
\end_layout

\begin_layout Standard
Let us sketch an idea.
 Suppose there is a graph with vertices 
\begin_inset Formula $(p,d)\in\{1,\ldots,p\}\times\{1,\ldots d\}$
\end_inset

.
 It may be possible to translate gecons into edges of this graph so that
 
\begin_inset Formula $(p,d)$
\end_inset

 and 
\begin_inset Formula $(p,d')$
\end_inset

 appear in the same partition class precisely if cutting depths 
\begin_inset Formula $d$
\end_inset

 and 
\begin_inset Formula $d'$
\end_inset

 are interchangeable on position 
\begin_inset Formula $p$
\end_inset

.
 How to formalise it precisely? Is finding automorphisms on a graph with
 
\begin_inset Formula $p\cdot d$
\end_inset

 vertices doable in a reasonable amount of time? Moreover, will the automorphism
s be large enough save enough backtracker's runtime? The answers need further
 research and empirical evaluation.
\end_layout

\begin_layout Section
Constraint satisfaction
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "csp-sec"

\end_inset


\end_layout

\begin_layout Standard
In this section, the lock-chart solving problem is formulated as a 
\emph on
constraint satisfaction problem
\emph default
 (CSP) and a pruning scheme is provided.
 The modified algorithm keeps a list of suitable cuttings for every key
 called a 
\emph on
scope
\emph default
.
 By deleting “obviously unsuitable” cuttings from the scopes, one may arrive
 at a partial solution with less suitable cuttings that the number of unassigned
 keys.
 This idea is known as 
\emph on
all-different pruning
\emph default
 
\begin_inset CommandInset citation
LatexCommand citep
before "Based on"
key "rossi2006"

\end_inset

 and allows a backtracker to skip huge parts of the search space by modifying
 line
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{persp-line}
\end_layout

\end_inset

 of Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "dfs-algorithm"

\end_inset

.
\end_layout

\begin_layout Standard
As the scope keeps a set of cuttings, we assume that one can iterate over
 
\begin_inset Formula $S$
\end_inset

.
 Hence, the CSP is formulated for the explicit framework.
\end_layout

\begin_layout Paragraph
Preliminaries.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $D$
\end_inset

 be a set called the 
\emph on
domain
\emph default
 and 
\begin_inset Formula $X$
\end_inset

 a set of 
\emph on
variables
\emph default
.

\emph on
 
\emph default
A 
\emph on
constraint
\emph default
 is a pair 
\begin_inset Formula $(\Sigma,R)$
\end_inset

, where 
\begin_inset Formula $\Sigma\subseteq X$
\end_inset

 is its 
\emph on
signature
\emph default
 (whose members will be denoted as 
\begin_inset Formula $\sigma_{1},\sigma_{2},\ldots$
\end_inset

) and 
\begin_inset Formula $R$
\end_inset

 a relation on 
\begin_inset Formula $D$
\end_inset

 of arity 
\begin_inset Formula $|\Sigma|$
\end_inset

.
 A 
\emph on
constraint satisfaction problem
\emph default
 (CSP) is a tuple 
\begin_inset Formula $(D,X,C)$
\end_inset

, where 
\begin_inset Formula $C$
\end_inset

 is a set of constraints.
\end_layout

\begin_layout Standard
A 
\emph on
solution
\emph default
 to a CSP is a function 
\begin_inset Formula $s:\,X\rightarrow D$
\end_inset

, s.t.
 for all constraints 
\begin_inset Formula $(\{\sigma_{1},\ldots,\sigma_{m}\},R)$
\end_inset

, the vector of solutions satisfies 
\begin_inset Formula 
\[
\left(s(\sigma_{1}),\ldots,s(\sigma_{m})\right)\in R\ .
\]

\end_inset

A solution is called 
\emph on
partial
\emph default
 if 
\begin_inset Formula $s$
\end_inset

 is a partial function.
 The 
\emph on
domain function
\emph default
 
\begin_inset Formula $\delta:\,K\rightarrow2^{S}$
\end_inset

 assigns each variable a 
\emph on
scope.
\end_layout

\begin_layout Paragraph
Lock-chart CSP.
\end_layout

\begin_layout Standard
The lock-chart problem will be reformulated as a CSP.
 The CSP instance will have one variable for each key, code space as the
 domain and one constraint for every blocking cell in the lock-chart.
\end_layout

\begin_layout Definition
\begin_inset CommandInset label
LatexCommand label
name "lc-csp-def"

\end_inset

Let 
\begin_inset Formula $(K,L,E)$
\end_inset

 be a lock-chart and 
\begin_inset Formula $S$
\end_inset

 the code space.
 The 
\begin_inset Formula $(S,K,C)$
\end_inset

 is a CSP if for every 
\begin_inset Formula $k\in K$
\end_inset

, 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $l\in L$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 s.t.
 
\begin_inset Formula $(k,l)\not\in E$
\end_inset

, there is one constraint 
\begin_inset Formula $(\{k\}\cup E(l),R_{k,l})\in C$
\end_inset

, where 
\begin_inset Formula $R_{k,l}=$
\end_inset


\begin_inset Formula 
\begin{equation}
\left\{ (\gamma_{0},\gamma_{1},\ldots,\gamma_{|E(l)|})\in S{}^{|E(l)|}\middle|\gamma_{1}\cup\cdots\cup\gamma_{|E(l)|}\text{ blocks }\gamma_{0}\right\} .\label{lc-csp-eq}
\end{equation}

\end_inset


\end_layout

\begin_layout Remark
Let 
\begin_inset Formula $(K,L,E)$
\end_inset

 be a lock-chart, 
\begin_inset Formula $S$
\end_inset

 the code space and 
\begin_inset Formula $(S,K,C)$
\end_inset

 the CSP from Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lc-csp-def"

\end_inset

.
 A solution 
\begin_inset Formula $s$
\end_inset

 to 
\begin_inset Formula $(S,K,C)$
\end_inset

 is a solution to the lock-chart 
\begin_inset Formula $(K,L,E)$
\end_inset

.
\end_layout

\begin_layout Proof
By definition, CSP's solution 
\begin_inset Formula $s$
\end_inset

 is an assignment.
 Let 
\begin_inset Formula $k\in K$
\end_inset

, 
\begin_inset Formula $l\in L$
\end_inset

.
 Proposition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "least-cut-prop"

\end_inset

 ensures that if 
\begin_inset Formula $(k,l)\in E$
\end_inset

, then 
\begin_inset Formula $s(k)$
\end_inset

 enters 
\begin_inset Formula $s(l)$
\end_inset

.
 Consider the 
\begin_inset Formula $(k,l)\not\in E$
\end_inset

 case.
 Since 
\begin_inset Formula $s$
\end_inset

 is a solution to the CSP, there must be 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula 
\[
(\gamma_{0},\gamma_{1},\ldots,\gamma_{|E(l)|})\in R_{k,l}\ .
\]

\end_inset

By (
\begin_inset CommandInset ref
LatexCommand ref
reference "lc-csp-eq"

\end_inset

) 
\begin_inset Formula $\gamma_{0}$
\end_inset

 is blocked in 
\begin_inset Formula $\gamma_{1}\cup\cdots\cup\gamma_{|E(l)|}$
\end_inset

.
 Since 
\begin_inset Formula $\gamma_{0}=s(k)$
\end_inset

 and 
\begin_inset Formula $\gamma_{1}\cup\cdots\cup\gamma_{|E(l)|}=s(l)$
\end_inset

, then 
\begin_inset Formula $s(k)$
\end_inset

 is blocked in 
\begin_inset Formula $s(l)$
\end_inset

.
 By checking all 
\begin_inset Formula $k,l$
\end_inset

, all cells in the lock-chart are satisfied.
\end_layout

\begin_layout Standard
The largest relation has 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $|S|^{1+\max_{l}|E(l)|}$
\end_inset

 tuples, which is too much for storing all relations in memory
\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
.
 Instead, there is Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "csp-prune-alg"

\end_inset

, which provides a pruning algorithm tailored for the lock-chart CSPs and
 which does not store relations explicitly.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LinesNumbered
\end_layout

\begin_layout Plain Layout


\backslash
DontPrintSemicolon
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{Input}{input}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{Output}{output}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{Requires}{requires}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{Ensures}{ensures}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{Assume}{assume}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{FakeForAlignment}{requiress}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{Null}{null}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{Prune}{prune}
\end_layout

\begin_layout Plain Layout


\backslash
SetKw{Continue}{continue}
\end_layout

\begin_layout Plain Layout


\backslash
SetKw{Throw}{throw}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{Function}{
\backslash
string:}{}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
Fn(){$
\backslash
delta=$ 
\backslash
Prune{$(K, L, E)$, $
\backslash
hat{s}: K 
\backslash
rightharpoonup S$} }{
\end_layout

\begin_layout Plain Layout

  
\backslash
Input{a lock-chart and its partial solution $
\backslash
hat{s}$}
\end_layout

\begin_layout Plain Layout

  
\backslash
Output{domain function $
\backslash
delta:
\backslash
,K 
\backslash
rightarrow 2^S$}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  let $
\backslash
delta 
\backslash
leftarrow$ array of size $|K|$, all cells filled with $S$, for convenience
 indexed by keys 
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
BlankLine
\end_layout

\begin_layout Plain Layout

  
\backslash
For(){$l 
\backslash
in L$}{
\end_layout

\begin_layout Plain Layout

    $
\backslash
Gamma 
\backslash
leftarrow 
\backslash
text{cuttings that enter }
\backslash
hat{s}(l)$
\backslash
; 
\end_layout

\begin_layout Plain Layout

    
\backslash
tcc*[h]{
\backslash
textrm{$
\backslash
Gamma$ will never be blocked in any extension of $
\backslash
hat{s}$.}} 
\backslash
;
\end_layout

\begin_layout Plain Layout

    
\backslash
For(){$k 
\backslash
not
\backslash
in E(l)$}{
\end_layout

\begin_layout Plain Layout

      remove $
\backslash
Gamma$ from $
\backslash
delta(k)$
\backslash
;
\backslash
label{line:pruning1}
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
BlankLine
\end_layout

\begin_layout Plain Layout

  
\backslash
For(){$l 
\backslash
in L$}{
\end_layout

\begin_layout Plain Layout

    $
\backslash
Gamma 
\backslash
leftarrow 
\backslash
emptyset$
\backslash
;
\end_layout

\begin_layout Plain Layout

    
\backslash
For(){$
\backslash
gamma 
\backslash
in S$}{	
\end_layout

\begin_layout Plain Layout

      
\backslash
tcc*[h]{
\backslash
textrm{Simulate adding $
\backslash
gamma$ into $
\backslash
hat{s}(l)$ and
\end_layout

\begin_layout Plain Layout

        find keys already assigned in $
\backslash
hat{s}$ that should be blocked by $l$.}}
\backslash
;
\end_layout

\begin_layout Plain Layout

      $
\backslash
lambda 
\backslash
leftarrow s(l) 
\backslash
cup 
\backslash
gamma$
\backslash
;
\backslash
label{line:addcut}
\end_layout

\begin_layout Plain Layout

      
\backslash
For(){$k 
\backslash
not
\backslash
in E(l)$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
If{$k
\backslash
text{ is assigned by }
\backslash
hat{s}
\backslash
text{ and }
\end_layout

\begin_layout Plain Layout

             
\backslash
hat{s}(k)
\backslash
text{ enters }
\backslash
lambda$}{
\backslash
label{line:lambaentered}
\end_layout

\begin_layout Plain Layout

          add $
\backslash
gamma$ to $
\backslash
Gamma$
\backslash
;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

    
\backslash
tcc*[h]{
\backslash
textrm{$
\backslash
Gamma$ contains cuttings
\end_layout

\begin_layout Plain Layout

      that violate some already established blocking
\end_layout

\begin_layout Plain Layout

      in $
\backslash
hat{s}(l)$.
 Never use them for keys that open $l$.}}
\backslash
;
\end_layout

\begin_layout Plain Layout

    
\backslash
For(){$k 
\backslash
in E(l)$}{
\end_layout

\begin_layout Plain Layout

      remove $
\backslash
Gamma$ from $
\backslash
delta(k)$
\backslash
;
\backslash
label{line:pruning2}
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\backslash
Return $
\backslash
delta$
\backslash
;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Domain pruning for a CSP
\end_layout

\end_inset

The domain pruning algorithm for a CSP in the explicit framework.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "csp-prune-alg"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The pruning algorithm provides a guarantee: If 
\begin_inset Formula $\hat{s}$
\end_inset

 was a solution and 
\begin_inset Formula $\gamma\in\delta(k)$
\end_inset

, then by assigning 
\begin_inset Formula $\gamma$
\end_inset

 to a unassigned key 
\begin_inset Formula $k$
\end_inset

, the assignment 
\begin_inset Formula $\hat{s}\cup(k,\gamma)$
\end_inset

 is a solution.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "lem:consistency"

\end_inset


\begin_inset Argument 1
status open

\begin_layout Plain Layout
Consistency
\end_layout

\end_inset

Let 
\begin_inset Formula $(K,L,E)$
\end_inset

 be a lock-chart, 
\begin_inset Formula $\hat{s}$
\end_inset

 a partial solution that assigns cuttings keys from a set 
\begin_inset Formula $K'\subseteq K$
\end_inset

 and 
\begin_inset Formula 
\[
\delta=\mathtt{prune(}(K,L,E),\hat{s}\mathtt{)}\ .
\]

\end_inset

Assume that for any 
\begin_inset Formula $\gamma,\gamma'\in S$
\end_inset

, the cylinder 
\begin_inset Formula $\gamma\cup\gamma'$
\end_inset

 blocks some cuttings from 
\begin_inset Formula $S$
\end_inset

.
 Then for every constraint 
\begin_inset Formula $(\{k_{0},k_{1},\ldots,k_{|E(l)|}\},R_{k_{0},l})$
\end_inset

, for every key 
\begin_inset Formula $k_{i}$
\end_inset

 in its signature, for every cutting 
\begin_inset Formula $\gamma_{i}\in\delta(k_{i})$
\end_inset

, there is a tuple 
\begin_inset Formula $(\gamma_{0},\gamma_{1},\ldots,\gamma_{|E(l)|})\in R_{k,l}$
\end_inset

 s.t.
\begin_inset Formula 
\[
\text{if }k_{j}\in K'\text{ then }\gamma_{j}=\hat{s}(k_{j}).
\]

\end_inset


\end_layout

\begin_layout Proof
a) 
\begin_inset Formula $i=0$
\end_inset

: Given 
\begin_inset Formula $k_{j}\in K'$
\end_inset

 then all locks 
\begin_inset Formula $E(k_{j})$
\end_inset

 contain shear-lines induced by 
\begin_inset Formula $\hat{s}(k_{j})$
\end_inset

.
 On line
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{line:pruning1}
\end_layout

\end_inset

 the pruner removes such shear-lines from the domain of a blocked key 
\begin_inset Formula $k_{0}$
\end_inset

 and therefore 
\begin_inset Formula $\gamma{}_{0}\not\in\hat{s}(k_{0})$
\end_inset

.
\end_layout

\begin_layout Proof
b) 
\begin_inset Formula $i\geq1$
\end_inset

, 
\begin_inset Formula $j=0$
\end_inset

: The state, when 
\begin_inset Formula $k_{0}$
\end_inset

 is blocked in 
\begin_inset Formula $l$
\end_inset

 and 
\begin_inset Formula $k_{0}\in K'$
\end_inset

 is checked on line
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{line:lambaentered}
\end_layout

\end_inset

.
 If assigning 
\begin_inset Formula $\gamma_{i}$
\end_inset

 to 
\begin_inset Formula $k_{i}$
\end_inset

 breaks this blocking, 
\begin_inset Formula $\gamma_{i}$
\end_inset

 is removed from 
\begin_inset Formula $\delta(k_{i})$
\end_inset

 on line
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{line:pruning2}
\end_layout

\end_inset

.
\end_layout

\begin_layout Proof
c) 
\begin_inset Formula $i\geq1$
\end_inset

, 
\begin_inset Formula $j\geq1$
\end_inset

.
 Values in 
\begin_inset Formula $1,\ldots,|E(l)|$
\end_inset

 columns come from the cartesian product 
\begin_inset Formula $S^{|E(l)|}$
\end_inset

.
 Since cylinder 
\begin_inset Formula $\gamma\cup\gamma'$
\end_inset

 blocks some other cutting, there must be a candidate for 
\begin_inset Formula $\gamma_{0}$
\end_inset

.
 Therefore the tuple with 
\begin_inset Formula $\gamma_{j}$
\end_inset

 is in 
\begin_inset Formula $R_{k,l}$
\end_inset

.
\end_layout

\begin_layout Standard
Note this is a weaker consistency than 
\emph on
generalised arc-consistency
\emph default
 
\begin_inset CommandInset citation
LatexCommand citep
key "mackworth1977maps"

\end_inset

.
 GAC would replace the 
\begin_inset Quotes eld
\end_inset

if 
\begin_inset Formula $k_{j}\in K'$
\end_inset

 then 
\begin_inset Formula $\gamma_{j}=s(k_{j})$
\end_inset


\begin_inset Quotes erd
\end_inset

 by a stronger condition 
\begin_inset Quotes eld
\end_inset

if 
\begin_inset Formula $k_{j}\in K$
\end_inset

 then
\begin_inset Formula $\gamma_{j}\in\delta(k_{j})$
\end_inset


\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Paragraph
All-different pruning.
\end_layout

\begin_layout Standard
Next, we add a pruning scheme for an early detection of non-perspective
 partial solutions.
 Proposition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "distinct-cor"

\end_inset

 ensures that all keys must be assigned different key cuttings, which allows
 to impose the 
\emph on
all-different constraint
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "rossi2006"

\end_inset

 on 
\begin_inset Formula $K$
\end_inset

.
 Instead of the pruning algorithm based on bipartite matching 
\begin_inset CommandInset citation
LatexCommand cite
key "rossi2006"

\end_inset

, here we use a simpler technique which achieves a weaker consistency.
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula $\delta=\texttt{prune(}(K,L,E),\hat{s}\texttt{)}$
\end_inset

, 
\begin_inset Formula $K'$
\end_inset

 be any subset of 
\begin_inset Formula $K$
\end_inset

 and
\begin_inset Formula 
\begin{equation}
\Delta=\bigcup_{k\in K'}\delta(k)
\end{equation}

\end_inset

be the union cuttings in their scopes.
 Next, every complete solution 
\begin_inset Formula $s\supseteq\hat{s}$
\end_inset

 (which extends 
\begin_inset Formula $\hat{s}$
\end_inset

) must assign all keys 
\begin_inset Formula $K'$
\end_inset

.
 Such keys will never be assigned cuttings outside 
\begin_inset Formula $\Delta$
\end_inset

.
 Therefore, by the pidgeon-hole principle, there must be at least as many
 cuttings as there are keys
\begin_inset Formula 
\begin{equation}
|\Delta|\geq|K'|\ .\label{alldifferent-requirement-equation}
\end{equation}

\end_inset

If this formula does not hold, the partial solution 
\begin_inset Formula $\hat{s}$
\end_inset

 can never be extended to a complete correct solution.
\end_layout

\begin_layout Standard
Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "csp-alld-alg"

\end_inset

 is a fast test that attempts to find 
\begin_inset Formula $K'$
\end_inset

 which violates the formula.
 It adds scopes of keys to a set 
\begin_inset Formula $\Delta$
\end_inset

, one-by-one.
 If 
\begin_inset Formula $\Delta$
\end_inset

 is too small and too many scopes have been added, the algorithm returns
 
\family typewriter
false
\family default
.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LinesNumbered
\end_layout

\begin_layout Plain Layout


\backslash
DontPrintSemicolon
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{Input}{input}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{Output}{output}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{Null}{null}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{True}{true}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{False}{false}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{Prune}{prune}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{Perspective}{perspective}
\end_layout

\begin_layout Plain Layout


\backslash
SetKw{Continue}{continue}
\end_layout

\begin_layout Plain Layout


\backslash
SetKw{Throw}{throw}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{Function}{
\backslash
string:}{}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
Fn(){
\backslash
Perspective{$
\backslash
delta$}}{
\end_layout

\begin_layout Plain Layout

  
\backslash
Input{a scope function $
\backslash
delta:
\backslash
,K 
\backslash
rightarrow 2^S$}
\end_layout

\begin_layout Plain Layout

  
\backslash
Output{$
\backslash
True$ if it finds a $K' 
\backslash
subseteq K$ s.t.
 $|
\backslash
Delta|<|K'|$}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
BlankLine
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  let $
\backslash
Delta$ be a set of cuttings
\backslash
;
\end_layout

\begin_layout Plain Layout

  let $K$ be an array of keys
\backslash
;
\end_layout

\begin_layout Plain Layout

  sort $K$ by $|
\backslash
delta(k)|$ in ascending order
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  initialise $
\backslash
Delta = 
\backslash
emptyset$
\backslash
;
\end_layout

\begin_layout Plain Layout

  
\backslash
For(){$i 
\backslash
in 
\backslash
{1,
\backslash
ldots, |K|
\backslash
}$}{
\end_layout

\begin_layout Plain Layout

    $
\backslash
Delta 
\backslash
leftarrow 
\backslash
Delta 
\backslash
cup 
\backslash
delta(k_i)$
\backslash
;
\end_layout

\begin_layout Plain Layout

    
\backslash
If{$|
\backslash
Delta| < i$}{
\end_layout

\begin_layout Plain Layout

      
\backslash
Return $
\backslash
False$
\backslash
;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\backslash
Return $
\backslash
True$
\backslash
;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
All-different pruning for a CSP
\end_layout

\end_inset

Simplified all-different pruner for the CSP bactracker.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "csp-alld-alg"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, let constrcut a full CSP backtracking algorithm from ideas in this
 section.
 The skeleton copies Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "dfs-algorithm"

\end_inset

 with the following modifications:
\end_layout

\begin_layout Itemize
On line
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{val-heur-line}
\end_layout

\end_inset

, the scopes are calculated by calling 
\begin_inset Formula $\texttt{prune}$
\end_inset

.
 Candidate cuttings for key 
\begin_inset Formula $k$
\end_inset

 are taken from 
\begin_inset Formula $\delta(k)$
\end_inset

.
\end_layout

\begin_layout Itemize
On line
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{persp-line}
\end_layout

\end_inset

, a partial solution is not considered perspective if 
\begin_inset Formula $\texttt{perspective(}(K,L,E),\hat{s}'\texttt{)}$
\end_inset

 returns 
\family typewriter
false
\family default
.
\end_layout

\begin_layout Section
Implicit domains
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "impli-sec"

\end_inset


\end_layout

\begin_layout Standard
The last algorithm builds upon an empirical observation.
 When executed on real-world datasets, the 
\family typewriter
perspective(
\begin_inset Formula $\delta$
\end_inset

)
\family default
 procedure usually returned 
\family typewriter
false
\family default
 only if the set 
\begin_inset Formula $K'$
\end_inset

 consisted of individual keys.
 This section formulates a different pruning algorithm tailored specifically
 for individual keys.
 Its advantage over the previous CSP approach is that it works in the general
 framework and hence it can handle larger code spaces.
\end_layout

\begin_layout Paragraph
Template lock-charts.
\end_layout

\begin_layout Standard
The backtracker keeps track of the available code space for individual keys.
 For a succinct notation, let's assume that the backtracker always solves
 a template lock-chart 
\begin_inset Formula $(M,G,F)$
\end_inset

 with an expansion function 
\begin_inset Formula $e:\,G\rightarrow\mathbb{N}$
\end_inset

 (see Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "template-definition"

\end_inset

).
 Keys in 
\begin_inset Formula $M$
\end_inset

 represent master keys 
\begin_inset Formula $k_{1},\ldots,k_{m}$
\end_inset

 and locks 
\begin_inset Formula $g_{1},\ldots,g_{n}$
\end_inset

 will be called 
\emph on
groups
\emph default
.
 The lock-chart 
\begin_inset Formula $(K,L,E)$
\end_inset

, which actually enters Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "dfs-algorithm"

\end_inset

, will be the the expansion of this template.
 Keys 
\begin_inset Formula $K$
\end_inset

 in the expansion will be denoted
\begin_inset Formula 
\begin{equation}
K=\{k_{1},\ldots,k_{m},\overbrace{k_{1}^{1},\ldots,k_{1}^{e(g_{1})}}^{\text{expansion of }g_{1}},\ldots,\overbrace{k_{n}^{1},\ldots,k_{n}^{g_{n}}}^{\text{expansion of }g_{n}}\}\ .\label{implicit-template-keys}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Since master keys 
\begin_inset Formula $k_{1},\ldots,k_{m}$
\end_inset

 appear both in the template and the expansion (
\begin_inset Formula $M\subseteq K$
\end_inset

), any partial solution 
\begin_inset Formula $\hat{s}$
\end_inset

 associated with the expansion lock-chart also prescribes cuttings for the
 template lock-chart.
\end_layout

\begin_layout Standard
Assume further that on line
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{var-heur-line}
\end_layout

\end_inset

 of Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "dfs-algorithm"

\end_inset

 keys are picked in the same order as they appear in (
\begin_inset CommandInset ref
LatexCommand ref
reference "implicit-template-keys"

\end_inset

).
 Consequently, master keys will be assigned before individual keys from
 the first group 
\begin_inset Formula $g_{1}$
\end_inset

.
 Only after that, the keys in other groups will be assigned.
\end_layout

\begin_layout Paragraph
Pruning scheme.
\end_layout

\begin_layout Standard
The proposed pruning scheme checks if there are enough cuttings for individual
 keys in each group.
 We are aiming at reusing the 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none

\begin_inset Formula $\bar{\Gamma}(q,E,\{B_{1},\ldots,B_{n}\})$
\end_inset


\family default
\series default
\shape default
\size default
\emph default
\bar default
\strikeout default
\uuline default
\uwave default
\noun default
\color inherit
 procedure for counting cuttings and comparing its size with 
\begin_inset Formula $e(g_{i})$
\end_inset

.
 The procedure will be invoked when assigning the first individual key 
\begin_inset Formula $k_{i}^{1}$
\end_inset

 from group 
\begin_inset Formula $g_{i}$
\end_inset

.
 Before stating a similar inequality to (
\begin_inset CommandInset ref
LatexCommand ref
reference "alldifferent-requirement-equation"

\end_inset

), which justifies the pruning, let's define arguments 
\begin_inset Formula $q$
\end_inset

, 
\begin_inset Formula $E$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

s.
\end_layout

\begin_layout Standard
Natural candidates for cylinders 
\begin_inset Formula $B$
\end_inset

 are universal cylinders (see Lemma
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "universal-cylinder-lemma"

\end_inset

) created from gecons in the general framework (see Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "gecon-def"

\end_inset

).
 All cuttings must these gecons, obviously including cuttings assigned to
 individual keys.
 Let's call such cylinders the 
\begin_inset Formula $B$
\end_inset

 cylinders of
\begin_inset space ~
\end_inset

type
\begin_inset space ~
\end_inset

0.
\end_layout

\begin_layout Standard
Next, all blocking constraints in the lock-chart are translated to 
\begin_inset Formula $B$
\end_inset

 cylinders of types 1 and 2.
 We start with cylinders of type
\begin_inset space ~
\end_inset

1, which ensure that a newly assigned cutting is blocked in all relevant
 cylinders.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "implicit-B1-lemma"

\end_inset

Let 
\begin_inset Formula $(K,L,E)$
\end_inset

 be the expansion s.t.
 
\begin_inset Formula $K$
\end_inset

 is indexed as in
\emph on
 (
\begin_inset CommandInset ref
LatexCommand ref
reference "implicit-template-keys"

\end_inset

)
\emph default
 and 
\begin_inset Formula $\hat{s}$
\end_inset

 its partial solution.
 If an individual key 
\begin_inset Formula $k_{i}^{x}$
\end_inset

 is assigned a cutting that enters some cylinder 
\begin_inset Formula $\hat{s}(l_{j}^{y})$
\end_inset

 for 
\begin_inset Formula $i\neq j$
\end_inset

 or 
\begin_inset Formula $x\neq y$
\end_inset

, partial assignment 
\begin_inset Formula $\hat{s}'$
\end_inset

 on line
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{assigned-line}
\end_layout

\end_inset

 of Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "dfs-algorithm"

\end_inset

 is not a solution.
\end_layout

\begin_layout Proof
If 
\begin_inset Formula $i\neq j$
\end_inset

 or 
\begin_inset Formula $x\neq y$
\end_inset

, lock 
\begin_inset Formula $l_{j}^{y}$
\end_inset

 is not opened by 
\begin_inset Formula $k_{i}^{x}$
\end_inset

 by Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "template-definition"

\end_inset

 of the template lock-chart.
 Therefore a cutting assigned to 
\begin_inset Formula $k_{i}^{x}$
\end_inset

 must be blocked in 
\begin_inset Formula $l_{j}^{y}$
\end_inset

.
\end_layout

\begin_layout Standard
Since 
\begin_inset Formula $\bar{\Gamma}$
\end_inset

 counts cuttings that are blocked by cylinders 
\begin_inset Formula $B$
\end_inset

, cylinders 
\begin_inset Formula $\hat{s}(l_{j}^{y})$
\end_inset

 can be passed as the last argument of 
\begin_inset Formula $\bar{\Gamma}$
\end_inset

.
 They constitute 
\begin_inset Formula $B$
\end_inset

 cylinders of type
\begin_inset space ~
\end_inset

1.
 Also note that many such cylinders are equal:
\end_layout

\begin_layout Remark
When the individual key 
\begin_inset Formula $k_{i}^{x}$
\end_inset

 is being assigned a cutting, all cylinders 
\begin_inset Formula $\hat{s}(l_{j}^{y})$
\end_inset

 are equal to 
\begin_inset Formula $\hat{s}(g_{j})$
\end_inset

 from the template if a) 
\begin_inset Formula $j>i$
\end_inset

 or b) 
\begin_inset Formula $j=i$
\end_inset

 and 
\begin_inset Formula $y>x$
\end_inset

.
\end_layout

\begin_layout Proof
The set of keys 
\begin_inset Formula $E(l_{j}^{y})$
\end_inset

 contains some master keys and exactly 1 individual key 
\begin_inset Formula $k_{j}^{y}$
\end_inset

.
 Key 
\begin_inset Formula $k_{i}^{x}$
\end_inset

 appears before 
\begin_inset Formula $k_{j}^{y}$
\end_inset

 in (
\begin_inset CommandInset ref
LatexCommand ref
reference "implicit-template-keys"

\end_inset

) precisely if conditions a) or b) hold.
 Consequently 
\begin_inset Formula $k_{j}^{y}$
\end_inset

 has not been assigned before 
\begin_inset Formula $k_{i}^{x}$
\end_inset

 and 
\begin_inset Formula $\hat{s}(l_{j}^{y})$
\end_inset

 contains cuttings of the master keys only.
 This is the exactly the cylinder 
\begin_inset Formula $\hat{s}(g_{j})$
\end_inset

 from the template lock-chart.
\end_layout

\begin_layout Standard
After removing identical cylinders, Lemma
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "implicit-B1-lemma"

\end_inset

 generates 
\begin_inset Formula 
\[
\sum_{j=1}^{i-1}e(g_{j})+(n-i)
\]

\end_inset

cylinders 
\begin_inset Formula $B$
\end_inset

 of type 1.
 The sum counts all 
\begin_inset Formula $\hat{s}(l_{j}^{y})$
\end_inset

 cylinders for 
\begin_inset Formula $j<i$
\end_inset

 and the 
\begin_inset Formula $(n-i)$
\end_inset

 term counts all the 
\begin_inset Formula $\hat{s}(g_{j})$
\end_inset

 cylinders.
\end_layout

\begin_layout Standard
The cylinders 
\begin_inset Formula $B$
\end_inset

 of type 2 ensure that a previously established blocking is not violated.
 The 
\family typewriter
prune
\family default
 method in Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "csp-prune-alg"

\end_inset

 preserved already established blockings by iterating over all 
\begin_inset Formula $\gamma\in S$
\end_inset

.
 In the general framework, this is not feasible.
 Instead, an already established blocking of key 
\begin_inset Formula $k$
\end_inset

 in lock 
\begin_inset Formula $l_{i}^{x}$
\end_inset

 translates to a gecon.
\end_layout

\begin_layout Lemma
\begin_inset CommandInset label
LatexCommand label
name "blogecon-lemma"

\end_inset

Let 
\begin_inset Formula $(K,L,E)$
\end_inset

 be the expansion s.t.
 
\begin_inset Formula $K$
\end_inset

 is indexed as in
\emph on
 (
\begin_inset CommandInset ref
LatexCommand ref
reference "implicit-template-keys"

\end_inset

)
\emph default
, 
\begin_inset Formula $\hat{s}$
\end_inset

 its partial solution, 
\begin_inset Formula $l_{i}^{x}$
\end_inset

 be a lock and 
\begin_inset Formula $k$
\end_inset

 one of its stopped keys 
\begin_inset Formula $k\not\in E(l_{i}^{x})$
\end_inset

.
 Individual key 
\begin_inset Formula $k_{i}^{x}$
\end_inset

 can be assigned cutting 
\begin_inset Formula $\gamma$
\end_inset

 without violating the blocking of 
\begin_inset Formula $\hat{s}(k)$
\end_inset

 in 
\begin_inset Formula $\hat{s}(l_{i}^{x})$
\end_inset

 if 
\begin_inset Formula $\gamma$
\end_inset

 satisfies the gecon 
\begin_inset Formula $(d_{1},\ldots,d_{p})$
\end_inset

 defined as follows: The depth 
\begin_inset Formula $d_{j}$
\end_inset

 is a wildcard if 
\begin_inset Formula $\hat{s}(k)_{j}\in\hat{s}(l_{i}^{x})_{j}$
\end_inset

; otherwise 
\begin_inset Formula $d_{j}=\hat{s}(k)_{j}$
\end_inset

.
\end_layout

\begin_layout Proof
A cutting 
\begin_inset Formula $\gamma$
\end_inset

 violates a gecon 
\begin_inset Formula $(d_{1},\ldots,d_{p})$
\end_inset

 precisely if 
\begin_inset Formula $\gamma_{j}=d_{j}$
\end_inset

 on all non-wildcard positions (by the Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "gecon-def"

\end_inset

).
 If it does, cylinder 
\begin_inset Formula $\hat{s}(l_{i}^{x})$
\end_inset

 will contain shear-line 
\begin_inset Formula $\hat{s}(k)$
\end_inset

 after having assigned 
\begin_inset Formula $\gamma$
\end_inset

 to 
\begin_inset Formula $k_{i}^{x}$
\end_inset

 and therefore 
\begin_inset Formula $k$
\end_inset

 is not blocked in 
\begin_inset Formula $l_{i}^{x}$
\end_inset

.
 If it does not, there is some depth 
\begin_inset Formula $\gamma_{j}$
\end_inset

 different from a non-wildcard 
\begin_inset Formula $d_{j}$
\end_inset

 and therefore 
\begin_inset Formula $k$
\end_inset

 is blocked in 
\begin_inset Formula $l_{i}^{x}$
\end_inset

 on the 
\begin_inset Formula $j$
\end_inset

-th position.
\end_layout

\begin_layout Standard
By satisfying gecons generated for every blocked cell in the 
\begin_inset Formula $l_{i}^{1}$
\end_inset

 row, the previously established blockings will not be violated.
 A
\begin_inset space ~
\end_inset

gecon is satisfied by a
\begin_inset space ~
\end_inset

cutting 
\begin_inset Formula $\gamma$
\end_inset

 if it is blocked in the gecon's universal cylinder.
 Therefore the 
\begin_inset Formula $\bar{\Gamma}$
\end_inset

 function receives one 
\begin_inset Formula $B$
\end_inset

 cylinder of type
\begin_inset space ~
\end_inset

2 for every blocked cell.
\end_layout

\begin_layout Standard
Together, by generating cylinders 
\begin_inset Formula $B$
\end_inset

 of types
\begin_inset space ~
\end_inset

0,
\begin_inset space ~
\end_inset

1 and
\begin_inset space ~
\end_inset

2, cuttings counted by
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\strikeout off
\uuline off
\uwave off
\noun off
\color none
 
\begin_inset Formula $\bar{\Gamma}(q,E,\{B_{1},\ldots,B_{n}\})$
\end_inset

 will be blocked in existing cylinders and their cylinders will block all
 blocked keys.
 How to ensure that cuttings within one group will be blocked amongst each
 other?
\end_layout

\begin_layout Standard
Let's motivate this question by a special case.
 If 
\begin_inset Formula $(K\cup L,E)$
\end_inset

 was a diagonal lock-chart and cylinder 
\begin_inset Formula $E$
\end_inset

 contained a single shear-line, namely the general key's cutting, then (
\begin_inset CommandInset ref
LatexCommand ref
reference "generalized-diagonal-size-equation"

\end_inset

) would give a lower bound on the size 
\begin_inset Formula $(K,L,E)$
\end_inset

, which is equal to the size of its only group 
\begin_inset Formula $e(g_{1})$
\end_inset

.
 How to define 
\emph on

\begin_inset Formula $E$
\end_inset


\emph default
 for non-diagonal lock-charts?
\end_layout

\begin_layout Lemma
Let 
\begin_inset Formula $\bar{\Gamma}(q,\hat{s}(g_{i}),\{\emptyset\})$
\end_inset

 count cuttings 
\begin_inset Formula $\gamma_{1},\gamma_{2},\ldots$
\end_inset

.
 If these cuttings are assigned to keys 
\begin_inset Formula $k_{i}^{1},k_{i}^{2},\ldots$
\end_inset

 then key 
\begin_inset Formula $k_{i}^{x}$
\end_inset

 will be blocked in 
\begin_inset Formula $l_{i}^{y}$
\end_inset

 for any 
\begin_inset Formula $x\neq y$
\end_inset

.
\end_layout

\begin_layout Proof
The proof generalises the idea from the proof of Theorem
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "thm:lower-bound"

\end_inset

.
 Let 
\begin_inset Formula $A_{x}$
\end_inset

 be the set of positions, where the cutting 
\begin_inset Formula $\hat{s}(k_{i}^{x})$
\end_inset

 has cutting depths present in lock 
\begin_inset Formula $\hat{s}(g_{i})$
\end_inset

: 
\begin_inset Formula 
\[
A_{x}=\left\{ r\in\{0,\ldots,p\}\mid\hat{s}(k_{i}^{x})_{r}\in\hat{s}(l_{i}^{y})_{r}\right\} \text{ .}
\]

\end_inset


\end_layout

\begin_layout Proof
a) 
\begin_inset Formula $A_{x}=A_{y}$
\end_inset

: There is a position 
\begin_inset Formula $r\not\in A_{x}$
\end_inset

 s.t.
 
\begin_inset Formula $\hat{s}(k_{i}^{x})_{r}\neq\hat{s}(k_{i}^{y})_{r}$
\end_inset

.
 Key 
\begin_inset Formula $k_{i}^{x}$
\end_inset

 is blocked in 
\begin_inset Formula $l_{i}^{y}$
\end_inset

 on position 
\begin_inset Formula $r$
\end_inset

 as well as key 
\begin_inset Formula $k_{i}^{y}$
\end_inset

 in 
\begin_inset Formula $l_{i}^{x}$
\end_inset

.
\end_layout

\begin_layout Proof
b) 
\begin_inset Formula $A_{x}\neq A_{y}$
\end_inset

: Since 
\begin_inset Formula $q=|A_{x}|=|A_{y}|$
\end_inset

, there is a position 
\begin_inset Formula $r\in A_{x}\setminus A_{y}$
\end_inset

 and 
\begin_inset Formula $r'\in A_{y}\setminus A_{x}$
\end_inset

.
 Key 
\begin_inset Formula $k_{i}^{y}$
\end_inset

 is blocked in 
\begin_inset Formula $l_{i}^{x}$
\end_inset

 on position 
\begin_inset Formula $r$
\end_inset

 and key 
\begin_inset Formula $k_{i}^{x}$
\end_inset

 is blocked in 
\begin_inset Formula $l_{i}^{y}$
\end_inset

 on 
\begin_inset Formula $r'$
\end_inset

.
\end_layout

\begin_layout Standard
Now it is tempting to state the condition for a perspective partial solution
 
\begin_inset Formula $\hat{s}$
\end_inset

 as
\begin_inset Formula 
\begin{equation}
\max_{0\leq q\leq p}\bar{\Gamma}(q,\hat{s}(g_{i}),B\text{ cylinders of all 3 types})\geq e(g_{i})\text{ .}\label{implicit-requirement-equation}
\end{equation}

\end_inset

However, this is a 
\emph on
sufficient
\emph default
 condition, not a 
\emph on
necessary
\emph default
 one, because 
\begin_inset Formula $\bar{\Gamma}$
\end_inset

 provides merely a lower bound on the size of diagonal “areas” in lock-charts.
 Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "counting-explicit-section"

\end_inset

 found diagonal lock-charts in the realistic dataset with more individual
 keys than this formula would give.
 Nevertheless, the margin between the lower bound and the exact value no
 bigger than 
\begin_inset Formula $50\%$
\end_inset

 (see Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "fig:same-as-general"

\end_inset

 below) and with larger code-space sizes, the margin only closed.
 Relying merely on the following assumption, the possibly overly-zealous
 pruning scheme must be evaluated empirically.
\end_layout

\begin_layout Assumption
\begin_inset CommandInset label
LatexCommand label
name "impli-optim-ass"

\end_inset

If the inequality 
\emph on
(
\begin_inset CommandInset ref
LatexCommand ref
reference "implicit-requirement-equation"

\end_inset

)
\emph default
 does not hold, there are not enough cuttings for individual keys in group
 
\begin_inset Formula $g_{i}$
\end_inset

.
\end_layout

\begin_layout Standard
The resulting pruning procedure is presented in Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "impli-alld-algo"

\end_inset

.
 Line
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{impli-alld-threshold-line}
\end_layout

\end_inset

 starts with two preconditions.
 The procedure is executed only when starting to assign the first key in
 each group of individual keys.
 Also, the pruning is considered only for sufficiently large groups, governed
 by a fixed threshold.
 Then, the procedure constructs 
\begin_inset Formula $B$
\end_inset

 cylinders of type
\begin_inset space ~
\end_inset

0 (starting on line
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{bcyl-type0-line}
\end_layout

\end_inset

), type
\begin_inset space ~
\end_inset

1 (line
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{bcyl-type1-line}
\end_layout

\end_inset

 onwards) and type
\begin_inset space ~
\end_inset

2 (line
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{bcyl-type2-line}
\end_layout

\end_inset

 onwards).
 Finally, the inequality (
\begin_inset CommandInset ref
LatexCommand ref
reference "implicit-requirement-equation"

\end_inset

) is checked in the loop on line
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{impli-prune-line}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LinesNumbered
\end_layout

\begin_layout Plain Layout


\backslash
DontPrintSemicolon
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{Input}{input}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{Output}{output}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{Null}{null}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{True}{true}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{False}{false}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{Perspective}{perspective}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{Function}{
\backslash
string:}{}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
Fn(){
\backslash
Perspective{$(M, G,F)$, $e$, $(K, L,E)$, $
\backslash
hat{s}$, $k_i^x$}}{
\end_layout

\begin_layout Plain Layout

  
\backslash
Input{The template lock-chart $(M,G,F)$,
\end_layout

\begin_layout Plain Layout

         the expansion function $e$,
\end_layout

\begin_layout Plain Layout

         the expansion $(K,L,E)$,
\end_layout

\begin_layout Plain Layout

         the partial solution $
\backslash
hat{s}$ and
\end_layout

\begin_layout Plain Layout

         a key yet to be assigned $k_i^x$}
\end_layout

\begin_layout Plain Layout

  
\backslash
Output{$
\backslash
True$ if the partial solution is perspective}
\end_layout

\begin_layout Plain Layout

  
\backslash
BlankLine
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
If{$x = 1$ and $e(g_i) 
\backslash
geq 
\backslash
text{ threshold}$}{
\backslash
label{impli-alld-threshold-line}
\end_layout

\begin_layout Plain Layout

    let $
\backslash
bar B$ be a set of cylinders, initialised to $
\backslash
emptyset$
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
ForEach(){gecon in the platform specification}{
\backslash
label{bcyl-type0-line}
\end_layout

\begin_layout Plain Layout

      convert it to a universal cylinder and add to $
\backslash
bar B$
\backslash
;
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
For(){$j 
\backslash
in 
\backslash
{1,
\backslash
ldots, n
\backslash
}$}{
\backslash
label{bcyl-type1-line}
\end_layout

\begin_layout Plain Layout

      
\backslash
uIf{$j < i$}{
\end_layout

\begin_layout Plain Layout

    	
\backslash
For(){$y 
\backslash
in 
\backslash
{1,
\backslash
ldots, e(g_j)
\backslash
}$}{
\end_layout

\begin_layout Plain Layout

          add $
\backslash
hat{s}(l_j^y)$ to $
\backslash
bar B$
\backslash
;
\end_layout

\begin_layout Plain Layout

        }
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      
\backslash
Else{
\end_layout

\begin_layout Plain Layout

        add $
\backslash
hat{s}(g_j)$ to $
\backslash
bar B$
\backslash
;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\end_layout

\begin_layout Plain Layout

    
\backslash
ForEach(){master key $k 
\backslash
not
\backslash
in F(g_i)$}{
\backslash
label{bcyl-type2-line}
\end_layout

\begin_layout Plain Layout

      create gecon by Lemma~
\backslash
ref{blogecon-lemma} from key $k$ and lock $g_i$
\backslash
;
\end_layout

\begin_layout Plain Layout

      convert it to a universal cylinder and add to $
\backslash
bar B$
\backslash
;
\end_layout

\begin_layout Plain Layout

   }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	
\backslash
For(){$j 
\backslash
in 
\backslash
{1,
\backslash
ldots, i-1
\backslash
}$}{
\end_layout

\begin_layout Plain Layout

  	
\backslash
For(){$y 
\backslash
in 
\backslash
{1,
\backslash
ldots, e(g_j)
\backslash
}$}{
\end_layout

\begin_layout Plain Layout

        create gecon by Lemma~
\backslash
ref{blogecon-lemma} from $k_j^y$ and $g_i$
\backslash
;
\end_layout

\begin_layout Plain Layout

        convert it to a universal cylinder and add to $
\backslash
bar B$
\backslash
;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

    
\backslash
For(){$q 
\backslash
in 
\backslash
{0,
\backslash
ldots, p
\backslash
}$}{
\backslash
label{impli-prune-line}
\end_layout

\begin_layout Plain Layout

      
\backslash
If{$
\backslash
bar
\backslash
Gamma(q, 
\backslash
hat{s}(g_i), 
\backslash
bar B) 
\backslash
geq e(g_i)$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
Return $
\backslash
True$
\backslash
;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

    
\backslash
Return $
\backslash
False$
\backslash
;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\backslash
Return $
\backslash
True$
\backslash
;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
All-different pruning for the general fr.
\end_layout

\end_inset

All-different pruner for the general framework.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "impli-alld-algo"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
GVC minimisation
\end_layout

\begin_layout Standard
\begin_inset CommandInset label
LatexCommand label
name "gvc-min-sec"

\end_inset


\end_layout

\begin_layout Standard
In the last section, all algorithms above are evaluated empirically.
 The methodology was taken from the automorphism algorithm's analysis in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "lawer2004"

\end_inset

.
 All algorithms were adapted to minimise the number of shear-lines in a
 global virtual cylinder (see Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "minimize-gvc-criterion"

\end_inset

).
 The adaptations were minimal so that the decision variant of the problem
 (which asks if 
\emph on
any
\emph default
 solution can be found) could also be evaluated.
\end_layout

\begin_layout Paragraph
Datasets.
\end_layout

\begin_layout Standard
For the evaluation, three datasets were used.
 Two of them are real-world datasets; the last was synthetic, generated
 using a procedure described below.
\end_layout

\begin_layout Enumerate
The 
\emph on
real-world dataset
\emph default
 contains the lock-charts published in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "lawer2004"

\end_inset

, which were provided by a German manufacturer IKON.
 The study does not mention the code space that was used to solve them,
 and hence we used the vanilla framework with 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

 values chosen as small as possible, which allowed at least one competing
 algorithm to find a solution.
 The actual values are given in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lawer-dataset-table"

\end_inset

.
\end_layout

\begin_layout Enumerate
The 
\emph on
master-only dataset
\emph default
 contains lock-charts from the real-world dataset, whose individual keys
 were deleted.
 The deletion allows us to compare results presented here with Lawer's decision
 to use the GVC minimisation on master keys only and to assign individual
 keys using a separate procedure (e.g.
 those suggested in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "counting-explicit-section"

\end_inset

).
 Since lock-chart 
\family typewriter
M204
\family default
 contains only individual keys, there was one less lock-chart in the master-only
 dataset than in the real-world dataset.
\end_layout

\begin_layout Enumerate
The 
\emph on
synthetic dataset
\emph default
 was constructed algorithmically.
 First, the parameter 
\begin_inset Formula $p$
\end_inset

 (number of positions), 
\begin_inset Formula $d$
\end_inset

 (number of cutting depths) and 
\begin_inset Formula $m$
\end_inset

 (number of master keys) were chosen randomly from values 
\begin_inset Formula $\{2,6,10\}$
\end_inset

.
 A lock-chart of independent keys (Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "lc-independent-definition"

\end_inset

) with 
\begin_inset Formula $m$
\end_inset

 keys was used as a template, but keeping only the first 
\begin_inset Formula $2^{m-1}$
\end_inset

 locks.
 This ensures that 
\begin_inset Formula $k_{m}$
\end_inset

 was the general key.
 Since 
\begin_inset Formula $m\geq2$
\end_inset

, no diagonal lock-chart was not included.
 Next, the total number of individual keys 
\begin_inset Formula $x$
\end_inset

 was sampled as either 
\begin_inset Formula $1\%$
\end_inset

, 
\begin_inset Formula $2\%$
\end_inset

, 
\begin_inset Formula $5\%$
\end_inset

, 
\begin_inset Formula $20\%$
\end_inset

, 
\begin_inset Formula $50\%$
\end_inset

 or 
\begin_inset Formula $100\%$
\end_inset

 of 
\begin_inset Formula $|S_{\hat{q}}|$
\end_inset

.
 To generate “reasonably” sized lock-charts, yet larger than those in the
 real-world dataset, values outside of 
\begin_inset Formula $20\leq x\leq200$
\end_inset

 were omitted.
 The expansion function was designed to spread 
\begin_inset Formula $x$
\end_inset

 individual keys between as many combinations of master keys as possible:
 
\begin_inset Formula 
\begin{equation}
e(l_{i})=(i+x-1)\div2^{m-1}
\end{equation}

\end_inset

Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "synthetic-dataset-table"

\end_inset

 contains the list of all lock-charts in the synthetic dataset.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="21" columns="6">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell multicolumn="1" alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Lock-chart
\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Keys 
\begin_inset Formula $m$
\end_inset

+
\begin_inset Formula $x$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Locks
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Positions 
\begin_inset Formula $p$
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Depths 
\begin_inset Formula $d$
\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="middle" bottomline="true" rotate="90" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
easy
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M103
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5+6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M108
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5+14
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M109
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7+8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M111
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4+10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M112
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3+13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M201
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
10+9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M203
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3+19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M204
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
0+2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M209
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6+16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
16
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="middle" bottomline="true" rotate="90" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
medium
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M101
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8+29
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
29
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M104
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
8+23
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
23
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M106
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
13+19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
29
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M107
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4+31
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
31
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M202
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9+19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
19
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M206
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9+27
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
27
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M208
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
7+34
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
34
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="3" alignment="center" valignment="middle" rotate="90" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
hard
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M100
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20+21
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
28
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" rotate="90" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M102
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
12+60
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
60
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
6
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" rotate="90" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M200
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
17+15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
29
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
</row>
<row>
<cell multirow="4" alignment="center" valignment="top" rotate="90" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\family typewriter
M205
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
20+15
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
33
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
3
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Real-world dataset
\end_layout

\end_inset

Real-world lock-charts from 
\begin_inset CommandInset citation
LatexCommand cite
key "lawer2004"

\end_inset

 with values of 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

 used during the experiments.
 Number of keys is formatted as 
\begin_inset Formula $m+x=\text{master + individual keys}$
\end_inset

.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "lawer-dataset-table"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset CommandInset include
LatexCommand input
preview true
filename "MinGvlSynthetic.tex"

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Synthetic dataset
\end_layout

\end_inset

Lock-charts from the synthetic dataset with values of 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $d$
\end_inset

 used during the experiments.
 Number of keys is formatted as 
\begin_inset Formula $m+x=\text{master + individual keys}$
\end_inset

.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "synthetic-dataset-table"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Algorithms.
\end_layout

\begin_layout Standard
The first contesting algorithm was the 
\emph on
automorphism algorithm
\emph default
 from Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "amorf-sec"

\end_inset

, which reduces the number of candidate cuttings from 
\begin_inset Formula $|S|$
\end_inset

 to the number given by (
\begin_inset CommandInset ref
LatexCommand ref
reference "amorf-cand-eq"

\end_inset

).
\end_layout

\begin_layout Standard
The other two backtrackers also used the automorphism pruning scheme but
 added the all-different pruning on top of that.
 The 
\emph on
CSP algorithm
\emph default
 followed ideas from Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "csp-sec"

\end_inset

 and considered a partial solution perspective according to Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "csp-alld-alg"

\end_inset

.
 The 
\emph on
implicit algorithm
\emph default
 from Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "impli-sec"

\end_inset

 considered a partial solution perspective according to Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "impli-alld-algo"

\end_inset

.
\end_layout

\begin_layout Standard
All three backtrackers were modified as follows:
\end_layout

\begin_layout Itemize
If a solution is found, the search does not stop.
 It stops when no more solutions are available.
\end_layout

\begin_layout Itemize
The algorithm keeps track of the best solution 
\begin_inset Formula $b$
\end_inset

 so far.
 When a new solution 
\begin_inset Formula $s$
\end_inset

 is found, 
\begin_inset Formula $b$
\end_inset

 is overwritten to 
\begin_inset Formula $s$
\end_inset

 if the number of shear-lines of the GVC decreases:
\begin_inset Formula 
\begin{equation}
\left|\bigcup_{k\in K}s(k)\right|<\left|\bigcup_{k\in K}b(k)\right|
\end{equation}

\end_inset


\end_layout

\begin_layout Itemize
To gain some more efficiency, any perspective partial solution 
\begin_inset Formula $\hat{s}$
\end_inset

 must also satisfy
\begin_inset Formula 
\begin{equation}
\left|\bigcup_{(k,\gamma)\in\hat{s}}\gamma\right|<\left|\bigcup_{k\in K}b(k)\right|\text{ .}
\end{equation}

\end_inset

This follows from the fact that the numuber of shear-lines in a partial
 solution can only increase in its extension.
\end_layout

\begin_layout Itemize
Following the idea in
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "lawer2004"

\end_inset

 the assignment of individual keys preferred cuttings, whose 
\begin_inset Formula $q$
\end_inset

 value was 
\begin_inset Formula $\arg\max_{q}|S_{q}|$
\end_inset

.
\end_layout

\begin_layout Standard
The fourth algorithm was not a backtracker.
 The 
\emph on
SAT algorithm
\emph default
 translates the lock-chart into a CNF as described in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sat-sec"

\end_inset

 and then it is solved by the MiniSAT library
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "een2003"

\end_inset

.
 Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sat-mingvc-algo"

\end_inset

 describes the adaptation needed to minimise the GVC using a SAT solver.
\end_layout

\begin_layout Standard
The algorithm can be viewed as a method to find an asymmetric framework
 with the deepest cutting 
\begin_inset Formula $(\tilde{d}_{1},\ldots,\tilde{d}_{p})$
\end_inset

.
 Iteratively it tries to minimise 
\begin_inset Formula $\tilde{d}_{1}$
\end_inset

 by forbidding the respective variables on line
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{sat-forbid-line}
\end_layout

\end_inset

.
 If that is not possible (line
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{sat-proceed-line}
\end_layout

\end_inset

), it continues with the next position 
\begin_inset Formula $\tilde{d}_{2}$
\end_inset

 etc.
 A early-escape pruning (line
\begin_inset space ~
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{sat-quick-stop-line}
\end_layout

\end_inset

) occurs if it fails to minimise 
\begin_inset Formula $\tilde{d}_{i}$
\end_inset

 at all.
 In such a case, 
\begin_inset Formula $\tilde{d}_{i+1}$
\end_inset

 can't be minimised neither and the algorithm stops.
 The algorithm minimises GVC shear-lines under the following assumption.
\end_layout

\begin_layout Assumption
\begin_inset CommandInset label
LatexCommand label
name "sat-mingvc-ass"

\end_inset

The 
\begin_inset Formula $\Lambda$
\end_inset

 under the asymmetric framework with deepest cutting 
\begin_inset Formula $(\tilde{d}_{1},\ldots,\tilde{d}_{p})$
\end_inset

 has less shear-lines than 
\begin_inset Formula $\Lambda$
\end_inset

 under 
\begin_inset Formula $(\tilde{d}_{1}',\ldots,\tilde{d}_{p}')$
\end_inset

 if there is a position 
\begin_inset Formula $i$
\end_inset

 s.t.
 
\begin_inset Formula 
\begin{equation}
\tilde{d}_{1}'=\tilde{d}_{1}',\ldots,\tilde{d}_{i-1}=\tilde{d}_{i-1}'\text{ and }\tilde{d}_{i}<\tilde{d}_{i}'\text{ .}\label{sat-assumption-eq}
\end{equation}

\end_inset


\end_layout

\begin_layout Standard
Since there are trivial counter-examples to this assumption, the effects
 on the calculation results must be found experimentally.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
LinesNumbered
\end_layout

\begin_layout Plain Layout


\backslash
DontPrintSemicolon
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{Input}{input}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwInOut{Output}{output}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{Null}{null}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{True}{true}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{False}{false}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwFunction{Sat}{sat}
\end_layout

\begin_layout Plain Layout


\backslash
SetKw{Break}{break}
\end_layout

\begin_layout Plain Layout


\backslash
SetKwProg{Fn}{Function}{
\backslash
string:}{}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
Fn(){
\backslash
Sat{$p$, $d$, $(K, L,E, B)$}}{
\end_layout

\begin_layout Plain Layout

  
\backslash
Input{Number of positions $p$,
\end_layout

\begin_layout Plain Layout

         number of cutting depths $d$
\end_layout

\begin_layout Plain Layout

         and a melted profiles lock-chart $(K, L,E, B)$}
\end_layout

\begin_layout Plain Layout

  
\backslash
Output{Solution which minimises the
\end_layout

\begin_layout Plain Layout

         number of shear-lines in the GVC
\end_layout

\begin_layout Plain Layout

         or 
\backslash
Null if no solution exists.}
\end_layout

\begin_layout Plain Layout

  
\backslash
BlankLine
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  let $b$ a solution, initialised to 
\backslash
Null
\backslash
;
\end_layout

\begin_layout Plain Layout

  let $C$ be the straightforward translation of $(K
\backslash
cup L, E)$
\backslash
;
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
uIf{$C$ has a model}{
\end_layout

\begin_layout Plain Layout

    update $b$ to the solution from $C$'s model
\backslash
;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

  
\backslash
Else{
\end_layout

\begin_layout Plain Layout

    
\backslash
Return 
\backslash
Null
\backslash
;
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
For(){$i 
\backslash
in 
\backslash
{1,
\backslash
ldots p
\backslash
}$}{
\backslash
label{sat-p-loop-line}
\end_layout

\begin_layout Plain Layout

    
\backslash
For(){$j 
\backslash
in 
\backslash
{2,
\backslash
ldots d
\backslash
}$}{
\backslash
label{sat-d-loop-line}
\end_layout

\begin_layout Plain Layout

      
\backslash
ForEach(){$k 
\backslash
in K$}{
\end_layout

\begin_layout Plain Layout

        add a unitary clause
\end_layout

\begin_layout Plain Layout

          $
\backslash
overline{
\backslash
mathsf{key}}_{i,j}^{k}$
\end_layout

\begin_layout Plain Layout

          to $C$
\backslash
;
\backslash
label{sat-forbid-line}
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      
\end_layout

\begin_layout Plain Layout

      
\backslash
uIf{$C$'s model can be found within a conflict limit}{
\end_layout

\begin_layout Plain Layout

        update $b$ to the solution from $C$'s model
\backslash
;
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      
\backslash
uElseIf{$j = d$}{
\end_layout

\begin_layout Plain Layout

        
\backslash
Return $b$
\backslash
;
\backslash
label{sat-quick-stop-line}
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

      
\backslash
Else{
\end_layout

\begin_layout Plain Layout

        
\backslash
Break to try the next position
\backslash
;
\backslash
label{sat-proceed-line}
\end_layout

\begin_layout Plain Layout

      }
\end_layout

\begin_layout Plain Layout

    }
\end_layout

\begin_layout Plain Layout

  }
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  
\backslash
Return $b$
\backslash
;
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
SAT-based 
\begin_inset Formula $|\Lambda|$
\end_inset

 minimiser
\end_layout

\end_inset

SAT solver modified to minimise 
\begin_inset Formula $|\Lambda|$
\end_inset

 using the straightforward translation.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "sat-mingvc-algo"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Two known algorithms published by other authors were left out of this comparison
 due to their incomplete specification.
 Junker's translation of lock-chart solving to CSP 
\begin_inset CommandInset citation
LatexCommand cite
key "junker1999"

\end_inset

 relied on 
\emph on
set variables
\emph default
, a feature present in ILOG solver v4.0 
\begin_inset CommandInset citation
LatexCommand cite
key "ilog"

\end_inset

, which is already 20 years old at the time of writing this text and no
 longer available.
 In the documentation of the current version of ILOG solver 
\begin_inset CommandInset citation
LatexCommand cite
key "cplex"

\end_inset

 (now acquired by IBM) we
\begin_inset space ~
\end_inset

were unable to find any reference to set variables.
 Hence, to the best of our knowledge, the actual strategy for navigating
 through the search-space defined by Junker's translation procedure is buried
 somewhere in the IBM archives.
\end_layout

\begin_layout Standard
The recent study 
\begin_inset CommandInset citation
LatexCommand cite
key "vomel2017"

\end_inset

 by Vőmel
\begin_inset space ~
\end_inset

et
\begin_inset space ~
\end_inset

al.
 adapted 
\emph on
simulated annealing
\emph default
 
\begin_inset CommandInset citation
LatexCommand cite
key "aarts1997"

\end_inset

 algorithm for lock-chart solving.
 Their objective function measured “the grade of deviation from a correct
 matching” and the move from one partial solution to another did not use
 the plain idea of “random exchanges”, but was “restricted at runtime” to
 find “‘reasonable’ candidates from a promising neighbourhood”.
 However, no formal description of 
\emph on
reasonable
\emph default
 or 
\emph on
promising
\emph default
 was given.
 Despite incomplete specification, we
\begin_inset space ~
\end_inset

tried implementing a prototype of a local search procedure.
 Since its performance was orders of magnitude slower than results presented
 in 
\begin_inset CommandInset citation
LatexCommand cite
key "vomel2017"

\end_inset

, we thought it would be unfair to consider it a “reimplementation of Vőmel's
 algorithm”.
 Merely as a “sluggish prototype of local search”, we decided not to include
 it here.
\end_layout

\begin_layout Paragraph
Hypotheses.
\end_layout

\begin_layout Standard
The automorphism and CSP algorithms are complete in the following sense:
 Given an infinite amount of time, they always find the optimal solution.
 The implicit algorithm is not complete, because of possible violations
 of Assumption
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "impli-optim-ass"

\end_inset

 and neither is the SAT algorithm because of Assumption
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sat-mingvc-ass"

\end_inset

.
 However, given a limited amount time, even the complete algorithms may
 fail to find the optimal solution quickly enough.
 Will the incomplete algorithms outperform them?
\end_layout

\begin_layout Standard
The implicit algorithm has an unpleasant property of invoking an 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete pruning procedure in some points of the search space.
 Will the overall runtime benefit from this?
\end_layout

\begin_layout Standard
Finally, how do these algorithms perform at the decision variant of the
 problem? All four algorithms received a “hook”, which reports every update
 of the best solution 
\begin_inset Formula $b$
\end_inset

.
 The first invocation of this hook reports the runtime necessary for finding
 the first solution, regardless of its quality.
\end_layout

\begin_layout Paragraph
Disclaimer.
\end_layout

\begin_layout Standard
A particular bias of these experiments should be pointed out.
 One fundamental limitation of the SAT algorithm was reported in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sat-sec"

\end_inset

.
 Due to high memory consumption and the MiniSAT's search strategy oblivious
 to symmetries in the search-space (such as picking cuttings from 
\begin_inset Formula $S_{\hat{q}}$
\end_inset

 for individual keys), SAT is unlikely to solve lock-charts with more than
 
\begin_inset Formula $\sim1700$
\end_inset

 keys.
 The largest lock-chart in the dataset has 
\begin_inset Formula $x=200$
\end_inset

 individual keys, well below this limit.
 If this limit were raised, SAT's performance would deteriorate.
 Lock-charts in this section should be considered 
\emph on
small-sized
\emph default
 or 
\emph on
mid-sized
\emph default
.
\end_layout

\begin_layout Standard
Individual keys in the synthetic dataset follow the Definition
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "gmik-def"

\end_inset

 exactly.
 Each key either opens exactly one lock (hence individual) or opens most
 locks (hence master).
 Our business experience confirms Lawer's observation
\begin_inset space ~
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "lawer2004"

\end_inset

 that the hardest industrial lock-charts are 
\emph on
unstructured
\emph default
.
 They have a lot of “almost individual” or “border-line master” keys, which,
 e.g.
 complicate picking cuttings of the 
\begin_inset Formula $S_{\hat{q}}$
\end_inset

 for individual keys.
 Hence lock-charts here are computationally hard due to the number of master
 keys rather than the poor structure of individual keys.
\end_layout

\begin_layout Standard
We avoided overly well-structured problems, such as the diagonal ones.
 The implicit algorithm detects whether they have a solution in linear time.
\begin_inset Foot
status collapsed

\begin_layout Plain Layout
Right after setting the general key's cutting (for which there is only 1
 candidate cutting), the 
\begin_inset Formula $\bar{\Gamma}(q,\hat{s}(k_{1}),\{\emptyset\})$
\end_inset

 function is invoked exactly 
\begin_inset Formula $p+1$
\end_inset

 times in the only group 
\begin_inset Formula $g_{1}$
\end_inset

.
 It reduces to calling 
\begin_inset Formula $\theta(p,q,\hat{s}(g),\emptyset)$
\end_inset

, for which Algorithm
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "vanilla-counting-algorithm"

\end_inset

 provides a fast implementation.
\end_layout

\end_inset

 If a solution exists, the same is true for Lawer's algorithm.
 Hence, including well-structured problems would merely test data structures
 and quality of implementation, which is not the aim of these experiments.
\end_layout

\begin_layout Paragraph
Results.
\end_layout

\begin_layout Standard
All experiments were performed on a Intel Xeon clocked at 
\begin_inset Formula $3.10\text{ GHz}$
\end_inset

 with 
\begin_inset Formula $128\text{ GiB}$
\end_inset

 RAM.
 All algorithms were implemented as single-threaded.
 The timeout was set to 
\begin_inset Formula $10^{4}\,\text{s}$
\end_inset

, which is 
\begin_inset Formula $\sim2.8\,\text{hours}$
\end_inset

.
\end_layout

\begin_layout Standard
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "mingvc-success-tab"

\end_inset

 summarises the number of successfuly solved lock-charts within the timeout,
 referred as the 
\emph on
success rate
\emph default
.
 It shows the algorithms' ability to solve the decision variant of the lock-char
t solving problem.
 We can see that SAT unquestionably dominates in all datasets having the
 
\begin_inset Formula $100\%$
\end_inset

 success rate.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset CommandInset include
LatexCommand input
preview true
filename "MinGvlSuccess.tex"

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Lock-charts solved within the timeout
\end_layout

\end_inset

Number of lock-charts solved within the 
\begin_inset Formula $10^{5}\,\text{s}$
\end_inset

 timeout.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "mingvc-success-tab"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
For small lock-charts in the real-world and master-only datasets, none of
 the two additional all-different pruning increases the success rate.
 However, as the lock-chart's size increases in the synthetic dataset, both
 pruning strategies avoid parts of the search space, where the automorphism
 algorithm got trapped.
 Tables
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "mingvc-absolute-first-MN-tab"

\end_inset

 and
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "mingvc-absolute-first-D-tab"

\end_inset

 support this by showing absolute runtime needed for finding the first solution
 – the time referred as 
\emph on
decision runtime
\emph default
.
\end_layout

\begin_layout Standard
In the pair-wise comparison, two algorithms are compared.
 The score (runtime, shear-lines in GVC, ...) is averaged by the geometric
 mean in the same way as in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "counting-explicit-section"

\end_inset

 from those lock-charts, which were solved by both compared algorithms.
\end_layout

\begin_layout Standard
Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "mingvc-pairwise-first-tab"

\end_inset

 shows the pair-wise comparison of decision runtimes.
 Values confirm the prevailing dominance of the SAT algorithm.
 Between CSP and the implicit pruning schemes, the implicit algorithm achieves
 a better runtime – a difference especially pronounced in the synthetic
 dataset, whose lock-charts are bigger.
\end_layout

\begin_layout Standard
How do the algorithms perform at minimising the number of shear-lines in
 the GVC? Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "mingvc-absolute-enterings-MN-tab"

\end_inset

 show the results in real-world and master-only datasets.
 In both, only minor differences can be found.
 In one case (lock-chart 
\family typewriter
M108
\family default
), the automorphism algorithm's brute-force paid off by finding a better
 solution than all other algorithms.
 In two cases (lock-charts 
\family typewriter
M107
\family default
 and 
\family typewriter
N200
\family default
), the SAT's brute force won over all other algorithms.
\end_layout

\begin_layout Standard
Probably the most interesting result is lock-chart 
\family typewriter
N201
\family default
.
 It is the only lock-chart, where Assumption
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sat-mingvc-ass"

\end_inset

 of SAT's optimality was necessarily violated.
 Nevertheless, possible further violations in the synthetic dataset, shown
 in Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "mingvc-absolute-enterings-D-tab"

\end_inset

, have a lesser effect than the backtrackers' inability to escape local
 minima.
 In 3 lock-charts, the difference was by more than one magnitude.
\end_layout

\begin_layout Standard
Finally, we measured the 
\emph on
optimisation runtime
\emph default
 – time needed to find the best solution.
 Such value is useful in practice for determining a reasonable timeout.
 If a timeout is greater than the optimisation runtime, then the quality
 of the solution (Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "mingvc-absolute-enterings-MN-tab"

\end_inset

) will be guaranteed.
 Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "mingvc-absolute-optim-MN-tab"

\end_inset

 summarises the optimisation runtime in real-world and master-only datasets
 and support the practicality of the SAT algorithm.
\end_layout

\begin_layout Standard
For illustrative purposes, Figure
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "mingvc-n102-fig"

\end_inset

 shows how the shear-lines in GVC are reduced over time in the 
\family typewriter
N102
\family default
 lock-chart.
\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset CommandInset include
LatexCommand input
preview true
filename "MinGvlAbsoluteFirstMN.tex"

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Decision runtime on the real-world dataset
\end_layout

\end_inset

Time required to find a solution (decision runtime) to the lock-charts in
 the real-world and master-only datasets.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "mingvc-absolute-first-MN-tab"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset CommandInset include
LatexCommand input
preview true
filename "MinGvlAbsoluteFirstD.tex"

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Decision runtime on the synthetic dataset
\end_layout

\end_inset

Time required to find a solution (decision runtime) to the lock-charts in
 the synthetic dataset.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "mingvc-absolute-first-D-tab"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset CommandInset include
LatexCommand input
preview true
filename "MinGvlPairwiseFirstM.tex"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset VSpace bigskip
\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset CommandInset include
LatexCommand input
preview true
filename "MinGvlPairwiseFirstD.tex"

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Decision runtime pair-wise comparison
\end_layout

\end_inset

Pair-wise comparison of decision runtimes, averaged by geometric mean.
 Values 
\begin_inset Formula $\leq1$
\end_inset

 mean that the row-algorithm beats the column-algorithm.
 Master-only dataset is not listed, because of small absolute values in
 Table
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "mingvc-absolute-first-MN-tab"

\end_inset

, whose ratio is numerically unstable.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "mingvc-pairwise-first-tab"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset CommandInset include
LatexCommand input
preview true
filename "MinGvlAbsoluteEnteringsMN.tex"

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset Formula $|\Lambda|$
\end_inset

 in the real-world dataset
\end_layout

\end_inset


\begin_inset Formula $|\Lambda|$
\end_inset

 by the best found solution in the real-world and master-only datasets.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "mingvc-absolute-enterings-MN-tab"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset CommandInset include
LatexCommand input
preview true
filename "MinGvlAbsoluteEnteringsD.tex"

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
\begin_inset Formula $|\Lambda|$
\end_inset

 in the synthetic dataset
\end_layout

\end_inset


\begin_inset Formula $|\Lambda|$
\end_inset

 by the best found solution in the synthetic dataset.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "mingvc-absolute-enterings-D-tab"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset CommandInset include
LatexCommand input
preview true
filename "MinGvlAbsoluteOptimMN.tex"

\end_inset


\end_layout

\begin_layout Plain Layout
\noindent
\align center
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Optimisation time in the real-world dataset
\end_layout

\end_inset

Time required to find the best solution (optimisation time) to lock-charts
 in the real-world and master-only datasets.
\end_layout

\end_inset


\begin_inset CommandInset label
LatexCommand label
name "mingvc-absolute-optim-MN-tab"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways true
status open

\begin_layout Plain Layout
\noindent
\align center
\begin_inset CommandInset include
LatexCommand input
preview true
filename "N102.tex"

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Convergence of 
\begin_inset Formula $|\Lambda|$
\end_inset

 in 
\family typewriter
N102
\family default
 lock-chart
\end_layout

\end_inset

Convergence of 
\begin_inset Formula $|\Lambda|$
\end_inset

 in the best solution found so far (
\begin_inset Formula $b$
\end_inset

) on the 
\family typewriter
N102
\family default
 lock-chart.
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset CommandInset label
LatexCommand label
name "mingvc-n102-fig"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\end_layout

\begin_layout Chapter
Conclusions
\end_layout

\begin_layout Standard
Lock-chart solving is a complex problem, both theoretically and practically.
 The formalism proposed in this study is relatively simple, yet expressive
 enough to capture all intricacies of several real-world mechanical platforms.
 Many real-world problems coming from industrial needs, such as finding
 largest diagonal lock-charts, are either polynomially solvable or can be
 approximated using a polynomial procedure to a satisfactory degree.
 Other real-world problems, such as solving large unstructured lock-charts
 or counting available cuttings, are not practically feasible given the
 state-of-the-art computers and algorithms.
\end_layout

\begin_layout Standard
Lock-chart solving is a problem overlooked by academia.
 We know only of 4 publicly available studies 
\begin_inset CommandInset citation
LatexCommand cite
key "junker1999,lawer2004,oshall2015,vomel2017"

\end_inset

 on the topic of computational lock-chart solving, which might be surprising
 given that the problem has many interesting properties.
 For example, the hierarchy of lock-chart formalisms contains the 
\begin_inset Formula $\mathcal{P}$
\end_inset

/
\begin_inset Formula $\mathcal{NP}$
\end_inset

 boundary.
 This study proved that in vanilla framework, diagonal and key-to-differ
 lock-charts are solvable in 
\begin_inset Formula $\mathcal{P}$
\end_inset

, yet more expressive lock-charts are 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete.
 Moreover, the simplistic formalism of lock-charts allows researchers to
 attack the problem using various discrete optimisation approaches.
 Here we have successfully applied SAT solvers and some CSP-inspired techniques.
\end_layout

\begin_layout Standard
Lock-chart solving is a great challenge for hackers.
\begin_inset Foot
status open

\begin_layout Plain Layout
We mean ethical hackers.
\end_layout

\end_inset

 Tackling 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete problems has always been approached both by theoretical breakthroughs
 and dirty tricks.
 The apparent structure and symmetries in lock-charts call for many ideas
 of the latter kind.
 Given the popularity of contests in lock-picking, which is essentially
 a kind of mechanical hacking, there is no reason to believe that lock-chart
 solving cannot become a hacking quest for IT people.
\end_layout

\begin_layout Standard
Lock-chart solving is a good exercise for teaching algorithmization in schools,
 an observation already mentioned in 
\begin_inset CommandInset citation
LatexCommand cite
key "vomel2017"

\end_inset

.
 Students need a low overhead to start.
 Since tuples are naturally represented by arrays and tree/hash sets are
 one of the earliest taught data structures, probably the hardest notion
 to understand before diving into lock-chart solving is a graph.
\end_layout

\begin_layout Standard
Here is a list of several opportunities for future development.
\end_layout

\begin_layout Itemize
Personally, the most intriguing open question is the status of basic lock-charts
 in the vanilla framework.
 Diagonal lock-charts are in 
\begin_inset Formula $\mathcal{P}$
\end_inset

, yet extension and melted profiles lock-charts are 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete.
 In which class do the basic lock-charts belong to?
\end_layout

\begin_layout Itemize
Solving 
\begin_inset Formula $\mathcal{NP}$
\end_inset

-complete tasks is usually concerned with the runtime.
 Unless 
\begin_inset Formula $\mathcal{P}=\mathcal{NP}$
\end_inset

, the runtime is inevitably exponential, which limits the algorithm capabilities.
 However, in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sat-sec"

\end_inset

 we saw that the limitation of SAT solvers is not their runtime, but memory
 requirements.
 The work on reducing the memory footprint of SAT solvers focuses on reducing
 the footprint of learnt clauses 
\begin_inset CommandInset citation
LatexCommand cite
key "audemard2009,grumberg2004"

\end_inset

 or proofs of formula's unsatisfiability 
\begin_inset CommandInset citation
LatexCommand cite
key "zhang2003"

\end_inset

.
 Another line of research can investigate methods of storing or reducing
 the CNF itself and keep a comparable runtime to the current generation
 of SAT solvers.
\end_layout

\begin_layout Itemize
Practical solvers that optimise for extensibility would benefit from a deeper
 analysis of independent keys.
 What is the largest lock-chart of independent keys if the code space is
 defined in the explicit framework?
\end_layout

\begin_layout Itemize
A
\begin_inset space ~
\end_inset

natural variation of employing SAT solvers is to explore other formalisms
 for discrete optimisation, such as ILP as proposed in Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "ilp-sec"

\end_inset

.
\end_layout

\begin_layout Itemize
The cutting counting algorithm with general constraints is in its early
 stages of development and offers many research directions.
 For example, can the code space 
\begin_inset Formula $S$
\end_inset

 be sampled to get merely approximate values 
\begin_inset Formula $|S_{q}|$
\end_inset

, yet precise enough to evaluate 
\begin_inset Formula $\hat{q}=\arg\max_{q}|S_{q}|$
\end_inset

?
\end_layout

\begin_layout Itemize
Better cutting counting algorithm can improve the scalability of backtracking
 algorithms, which is the main drawback of SAT solvers (see Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "sat-sec"

\end_inset

).
 Even though the implicit algorithm (from Section
\begin_inset space ~
\end_inset


\begin_inset CommandInset ref
LatexCommand ref
reference "impli-sec"

\end_inset

) is not complete and does not ensure finding the optimal solution, it achieved
 better results than other backtrackers did due to performance gains.
 The trade-off between completeness and performance should be explored in
 more detail.
\end_layout

\begin_layout Standard
Finally, there is a personal wish.
 It would be great to see a small lock-chart solving community.
 Given a commercial interest, the undeniable romantic flair of mechanical
 locks and a potential of a healthy competition, there is no reason why
 the topic should not attract more enthusiasts.
 Hopefully, this text will help people willing to take up lock-chart solving.
 A
\begin_inset space ~
\end_inset

second important component would be a publicly available dataset of constraints
 from real-world platforms and a dataset of lock-charts.
 I promise to try persuading our commercial partners towards this direction.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "References"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
UrlFont}{
\backslash
ttfamily
\backslash
small}
\end_layout

\begin_layout Plain Layout


\backslash
printbibliography
\end_layout

\end_inset


\end_layout

\end_body
\end_document
